(self["webpackChunkelement_masters"] = self["webpackChunkelement_masters"] || []).push([[792],{

/***/ 344:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "static/media/170515__rolandasb__forest_ambient_01_loop.a310101290493c58b5ae.ogg";

/***/ }),

/***/ 719:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "static/media/seamless_06.c9213a4db899c1e409fa.jpg";

/***/ }),

/***/ 1032:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./170515__rolandasb__forest_ambient_01_loop.ogg": 344,
	"./830253__nicktayloe__afternoon-woods-in-october-midwest-us-loop.ogg": 3004
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 1032;

/***/ }),

/***/ 1083:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAu0lEQVRYR+2XMQqAMAxF7TW8gEdzcnYUR2cnj+YFvIYSoSDSNj9tIR3iKNL3+htNdJ3y5ZT5nQlYAtkJTGN/hwp4Py7RmqKHCejB2zoEX6B5Od/7qIhIgOAx8N+GRBAJWEAC9zKIBCSQA0clWIESOCLRtkCN3XMpJBMwAUvAElBPwHc/tAHF5stUT2j7S+h3VHIUXEdkEyiR4OC0NiwgrQcELhZQH8m+Va42lNb+lRPVQG14Vg3UllBP4AHdtpQh121K4wAAAABJRU5ErkJgggAA";

/***/ }),

/***/ 1297:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAALUlEQVRYR+3QQREAAAABQfqXFsNnFTizzXk99+MAAQIECBAgQIAAAQIECBAgMBo/ACHo7lH9AAAAAElFTkSuQmCC";

/***/ }),

/***/ 1351:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAjUlEQVRYR+2XOQ7AIAwEoeeXvCu/pE/kIlIOY0fIR4rlAwwDy0ItyaMmz18AAAMwAAMw8DKwtbb3McLMsABnP0SA3ABo9ddySgcgGG8I0UDEVnwC8DQBgH8ZoL1+RtE7luJFxD1YrWPJXrmSBetELAFYQkxLR7NgBSG2ngZhcR7U2vVOhQrg/XUDQLqBA78FQCESgyt9AAAAAElFTkSuQmCC";

/***/ }),

/***/ 1621:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./blocks/diorite_block.png": 8276,
	"./blocks/dirt_block_0001.png": 7157,
	"./blocks/grass_block_0001.png": 1764,
	"./blocks/sand_block_0001.png": 2250,
	"./blocks/sand_block_0002.png": 2145,
	"./blocks/water_block.png": 1635,
	"./entities/player/player_dead_01.png": 2735,
	"./entities/player/player_dead_02.png": 2820,
	"./entities/player/player_dead_03.png": 5325,
	"./entities/player/player_dead_04.png": 3762,
	"./entities/player/player_dead_05.png": 2763,
	"./entities/player/player_dead_06.png": 7728,
	"./entities/player/player_dead_07.png": 8905,
	"./entities/player/player_dead_08.png": 3662,
	"./entities/player/player_dead_09.png": 1351,
	"./entities/player/player_dead_10.png": 1297,
	"./entities/player/player_default_100.A.png": 6847,
	"./entities/player/player_default_100.B.png": 4388,
	"./entities/player/player_target_100.A.png": 2155,
	"./entities/player/player_target_100.B.png": 8336,
	"./hazards/bushes_001.png": 6343,
	"./interactables/berry_bush_01_A.png": 2534,
	"./interactables/berry_bush_01_B.png": 4157,
	"./interactables/berry_bush_02_A.png": 3945,
	"./interactables/berry_bush_02_B.png": 7858,
	"./items/fireball_basic_A.png": 9240,
	"./items/fireball_basic_B.png": 4851,
	"./items/fireball_basic_C.png": 9290,
	"./items/fireball_basic_D.png": 9717,
	"./items/hertz_item.A.png": 7720,
	"./items/hertz_item.B.png": 3475,
	"./projectiles/fireball_basic_A.png": 9792,
	"./projectiles/fireball_basic_B.png": 1083,
	"./projectiles/fireball_basic_C.png": 9954,
	"./projectiles/fireball_basic_D.png": 4205
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 1621;

/***/ }),

/***/ 1635:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAMklEQVRYR+3QQREAAAjDMGYYudgBGXxSBb2kerYeiwECBAgQIECAAAECBAgQIEDgW+AAFGZIgY4rz5YAAAAASUVORK5CYIIA";

/***/ }),

/***/ 1752:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"id":"hertz_item","name":"item.hertz","width":"1","height":"1","textures":["/assets/images/items/hertz_item.A.png","/assets/images/items/hertz_item.B.png"],"animationSpeed":300,"pickup":true,"effect":{"health":"10"},"sfx":"/assets/sound/sfx/zzox-fx_sling-selector.ogg","sfxVolume":0.85}');

/***/ }),

/***/ 1764:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABrklEQVRYR62WLVYDUQyFZ0zNFN/V4MFjUCjWhaphAXhWU8+pqSlkDum5k+bnptMxnZ+X5MtN8l7HzcvufPo8jNXv8Hfpmui+8uF9XwQWx3IpkD7jO/wW3Wd21vcMgAbVvThABSr7SF2N0waoALvf7w7wdjwMH9OO5rgrgASXqw1gDTtZ4NrVAEpfOcVAunbz9TO8Ph4vCrBJzCVQhxHA/nu6OJd7uTCYPGc+soYY35+HxRhK/awCCKDOFOT09DC/QgBdY3vBK3UJgNJiJqiEVQXXIYQLsN1OZ5XTGoqBZp+VwaqS+cMpkeSuFED5MHuvDPSw/4+mV6YFAAYR6az8LAS7ThIIFfDqmjWjTobaqTpeOVC5KwB0YI3ZzGy/ZBChAkLJNJ7XBxY0A3cBPBnZ7C04ToinBNUDneARQPR+Bsg2kioDpgTZPpH2gHXOgGbAnr07BdXoMKMWwdpyjt5WzATQmlqVEJ7pnVYJuvIyW/VNAN1Rs2qhSjcBMNJG2V/1gP1DwsgWAWTbeOSXUqDTlN3zgz4LGGVY2anTsNoLOkDtw6jjfO1aqgfWBsnsfwHb/steztmElwAAAABJRU5ErkJgggAA";

/***/ }),

/***/ 2038:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "static/media/seamless_03.b36cf089998887796c4f.jpg";

/***/ }),

/***/ 2145:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACdElEQVRYR7VXO0pDURB9WYJgIZheLQTdgaJ22lpF7BRxCwER0gYrEVyAG4hY+duBdm4ghYXgEtS5cC7nzpuZ+xLwNUnenTtz5sw3vYfJ4U/z90zuP5qD/TX5mp7p9Dt99vsL+Z0+e3v/bDY3lvK5/Mbj6RI78uC8d3uzlwCIITFqGWwhUC80eD62HGE7PTBgXcK7GigLAAwziyIHxqAzAah5zhcZKJR4ACLgsFkAiKiMwqA9qznEulIOaKS1mEJeDCER+Z2mXSck2zNzAFXAglFVWOwAHGe8JZcBaNrYIJSJJxa9HmNdQLcY2Nq5zkBfn87NHlCrCl1RkIdu1lsAEIHh8CLfH40uGxa2vGd2okRl3aJX7OxufzW5CgbHd4VxKGMQGgB3NQ6DDol2THRDbxXA6spyMzg6SUwwAN1SOXFRlkJ9ZFzuFGVoCQNtrR175xxS9hzyRQ4I8vHVsxmKeQHwPZ1TiQGehv9p3MqpBODsdD1Nw8i4IJ/30SHgMAjjmYEo/ihFJGHU6/VZlIQFgMeXxVQaXfqAB4CznxnTPaBoRDyMIkEojNqrB0DuWl0wMQAAaB6WIHuD+udVbJ5tCnpas6DrFNP9Xn7zjIABec/jGPfgsAnAW0SjDWiWKuFW7TIA1FbMu47fLsMrAYBCLjNNqc4DzgE+0yxZA4z3ihYAKPNmvjWEvArRm7FVJe5KVoupB8TbrGR3tDaqmQBEDUiUe6B0zph/TGr7W+1cGNP7ggZlOVAwACOgi2Orc0InrJU73Atwrlf0VieMjOrm02U5rf3ZKfYBq/atjsZU6tBEyWmVdt4HvJZpVUNtHFt3uD+wrV8YyG2u9XeR7wAAAABJRU5ErkJgggAA";

/***/ }),

/***/ 2147:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "static/media/seamless_02.cdc61ab2fe1638255840.jpg";

/***/ }),

/***/ 2155:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAA8klEQVRYR+2WQQ7DMAgEybUPyP/flwf02sZSrdIUwi6mSiLVyilG3mGxsSc5eEwH68sf4HoOPETWzx9rRlRScHAkvEVCQUIAVpgF2QUYFe8we264AIj4fVnkNs9QK/EgTABUvCuPQKQBmjjjQIu3XPgCQLKHPHeCthDnAqjK3rJar63nPxyoAEAbkDqi72JlAFhBo1HlAUbFXyfjwgDazuZGL6HnjDVfvgm9htP+hwA6qKLZWJv63I2oZ505johj0F1QVQYLCAb4BQT1HqguRepFVAURdcvwUZoFiYTNywjZydEJQYXTAAgkEwOXgFmUiX0CYXFFIWMypoAAAAAASUVORK5CYIIA";

/***/ }),

/***/ 2250:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACJklEQVRYR6VXO05DQQzMOwIdRS5AgQSHoIOWKyBOhMQ1grgGdFwgBR1HAPykWc2bHa838Jokbz8ejz22s7we7r93v8/h5WN3d3sRX9fnePxaP/f7s/ZO197eP3fXV+dtPX7jye4KO/FgfXl+ulkBhKEw6gx2COSFgudl5wjbWcCAO4R3FSgHAIaZxdgHxnDnCqDynA8yUFySARgBh80NgBGVozCoZ5VDfNeaA4q0iin2hyEkIr9T2jUh2Z7NAaiAN45U4dgBOM54t68BUNrYIC4LTxy9GWMzoFMGspifEl9l0jm5AVBd7taZnapeqNQjxFaGoFSrlgLgdQ5DpSZeTwFw8sAwA1BwTDdkOaoDOG9lqFQyAJZYVRtYfrq3AeBS7BpSeMHvZzI7jFVhAKCWhP+RkgPlQmTrwOPD5doNlS6O98jrWU+z+jFdCTnJRnKtpMwsBPi0HWeDyGhumMn+DoBrRpWHmRJmACCcmJ6aDLn4xNCQaRjJxaPYiJWsxzQAOhHNdrFq7AJQ7NMkh8NdDmT0axUcFZmqJ3SlWL0JemAg07gDoHtnmtfKABDNltxsRnSTkGtgPFd0AMBGlYSzDPB9TiUnDyS4MCu1o6x3E9VJALIEzeYHBpsNppuZcNRqZ7qgUwoz5RzoRrIAwSrQuQ5eacK63NFaoE0v7ugqoRrIND3bdKpuaecBppu94Now+iOStXcX4gXzgDv0F+8BXs/y/0i29QMq/F8fgUChegAAAABJRU5ErkJgggAA";

/***/ }),

/***/ 2333:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"id":"player_default_100","name":"entities.player","type":"default","width":"1","height":"1","textures":["/assets/images/entities/player/player_default_100.A.png","/assets/images/entities/player/player_default_100.B.png"],"animationSpeed":500}');

/***/ }),

/***/ 2436:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "static/media/seamless_01.b0589e5cf585a593914d.jpg";

/***/ }),

/***/ 2534:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABI0lEQVRYR+2XMQ7CMAxFE5WFge6sXAtGDoAEKxMrAwdg5Fys7F1YqIr+kNK6tuMUpAopnpP85287Tb2bOPzE+i4DZAeyA9mB7EB24P8cKDZlI31B61uVnJB5QxD2c35L8+xzWWGiAJLw+Vq53bF0s8fQjy5MDEQFgLiUMQAO27Kn/lq6HpAFZDQAFdNeVgGEc0ME0LKHGBxAUBckEAmCBYiJQ6TrgNUNDmIAQMWth1sftxSiBxDLXILhGjIAcXu6EC1ATFzLUBtJrSfQlD8BSC0T1iOKe/P5L4AD9cqzF0uqAG1S6gLOu5wqt18vbAB05MYAUQic2QJw9Q+iuG4R3JVr7XytD7zWfKFWKQCSO9I0qADfZhjbj3FkAVJqnLKWAgHgDQvYnxUVmndjAAAAAElFTkSuQmCC";

/***/ }),

/***/ 2619:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"id":"lava_block","name":"block.lava","type":"block","width":1,"height":1,"collision":false,"flags":{"liquid":true,"lava":true,"swimmable":false},"liquid":{"buoyancy":0.3,"drag":{"x":0.5,"y":0.6},"surface":false,"swimmable":false,"damagePerSecond":20,"resistance":{"drainPerSecond":25,"regenPerSecond":40,"damagePerSecondWhenDepleted":15}},"tintBelowSurface":14189029}');

/***/ }),

/***/ 2735:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAA7UlEQVRYR+2WPQ7DIAyFyZIpt8zWA3XrLTNlaeQBiVIbP/9USaSyYvl9PIPxVE5e08n65Q9wPwdey/Ie3Zt120yHgoM14R4KBVEBrMJWkCFAVLzCjNwQARDxx76X5zxDrUSCYAFQ8aocgXADkLjFAYrnXPgCQE4PeS4E9RDXAsg6PWd1m7vd/3AgAwBtQLVCYQCrYH81QgBRcYK5N0BrJ7lR75DkDLcfckDqB24ASpj5Erhc125E1dIMF7jyQH9BVhlCAL+AMM0D2aVwTURZEFq3VIdSL4gmzH5GyKChvRBU2A2AQFpi4BJYklpiDyZMgSFARslqAAAAAElFTkSuQmCC";

/***/ }),

/***/ 2763:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAxklEQVRYR+2WSw6AIAxEZc8tPZe3ZK9h0QQr9ENLwAS34sxz7MdwTL7CZP9jA+wEdgI7gTUTuGK8ywl5ptQNWmrVdD7C2LwHRKOhAsgwVBqUMbwIfv4FIBGQLK8aZOtTuANo68UMoDXECZoArOYZ5t8AuEWh0FrJ1O6bEmh1RDdAFvRoRQCoaZFzwAuAmhUswEgI0S5YAmAERKswyTXrUZDcAmP3vBWCm5YsAFS0FoQzBl0xgBREatwNIPkf0JxRJ6ARl5x9ANkibCGN1XqfAAAAAElFTkSuQmCC";

/***/ }),

/***/ 2820:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAA60lEQVRYR+2WMQ7DIAxFyZIpt8zWA3XrLTNlSUUlS4TafBtbgiFZTfwf3zawpMHfMlg/PQCPA2oHPtt2tRp2Pw51rjIP/AkJoylCYE0ArzjBtSBEAI346zzTe12RCb+4BMECaMVJ2QPRDZDFLQ5ILvwBaHav8lxYVJdiLoCo3XMNV+Yu4zcHIgDQ3NeVcQNYBUMBvOIZxuXAcIDSzgxDPSSBcXGXA9J50A2QE0ZOApdr7oOILI1wgSsPVxrXZWS9E9QAUb1QTwkHPO+LKKof0GEFH6W9IEiY8qoBtCBa4W4Aa+ej9WYHUEJr/AvvYn0hrfQsOQAAAABJRU5ErkJgggAA";

/***/ }),

/***/ 3004:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "static/media/830253__nicktayloe__afternoon-woods-in-october-midwest-us-loop.8cf51a08e5b09d743c60.ogg";

/***/ }),

/***/ 3344:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "static/media/seamless_05.2794b109e4674b610203.jpg";

/***/ }),

/***/ 3462:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"id":"dirt_block_0001","name":"block.dirt","width":"1","height":"1","texture":"/assets/images/blocks/dirt_block_0001.png","collision":{"top":true,"bottom":true,"left":true,"right":true}}');

/***/ }),

/***/ 3475:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAoklEQVRYR+2V0Q2AIAwFYQBXcP+5XIEBNHyYECztayWBj+d3wx2npjktfvJifqIAC7AAC7DA/gWu47j7fXGW8hHv56QZae+oBST4e0gLGM0hEkMBDd5KWHOWxC8BZJWHBKxbIeB2RpMQC1CABZYXqF/wLInQb7iFwAwJ6/aVYW7D6KtA4JBApAQKhwU8Eh64SwCR8MLdAppEBB4SkCSi8HrWA1utWCGi57SIAAAAAElFTkSuQmCC";

/***/ }),

/***/ 3540:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"id":"bushes_001","name":"hazard.bush","type":"hazard","width":1,"height":1,"texture":"/assets/images/hazards/bushes_001.png","collision":true,"renderAbovePlayer":true,"damage":5,"damageOnce":false,"damagePerSecond":5,"damageDirections":{"top":true,"bottom":true,"left":true,"right":true}}');

/***/ }),

/***/ 3662:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAtElEQVRYR+2WSw6AIAxEYc8tPZe3ZK9h0QQj9IMtYFK3GuY5UxhiWPzExfrBAdwBd8Ad2NOBM6WrnJBHzuaALwEQ3wJgBsTDgfrv65KyjIIFYOkEG8AKQgQAsWhG8k8AzTiGHDADKAv3tmLr7qgxC+hJSF1YTQBmu9AsG0kMnK2JlVu37UYgsMh6caF1qwWBzQrZ918hqEElAcBWKQglDOuyAbggXOFhAOpskL4XOyAVoL6/AabTUCHqXjI2AAAAAElFTkSuQmCC";

/***/ }),

/***/ 3762:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAA4ElEQVRYR+2WMQ7DIAxFyZIpt8zWA2XrLbOUJZUHJErt8o2NSCWygv1fvo1hCYO/ZbB+mADTgelAdwee23bt5ynqdAMg4XzGSBAsQBnMDatHjOEV40d8LY6DaAYgKII41hUephBA7S9gNWFjCfHlwFAAL3HO6jx3vq5qIsT+X0eOizcDaAVLCBOAVZxg/hugnHSp0SRnuHWTA1JTNgNQQo+jmAC4XPceRMlSDxe48kB3gVcZTAA9IFTvAe9SmF5E1n6oTUv4SaYFqQknl2EAtCyocDMAciVr9qgd0CRH9r4BjQZ2If+fK2EAAAAASUVORK5CYIIA";

/***/ }),

/***/ 3929:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"id":"diorite_block","name":"block.dirt","width":"1","height":"1","texture":"/assets/images/blocks/diorite_block.png","collision":{"top":true,"bottom":true,"left":true,"right":true}}');

/***/ }),

/***/ 3945:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABmklEQVRYR+2WoU4DQRCGt2kruQpULYKnQvIAiKYODK6p4AEqeSEsAovCHIIEaI7753Y2s8Ps7h2mCdlVTa7d+eb//5nrzJ34zE5c31WAqkBVoCpQFagK/A8F5ldNZ71Vj49tscHiF3Kvay58vLCvmb90rgTxJ4BSYQ2dA5kMgOKy44f7luptdufu+/0rKVgKYjRAruvF2ZIKM8Ditf+8dg5wN7dNBKVBRgHorkt/4xhov31zm+uGYPhMArC6xuW4WHcmoQjgubfjclCGQLxFAMDhcCYVSHWtAVjulCr8famEVMEEmCI5CsB7gFAOhNwMxYrwsyyALs4dsq+Qli/i7ngKdBBhAcGpkCYBrM7DmPVhIk+FtxEMFPAFAfJrMrxSeDYJIHSeiX5u/gnG28OAMoghA8nQ+ZkOXSkLpOzRJIjfWRPSfQxrmgDGho4DF4ULwTM2oLZA/6Z7+hwArOKp0TIBfCY0BO7YH9poRZMVfjeYANorbbsGk/nAssGRCwoB1puQIQKAu1vRapJ0snAuYGZARUYyuaVJwPkBxy8JnAO6cdwAAAAASUVORK5CYIIA";

/***/ }),

/***/ 4157:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAA+klEQVRYR+2XPQ7CMAxGE5WFhZ2Vc3E8zsXKzsJCFeRKhsS1YzsgVUjOmp/v+SVN25w2bnnj/BQAYSAMhIEwEAb+z8B0PhTpDTpf7u6CzBMwOO/5KeXRcllhVIBe8POY0u629lHDaCBdAAiXKua2gQJZQIYBpOo5MAThbIgA3uq1TzsJggWwhNcGrDY4iBUADbcurhnAfgrRAGiVj8Bwc2qIN4AWrlXohQMIOJQ/AfCGw3ho07V8/gvAwHzK7MXiDYDFe3OwDyw0BiQAqn8ESLofFoDe/qMu7srVzoXWvxiwhMNCVgDJjvQ0dAG0Cr7tFw149tgzlgIDwAu/Ko4VNQcqFwAAAABJRU5ErkJgggAA";

/***/ }),

/***/ 4205:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAu0lEQVRYR+2XwQmAMAxF7RoO4GqeBE8O4Unw5GoO4BpKhIJI2/y0hfQQjyJ9r7/RRNcpX06Z35mAJZCdwDT2d6iA9+MSrSl6mIAevG5n8AVa5uG9j4qIBAgeA/9tSASRgAUkcC+DSEACOXBUghUogSMSbQvU2D2XQjIBE7AELAH1BHz3QxtQbL5M9YS2v4R+RyVHwXVENoESCQ5Oa8MC0npA4GIB9ZHsW+VqQ2ntXzlRDdSGZ9VAbQn1BB5XopQhvIwnHgAAAABJRU5ErkJgggAA";

/***/ }),

/***/ 4388:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAA8UlEQVRYR+2WsQ7CMAxEk4Ff6cbAxP+PTB3Y+BUGUIZUIcTJne2oRaJrLN/zxXYTw85f3Fk//AF+z4HHenr1+ma5PKmi4OCRcA2FggwBWGEWpAtgFc8wPTdEAET8fI3hfuu2xGaIBNEEQMVzdguEGiCJMw6k+JYLXwBI9Zb1XUMcC2B29a2p+HDACwBdQgnIBYARrPtHDWARLSHUANJYsRNiAijFkiO5h1rulP1VnrsBMJWLACmJ1yRIQMdeRJl6lgvQv2DmNcAAMyCo94D3VaheRF4Qo405fJRqQUbCOS8MgIKgwmoAZuMhsbQDSFIm5g20nHUhyaEtwgAAAABJRU5ErkJgggAA";

/***/ }),

/***/ 4851:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAu0lEQVRYR+2XMQqAMAxF7TW8gEdzcnYUR2cnj+YFvIYSoSDSNj9tIR3iKNL3+htNdJ3y5ZT5nQlYAtkJTGN/hwp4Py7RmqKHCejB2zoEX6B5Od/7qIhIgOAx8N+GRBAJWEAC9zKIBCSQA0clWIESOCLRtkCN3XMpJBMwAUvAElBPwHc/tAHF5stUT2j7S+h3VHIUXEdkEyiR4OC0NiwgrQcELhZQH8m+Va42lNb+lRPVQG14Vg3UllBP4AHdtpQh121K4wAAAABJRU5ErkJgggAA";

/***/ }),

/***/ 5325:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAA50lEQVRYR+2WMRKEMAhFY2PlLbfbA9l5Syub3aFgRpGEn8BMdCZpg/mPH8BMqfOaOuunATAcGA5UO7Aty0+27mffs+dQfGm/+KE1I77HkdZ5TpqABM1BqABalhKGxHkRBLI0iGYAEmQHEHGKgQCQ7FFBLU5C3BzoChAlbhXlef/iQARAqeW0K3ED1ApKCBeAV5xg3g1wtpPc4BrKOaPtuxzIzYNmADowshOQH9ezBhFbGuECMoZvXfAYgKhakF1iTkIZEHUVTS+iqOuwpiX8Jqx1wxLmBGEA1BFUuBnA8xqqLsJoMe28P0eafSGWcnmWAAAAAElFTkSuQmCC";

/***/ }),

/***/ 5688:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"id":"water_block","name":"block.water","type":"block","width":1,"height":1,"collision":false,"flags":{"liquid":true,"water":true,"swimmable":true},"liquid":{"buoyancy":0.5,"drag":{"x":0.55,"y":0.65},"surface":true,"damagePerSecond":0,"oxygen":{"drainPerSecond":20,"regenPerSecond":35,"damagePerSecondWhenDepleted":10}},"tintBelowSurface":3829853}');

/***/ }),

/***/ 5998:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"id":"player_dead","name":"entities.player","type":"dead","width":"1","height":"1","textures":["/assets/images/entities/player/player_dead_01.png","/assets/images/entities/player/player_dead_02.png","/assets/images/entities/player/player_dead_03.png","/assets/images/entities/player/player_dead_04.png","/assets/images/entities/player/player_dead_05.png","/assets/images/entities/player/player_dead_06.png","/assets/images/entities/player/player_dead_07.png","/assets/images/entities/player/player_dead_08.png","/assets/images/entities/player/player_dead_09.png","/assets/images/entities/player/player_dead_10.png"],"animationSpeed":300}');

/***/ }),

/***/ 6343:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAAEBElEQVR4Xu2abW7cMAxEm6O2R+hBeoTmqA2Q3QIObO2+ETn+yE5/FrJM8nGGkjdvPy747/3vn3//w/756/fbbArLfZZ7VPZUY5kOXn1R5/oA6KzmxF4BMFG06iNuu3DvP8r/MhbkLpB7/wB4IsEAEArkPqWoMEYzicyqS1pQAFQn6sTzpJsmtt185DAF7JnkMnMi4aMuSgQGiX+k2i8WFABrQQTAhkm4Z8BInSMVWhSwp+QrCai+X1H5SA0qmOX6oQUFALejABBkcGoFkJPJKFcyrNRnHSqsAFDrQ941vIiRh9VhFQDrCgSAYF+HKUC1AlU9amJqzSr2WFE5qQNSQADcKqCCDIB756iFU2fV6GJYAlCxBfJikmTXjbcSj7sO6HO0moC6vpIkmQeVeCqxkfcGACG4YWVEnZcHoA5/h61V5kcATHZu5eipWtapLSgKmDzGVWSrdhCxnQpIYiMkBvSLGNmIJBMA64tbANw7h5xeHCrcFYBjiBHldRWuax9iX/IQrhTiqGfVrg+AyeHfVbiufUoK6BqkxI6IMtR4SPLk0NGlnlGOls/RJLHRGvJlUQWmFrECjzTcMp4A2OiE0wFQO4h0AelioqRlbOrf7aj7j9aT/x9BRQoIAFLix2sCQLiIdVkQOU3Z/zLOnYzam0TN7piHQ1g96pHk3cmQGNR54445AJ5QOwwA8Sy14xzJkFPW6HR0Bgtaxr/rKYgkXwE8shq1CdT1JOaRvQeA8SJGlGoB4BjmlUsTiYesIZ1O1izfFQD3igUAaZ1JuyDFJWsmQ1w9tqsCjhq8qmU5Bi+JwW5BAbDGEAVsfBc6tQLOcJXvuiSOCu0GULoHBEB9/AbAxnGz8rlCRXJ5AF3HxK5fzSoA7L8JO/w0ADZODuSc23UMfTkA5EMS+UHcAeDMe6p1a/vTxK4OPUpVXVADQJiOjlllAUA2Ve8KQp0+lzqK5dhTvTAiCwoAtV1u6wngABBOdyqGXQE4hpgq50qBHBYaAE+InOHk1mZBUcCatkUBblvY8x7gyEVVlawAR9DEu0k3kX3cgANgkkIX4G8FQE1msvb4zE72V0Ge2oICQDjGOU5BAXAiAA7AjgPFt7WgANhQg0qbDDFHV5L3duWi7tM2hI/6lkKKS9ZU5k3l2QC406kUsfJsAFwZwMivu+xI9VNiNWSN+l51/TKGkgIC4FaBACBtLaxRC6qutyig6/hYGWhCjR8uJQXtirPNggLgVgH1whgAkxfMl1CA2k1HWVAlzlMroJJYBYY6AypxBkCDBQVApd0D4GsFiPyb673ajsRA1pA4Y0FRQBRAlCKtqciz8qwU5IPFJAayhsQTC4oFxYKIUqQ1FXlWnpWCjAVtV+DVAHwAC2I2Qp8YIY4AAAAASUVORK5CYII=";

/***/ }),

/***/ 6411:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"id":"player","name":"entities.player","speed":4.5,"jumpHeight":1.2,"maxHealth":100,"defaultAnimation":"player_default","deadAnimation":"player_dead","targetAnimation":"player_target"}');

/***/ }),

/***/ 6431:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./background/170515__rolandasb__forest_ambient_01_loop.ogg": 344,
	"./background/830253__nicktayloe__afternoon-woods-in-october-midwest-us-loop.ogg": 3004,
	"./sfx/zzox-fx_nite-hit-item.ogg": 9750,
	"./sfx/zzox-fx_sling-selector.ogg": 7973
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 6431;

/***/ }),

/***/ 6513:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"id":"player_target_100","name":"entities.player","type":"target","width":"1","height":"1","textures":["/assets/images/entities/player/player_target_100.A.png","/assets/images/entities/player/player_target_100.B.png"],"animationSpeed":500}');

/***/ }),

/***/ 6523:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1354);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6314);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `*, *::before, *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

html, body, #root {
    height: 100%;
    width: 100%;
}

body {
    margin: 0;
    padding: 0;
    line-height: 1.5;
}

#root {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

@supports (min-height: 100dvh) {
    #root {
        min-height: 100dvh; /* dynamic viewport height for mobile */
    }
}
`, "",{"version":3,"sources":["webpack://./src/index.css"],"names":[],"mappings":"AAAA;IACI,sBAAsB;IACtB,SAAS;IACT,UAAU;AACd;;AAEA;IACI,YAAY;IACZ,WAAW;AACf;;AAEA;IACI,SAAS;IACT,UAAU;IACV,gBAAgB;AACpB;;AAEA;IACI,iBAAiB;IACjB,aAAa;IACb,sBAAsB;AAC1B;;AAEA;IACI;QACI,kBAAkB,EAAE,uCAAuC;IAC/D;AACJ","sourcesContent":["*, *::before, *::after {\n    box-sizing: border-box;\n    margin: 0;\n    padding: 0;\n}\n\nhtml, body, #root {\n    height: 100%;\n    width: 100%;\n}\n\nbody {\n    margin: 0;\n    padding: 0;\n    line-height: 1.5;\n}\n\n#root {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n}\n\n@supports (min-height: 100dvh) {\n    #root {\n        min-height: 100dvh; /* dynamic viewport height for mobile */\n    }\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 6570:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./blocks/diorite_block.json": 3929,
	"./blocks/dirt_block_0001.json": 3462,
	"./blocks/grass_block_0001.json": 7865,
	"./blocks/lava_block.json": 2619,
	"./blocks/sand_block_0001.json": 7323,
	"./blocks/sand_block_0002.json": 7210,
	"./blocks/water_block.json": 5688,
	"./entities/player/player.json": 6411,
	"./entities/player/player_dead.json": 5998,
	"./entities/player/player_default.json": 2333,
	"./entities/player/player_target.json": 6513,
	"./hazards/bushes_001.json": 3540,
	"./interactables/berry_bush_01.json": 7043,
	"./interactables/berry_bush_01_used.json": 8669,
	"./items/fireball_ammo.json": 8443,
	"./items/hertz_item.json": 1752,
	"./projectiles/firebal_basic.json": 8097
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 6570;

/***/ }),

/***/ 6847:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAA6klEQVRYR+2WQQ6EIAxFceFVZj/3P4R7r+LCkWRIAKH9LT9RE9kZCf/1F9pO4eI1XawfXoDnObAu8y7dm893MwUFb9aEaygURAWwCltBRIBR8QQjudEFYIlrEE0AtrgEQQM4bA4HuFhYW6k4AXiij+JpWSEoAFEcceC/r9AsPjzRe5pZnooXYMiBaKUnbbQUSBUuB4MroSea1iVsCfaAhlLgeQH1U6TVARSmdud+ADES1l1AZgNaM0JSADWjrKmIsx8imO/pPcX7TkQsJ7ThVB1KvSCacDoXBkBBUGE3gPXyafvNDmgHWv//AIcTeSHa0ksZAAAAAElFTkSuQmCC";

/***/ }),

/***/ 7043:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"id":"berry_bush_01","name":"interactable.berry_bush_01","width":"1","height":"1","texture":"/assets/images/interactables/berry_bush_01_A.png","pickup":true,"effect":{"health":"1"},"sfx":"/assets/sound/sfx/zzox-fx_sling-selector.ogg","sfxVolume":0.85}');

/***/ }),

/***/ 7157:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABVklEQVRYR72X0Q3CMAxE2+92JgZgBAZgNAZhJ76LWimVY2zfOQnlD5TEz2f7Eubnfdqmiz6v93JEetw+Z8T53wAlqA5cCA6AfZGkukiQI0yTAiOBKQApo1anV7kQwMo0mz1a/wOgN5TvVgd7vYIaT+6jSrBviDLJwGloCkAG18GQxGii0gDlwIzMEQQE8DKUSnSVYF2XLRol2YRlnReQBZHq0WPYW2uvDBWAN4Ky7ozxZGBdBSw5PWMqgDucdk0EbBqRPFBKx2amxzaCSPWAd6Xq+qJSQie0ZGSz91zT20/1QCZ4ZNvWOeeDBMmbgWDMq3oRIb/W9os6OyqDThRexxYcM2qRW1aPUsuKmQAly+iFxJQNXkaeAroM7D3Q9B7IQHj94V3fwxTINHL3HxM0ZmikoRNa1ip/i2S2emPIXcBKzPaLa0St3RwBRuPY1IQ9agwbw1EQX2odL4NwzQNBAAAAAElFTkSuQmCC";

/***/ }),

/***/ 7210:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"id":"sand_block_0002","name":"block.sand","width":"1","height":"1","texture":"/assets/images/blocks/sand_block_0002.png","collision":{"top":true,"bottom":true,"left":true,"right":true}}');

/***/ }),

/***/ 7323:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"id":"sand_block_0001","name":"block.sand","width":"1","height":"1","texture":"/assets/images/blocks/sand_block_0001.png","collision":{"top":true,"bottom":true,"left":true,"right":true}}');

/***/ }),

/***/ 7720:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAoUlEQVRYR+2VQQ6AIAwE4RV+1Gf4UV6h4WBCsLTbSgKH9dwww6hpToufvJifKMACLMACLLB/ges47n5fnKV8xPs5aUbaO2oBCf4e0gJGc4jEUECDtxLWnCXxSwBZ5SEB61YIuJ3RJMQCFGCB5QXqFzxLIvQbbiEwQ8K6fWWY2zD6KhA4JBApgcJhAY+EB+4SQCS8cLeAJhGBhwQkiSi8nvUAN8ZYIdGoG9MAAAAASUVORK5CYIIA";

/***/ }),

/***/ 7728:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAxklEQVRYR+2WSw6AIAxEZc8tPZe3ZK9h0QQr9ENLwAS34sxz7MdwTL7CZP9jA+wEdgI7gTUTuGK8ywl5ptQNWmrVdD7C2LwHRKOhAsgwVBqUMbwIfv4FIBGQLK8aZOtTuANo68UMoDXECZoArOYZ5t8AuEWh0FrJ1O6bEmh1RDdAFvRoRQCoaZFzwAuAmhUswEgI0S5YAmAERKswyTXrUZDcAmP3vBWCm5YsAFS0FoQzBl0xgBREatwNIPkf0JxRJ6ARl5x9ANkibCGN1XqfAAAAAElFTkSuQmCC";

/***/ }),

/***/ 7858:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABYElEQVRYR+2XsW7CQBBED4HLQE1Lka/iW/I1+SFaClp6KJCCkckentMy7N750iBF5xLs27czs2t5Ft58zd5cPzSApkBToCnQFGgK/A8F5tvlYL1Vb9+nYoPFG3KvaxS+bexj5ochlCD+BFAqzNA5kGoAKc4dL46/JT+70J+vrmAexGSAXNeLjy4WBoAA9WubhUEmAVhd57KhgRimCsDqOh6+v7odChjuEVugjPwmCgmAXAinq4DXdY3cgJHCWgmtgglQIzk6i0GUHBjes2pZAC4OcnSu5UfxJDsFEZPBqrkA5oiN3mHUBADePsHQKL5YNZ4jsNUApY+X3PxHdUZ7oIgOYsqAGzo10+wld6lBvV2AM4bLY01HgKmh055bvj8B0HLCf4Aedj8PAG+1emnWcut5Zxt0ePWGRH5MAPaKvWdZ02So9BefGcOaAMLXKq6mlHI6IRcwDZAeK2xJ3Icg3gHRrQOc3CcxgwAAAABJRU5ErkJgggAA";

/***/ }),

/***/ 7865:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"id":"grass_block_0001","name":"block.grass","width":"1","height":"1","texture":"/assets/images/blocks/grass_block_0001.png","collision":{"top":true,"bottom":true,"left":true,"right":true}}');

/***/ }),

/***/ 7973:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "static/media/zzox-fx_sling-selector.e72674ca2ded3aca6a78.ogg";

/***/ }),

/***/ 8097:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"id":"fireball_basic","name":"projectile.fireball","type":"projectile","width":0.25,"height":0.25,"textures":["/assets/images/projectiles/fireball_basic_A.png","/assets/images/projectiles/fireball_basic_B.png","/assets/images/projectiles/fireball_basic_C.png","/assets/images/projectiles/fireball_basic_D.png","/assets/images/projectiles/fireball_basic_C.png","/assets/images/projectiles/fireball_basic_B.png"],"animationSpeed":80,"speed":14,"damage":12,"lifespan":600,"hitboxScale":0.8,"collisionWithPenetration":"true","collisionWithTiles":true,"collisionWithEntities":true,"maxBounces":3,"bounceDamping":0.6,"ricochetRandom":0.15,"directional":true,"sfx":"/assets/sound/sfx/zzox-fx_nite-hit-item.ogg","sfxVolume":0.85}');

/***/ }),

/***/ 8237:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "static/media/seamless_04.228c1b290f6042f321b0.jpg";

/***/ }),

/***/ 8276:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAGqUlEQVRYR22X229UZRTF9whSsHaAammhUkl68QK0QiVGi603isTUByIKwUc1RH2ivuELf4CNRpPGy7tEpA+MijReAME3wRav0zbBYi9DtUintZSA4/fb4zr9JJykOdOZ7+zL2muvvU9qy5YthcoVK+zWsjIrLS21dDptVeH/mdk5GxwatCWLF9vs5cvG1bRurd11z7320cGD/n9dbZ39MZGzuStXrKWlxbq7u622ttbKly+3v6byfr6qerUdPfq5Pbtjh01O/mkTuZxlBwfdz9TUlKWe3727gPOhoSEjkMqqKuvoeNqOHz9mbW2P+J2A+n740Z1Wrqjw/wnkUnCCcb7D2MzMjDsvCUFzJjs45METCM9z5/q4p8d94TfV09NTOHv2rA1ks1bf0GBjY2O2cuVKN9jf3+8HX3jxJQ+E3zY0NTk6a9bUGM+tX7/eystvswMHPkwQzF2Y8Ix//fknq6is9N/JnntvCHh4eNgTbairs9TLr7xaUGY4oAyzl+cC9CWWGx9PDo5fuOBBqUQgkMkcTtDChhyfPn3GMyVIICd7ylW6pMRkB7RI1BEgMozh+J9rV/0H4MfQyMjvIdLapPZkRracEVqxc7IWT3C6ceMGR0LfUQYFYZayVFfXmwXIRh0xeNOChU68dLrMM4YPXDKiOwGDxlyo8f2bNjm8/IZxkRjnEHZZsAUpn3j8seQcNkHGS0BWGATyHc/tsvGR887epeFBjMJaAtFnHIOQWE12sXPI19HR4c5BlLIqEb4jWcrFldq/f3+hrGyp5fOXPOOBgQFrbm4On/NuBCenTp1KCAlR1QVuIVxCQ9/jRPBnMhkrWXSzowRpOcOlBFPHjh0vxAzWAbLi+uD99+zhzZvtm5MnbSqft/r6+oSIYrg6ZOfOXZ61nGNX7R0Hzpki6pkiAuphoGpte9ShJ/MFCxf5Z4KgbRAbsgA+YKQM4oR4QotC3JmZaZsOAXMR+Lq1ax2FL778yp0TBIR0Emazvzir79vQHNW9WEcccKnO3NXTZA4J76ypcdGJr9z4mAsNuvFb6HuJk7pB4pUIkeoXi0exvpkkkGLvZwISDwVefOu1xXDcsgTNGVo3tFRA4u9AwlsssNFZTydIjuGbc0BO+YG6xgpXZP5QIGfWntq2LVE2Zd++9UlH6dMjR2zv3s7/tON80jVCTnxRt6C8lDX1bnd34Uxf3/+ERbXlIS4Cg4Q8AEfQf+qXm5iw1ta2hKzUenZ21p7Zvt31gO4i+4qK2xNFbGpstL4g8Sgt7ewkxCFEy4WHmGaainwPnGYFHzTT09O2PRgXUoiPyEcSzvgQNH/oPEHEyXAedZVAOQkpAUZoGVhLltJ7EMBZDKM6Q4QDUiGoWaHA4QFBMLA0EzSkFJx3AUMCZwhOPGxEQkgXTzTGMGqpEsEZzQU5h4w6J2dSW2kCLesISFKLQ6KogGK7ECAYnaOtpP8qgZxoR2CexG2MnDPeGwMHKI9QdQSoSRzE9TrPDKfXIaJ6W0p5oxlAEAiY7mROy6WDLqCqZF6U/ryl9uzZU9ACojVJg0eiAwpsMRAUItasXm1qP00/DaCYZEgyqlhE9LATOSY4SafinRDVglDcZVCl6O3tdZLeSN00WLTGIbNbgz6AgkqncY19glAZkp0Qp/HA4YCCUJ2114n1WsdUBqT8RJDn6uo7vNVAg11DC6k0RXwh0EQJMc7sVpbt7e3O/HhyAaWCgYiUAX4gx5oJQiNGIZZzgle7U+pkJ9SEihcI7Xw4jbPhexAiiMmLFxNIpRuQTAjUhnOgQvDasLWWM39SnZ2vFdQuN5p4WjYQmeqwJWnHUyZST+2R8ZZE5q1BTa9dvZIMIAKf59ngfAk0JtFo5j7wa9FoaLjbGNksHGJ53Fo1oUV5OYlXNUQNZxI4Zsj3Z77zUlEy7Zs+jHAueEQQyfPo6KitWrUq2ZTFCe17vIjIOUbllOd7Dh3y+bI59L5+E5HVvs4BbcSQA6GIZ4CGVGNjk2/K87P/fLIVa9mI3x0419X1hq9wegcgKL5XEiQdONBZ0AGUiVWqKEx5XzzQ+fmlNZ+0WIyYYMW4ukTjO96mQQcE0AhGOncfx8X+/TqB79y54aR/MahFcyQMIL03wmC64IEHW3wwxR0hRWXNZ/AAP5/Ty5Ynr2zarrwLmPd6CKbHr1RECXk0avX6pdZkktL7OiO5ZfCo9hDwyGefeP/DiX37Xncy06KOAIqG1CI+QK46Xe+cUnChbrHUqhyCnSC0jGpmEOQ7b7/lzkGUaYli/gsGqL0FLGLzYQAAAABJRU5ErkJgggAA";

/***/ }),

/***/ 8336:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAA70lEQVRYR+2WUQ+DMAiE8cXs///axZfNJmvGHMgdZVGTNT5Z0vs4WtpJDh7TwfryB7ieAw+R9fPHmhGVFBwcCW+RUJAQgBVmQXYBRsU7zJ4bLgAifptnuS8L1Eo8CBMAFe/KIxBpgCbOONDiLRe+AJDsIc+doC3EuQCqsres1mvr+Q8HKgDQBqSO6LtYGQBW0GhUeYBR8dfJuDCAtrO50UvoOWPNl29Cr+G0/yGADqpoNtamPncj6llnjiPiGHQXVJXBAoIBfgFBvQeqS5F6EVVBRN0yfJRmQSJh8zJCdnJ0QlDhNAACycTAJWAWZWKfKzlFIVEIV/gAAAAASUVORK5CYIIA";

/***/ }),

/***/ 8443:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"id":"fireball_ammo","name":"item.fireball","width":"1","height":"1","textures":["/assets/images/items/fireball_basic_A.png","/assets/images/items/fireball_basic_B.png","/assets/images/items/fireball_basic_C.png","/assets/images/items/fireball_basic_D.png","/assets/images/items/fireball_basic_C.png","/assets/images/items/fireball_basic_B.png"],"animationSpeed":300,"pickup":true,"effect":{"fireball":"10"},"sfx":"/assets/sound/sfx/zzox-fx_sling-selector.ogg","sfxVolume":0.85}');

/***/ }),

/***/ 8669:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"id":"berry_bush_01_used","name":"interactable.berry_bush_01_used","width":"1","height":"1","texture":"/assets/images/interactables/berry_bush_01_B.png","pickup":false}');

/***/ }),

/***/ 8870:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./seamless_01.jpg": 2436,
	"./seamless_02.jpg": 2147,
	"./seamless_03.jpg": 2038,
	"./seamless_04.jpg": 8237,
	"./seamless_05.jpg": 3344,
	"./seamless_06.jpg": 719
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 8870;

/***/ }),

/***/ 8905:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAtUlEQVRYR+2WQQ7AIAgE691f9l39pfc2HkgsRUHBaFJ6NYHpLi6GY/EXFvc/HMAVcAVcgT0VuGK8y4Q8U5oG+imMm2eQ/wBQfz/bipcFHADenBbWqAAs5kMFsFyB5QB4QGGGamDUucqC2nNuGCAX7L0JFAQASEJNlISWD1esDpnxFiq0lCnP9gSwmgVJjDfXrJUVrbxg97wWggsrFgBk7AXhGkNdMYAURNp4GMAyE3KtbgWsAR7iOFwhru9JZwAAAABJRU5ErkJgggAA";

/***/ }),

/***/ 8921:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(6540);
// EXTERNAL MODULE: ./node_modules/react-dom/client.js
var client = __webpack_require__(5338);
// EXTERNAL MODULE: ./node_modules/react-router/dist/development/chunk-4WY6JWTD.mjs
var chunk_4WY6JWTD = __webpack_require__(5052);
// EXTERNAL MODULE: ./node_modules/react-redux/dist/react-redux.mjs
var react_redux = __webpack_require__(1468);
// EXTERNAL MODULE: ./node_modules/styled-components/dist/styled-components.browser.esm.js + 9 modules
var styled_components_browser_esm = __webpack_require__(7581);
// EXTERNAL MODULE: ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs + 3 modules
var redux_toolkit_modern = __webpack_require__(3816);
;// ./src/store/slices/gameSlice.js
/**
 * Game Slice
 * Manages game-level state (maps, registry, game status)
 */


const initialState = {
  activeMapData: null,
  tileMapData: [],
  objectMapData: [],
  objectTextureIndices: {},
  // Track texture index per object position { index: textureIndex }
  mapWidth: 20,
  mapHeight: 15,
  isLoading: false,
  error: null,
  isPaused: false,
  isGameOver: false
};
const gameSlice = (0,redux_toolkit_modern/* createSlice */.Z0)({
  name: 'game',
  initialState,
  reducers: {
    setActiveMap: (state, action) => {
      const {
        mapData,
        tileMapData,
        objectMapData,
        mapWidth,
        mapHeight
      } = action.payload;
      state.activeMapData = mapData;
      state.tileMapData = tileMapData;
      state.objectMapData = objectMapData;
      state.objectTextureIndices = {}; // Reset texture indices on new map
      state.mapWidth = mapWidth;
      state.mapHeight = mapHeight;
      state.isGameOver = false;
    },
    updateObjectMap: (state, action) => {
      state.objectMapData = action.payload;
    },
    removeObjectAtIndex: (state, action) => {
      const index = action.payload;
      if (state.objectMapData[index] !== undefined) {
        state.objectMapData[index] = null;
      }
    },
    updateObjectAtIndex: (state, action) => {
      const {
        index,
        newId
      } = action.payload;
      if (state.objectMapData[index] !== undefined) {
        state.objectMapData[index] = newId;
      }
    },
    setObjectTextureIndex: (state, action) => {
      const {
        index,
        textureIndex
      } = action.payload;
      state.objectTextureIndices[index] = textureIndex;
    },
    setLoading: (state, action) => {
      state.isLoading = action.payload;
    },
    setError: (state, action) => {
      state.error = action.payload;
    },
    setPaused: (state, action) => {
      state.isPaused = action.payload;
    },
    setGameOver: (state, action) => {
      state.isGameOver = action.payload;
    },
    resetGame: state => {
      return {
        ...initialState,
        activeMapData: state.activeMapData
      };
    }
  }
});
const {
  setActiveMap,
  updateObjectMap,
  removeObjectAtIndex,
  updateObjectAtIndex,
  setObjectTextureIndex,
  setLoading,
  setError,
  setPaused,
  setGameOver,
  resetGame
} = gameSlice.actions;
/* harmony default export */ const slices_gameSlice = (gameSlice.reducer);
;// ./src/constants/gameConstants.js
/**
 * Game Constants
 * All game-wide constants centralized in one place
 */

// Physics Constants
const TILE_SIZE = 32;
const GRAVITY = 0.6;
const TERMINAL_VELOCITY = 12;
const MOVE_SPEED = 4;
const JUMP_FORCE = 10;

// Player Stats Constants
const MAX_HEALTH = 100;
const MAX_OXYGEN = 100;
const MAX_LAVA_RESIST = 100;

// Combat Constants
const SHOOT_COOLDOWN = 350; // milliseconds
const HIT_FLASH_DURATION = 500; // milliseconds

// Animation Constants
const IDLE_ANIMATION = 'idle';
const RUN_ANIMATION = 'run';
const JUMP_ANIMATION = 'jump';

// Liquid Constants
const WATER_HORIZONTAL_DAMPING = 0.82;
const LAVA_HORIZONTAL_DAMPING = 0.78;

// Default Liquid Parameters
const DEFAULT_OXYGEN_PARAMS = {
  drainPerSecond: 20,
  regenPerSecond: 35,
  damagePerSecondWhenDepleted: 10
};
const DEFAULT_LAVA_PARAMS = {
  drainPerSecond: 25,
  regenPerSecond: 40,
  damagePerSecondWhenDepleted: 15
};

// Timing Constants
const HAZARD_DAMAGE_TICK_INTERVAL = 1000; // milliseconds
const LIQUID_DAMAGE_TICK_INTERVAL = 1000; // milliseconds

// Direction Constants
const DIRECTION_RIGHT = 1;
const DIRECTION_LEFT = (/* unused pure expression or super */ null && (-1));

// Map Defaults
const DEFAULT_MAP_WIDTH = 20;
const DEFAULT_MAP_HEIGHT = 15;

// Viewport Constants
const VIEWPORT_DEAD_ZONE_LEFT = 0.3;
const VIEWPORT_DEAD_ZONE_RIGHT = 0.7;

// Sound Constants
const DEFAULT_BACKGROUND_MUSIC_VOLUME = 0.6;
const DEFAULT_SFX_VOLUME = 0.5;
;// ./src/store/slices/playerSlice.js
/**
 * Player Slice
 * Manages player state (position, health, resources, etc.)
 */



const playerSlice_initialState = {
  x: 0,
  y: 0,
  width: 32,
  height: 32,
  vx: 0,
  vy: 0,
  isGrounded: false,
  direction: 1,
  animation: 'idle',
  health: 90,
  maxHealth: MAX_HEALTH,
  ammo: 0,
  oxygen: MAX_OXYGEN,
  maxOxygen: MAX_OXYGEN,
  lavaResist: MAX_LAVA_RESIST,
  maxLavaResist: MAX_LAVA_RESIST,
  projectiles: [],
  inWater: false,
  headUnderWater: false,
  atSurface: false,
  liquidType: null,
  hitTimerMs: 0
};
const playerSlice = (0,redux_toolkit_modern/* createSlice */.Z0)({
  name: 'player',
  initialState: playerSlice_initialState,
  reducers: {
    updateState: (state, action) => {
      return {
        ...state,
        ...action.payload
      };
    },
    setPosition: (state, action) => {
      const {
        x,
        y
      } = action.payload;
      state.x = x;
      state.y = y;
    },
    setVelocity: (state, action) => {
      const {
        vx,
        vy
      } = action.payload;
      state.vx = vx;
      state.vy = vy;
    },
    setHealth: (state, action) => {
      state.health = Math.max(0, Math.min(state.maxHealth, action.payload));
    },
    addHealth: (state, action) => {
      state.health = Math.max(0, Math.min(state.maxHealth, state.health + action.payload));
    },
    takeDamage: (state, action) => {
      state.health = Math.max(0, state.health - action.payload);
      state.hitTimerMs = Math.max(state.hitTimerMs, 500);
    },
    setAmmo: (state, action) => {
      state.ammo = Math.max(0, action.payload);
    },
    addAmmo: (state, action) => {
      state.ammo = Math.max(0, state.ammo + action.payload);
    },
    setOxygen: (state, action) => {
      state.oxygen = Math.max(0, Math.min(state.maxOxygen, action.payload));
    },
    setLavaResist: (state, action) => {
      state.lavaResist = Math.max(0, Math.min(state.maxLavaResist, action.payload));
    },
    setProjectiles: (state, action) => {
      state.projectiles = action.payload;
    },
    addProjectile: (state, action) => {
      state.projectiles.push(action.payload);
    },
    removeProjectile: (state, action) => {
      state.projectiles = state.projectiles.filter(p => p.id !== action.payload);
    },
    setDirection: (state, action) => {
      state.direction = action.payload;
    },
    setAnimation: (state, action) => {
      state.animation = action.payload;
    },
    setGrounded: (state, action) => {
      state.isGrounded = action.payload;
    },
    setInWater: (state, action) => {
      state.inWater = action.payload;
    },
    setLiquidType: (state, action) => {
      state.liquidType = action.payload;
    },
    resetPlayer: () => playerSlice_initialState
  }
});
const {
  updateState,
  setPosition,
  setVelocity,
  setHealth,
  addHealth,
  takeDamage,
  setAmmo,
  addAmmo,
  setOxygen,
  setLavaResist,
  setProjectiles,
  addProjectile,
  removeProjectile,
  setDirection,
  setAnimation,
  setGrounded,
  setInWater,
  setLiquidType,
  resetPlayer
} = playerSlice.actions;
/* harmony default export */ const slices_playerSlice = (playerSlice.reducer);
;// ./src/store/slices/settingsSlice.js
/**
 * Settings Slice
 * Manages game settings (audio, graphics, controls, etc.)
 */


const settingsSlice_initialState = {
  sound: {
    enabled: false,
    masterVolume: 1.0,
    sfxVolume: 0.5,
    musicVolume: 0.6
  },
  graphics: {
    backgroundParallaxFactor: 0.3,
    weatherRain: 0,
    weatherSnow: 0,
    weatherClouds: 0,
    weatherFog: 0,
    weatherThunder: 0
  },
  ui: {
    healthBarEnabled: true,
    oxygenBarEnabled: true,
    lavaBarEnabled: true,
    waterSplashesEnabled: true,
    lavaEmbersEnabled: true
  },
  controls: {
    keyUp: 'w',
    keyDown: 's',
    keyLeft: 'a',
    keyRight: 'd',
    keyJump: 'Space',
    keyShoot: 'MouseLeft'
  }
};

// Load settings from localStorage
const loadSettings = () => {
  try {
    const saved = localStorage.getItem('game_settings');
    if (saved) {
      const parsed = JSON.parse(saved);
      return {
        ...settingsSlice_initialState,
        ...parsed
      };
    }
  } catch (error) {
    console.error('Failed to load settings:', error);
  }
  return settingsSlice_initialState;
};
const settingsSlice = (0,redux_toolkit_modern/* createSlice */.Z0)({
  name: 'settings',
  initialState: loadSettings(),
  reducers: {
    updateSettings: (state, action) => {
      const newState = {
        ...state,
        ...action.payload
      };
      // Save to localStorage
      try {
        localStorage.setItem('game_settings', JSON.stringify(newState));
      } catch (error) {
        console.error('Failed to save settings:', error);
      }
      return newState;
    },
    setSoundEnabled: (state, action) => {
      state.sound.enabled = action.payload;
      try {
        localStorage.setItem('game_sound_enabled', action.payload ? '1' : '0');
      } catch (error) {
        console.error('Failed to save sound setting:', error);
      }
    },
    setSoundVolume: (state, action) => {
      const {
        type,
        volume
      } = action.payload;
      if (type === 'master') state.sound.masterVolume = volume;else if (type === 'sfx') state.sound.sfxVolume = volume;else if (type === 'music') state.sound.musicVolume = volume;
    },
    setGraphicsSetting: (state, action) => {
      const {
        key,
        value
      } = action.payload;
      if (state.graphics[key] !== undefined) {
        state.graphics[key] = value;
      }
    },
    setUISetting: (state, action) => {
      const {
        key,
        value
      } = action.payload;
      if (state.ui[key] !== undefined) {
        state.ui[key] = value;
      }
    },
    setControlBinding: (state, action) => {
      const {
        key,
        value
      } = action.payload;
      if (state.controls[key] !== undefined) {
        state.controls[key] = value;
      }
    },
    resetSettings: () => {
      try {
        localStorage.removeItem('game_settings');
      } catch (error) {
        console.error('Failed to clear settings:', error);
      }
      return settingsSlice_initialState;
    }
  }
});
const {
  updateSettings,
  setSoundEnabled,
  setSoundVolume,
  setGraphicsSetting,
  setUISetting,
  setControlBinding,
  resetSettings
} = settingsSlice.actions;
/* harmony default export */ const slices_settingsSlice = (settingsSlice.reducer);
;// ./src/store/slices/uiSlice.js
/**
 * UI Slice
 * Manages UI state (modals, menus, notifications, etc.)
 */


const uiSlice_initialState = {
  isMapModalOpen: true,
  isSettingsOpen: false,
  isTerminalOpen: false,
  isPauseMenuOpen: false,
  notifications: [],
  cameraScrollX: 0,
  shouldCenterMap: false
};
const uiSlice = (0,redux_toolkit_modern/* createSlice */.Z0)({
  name: 'ui',
  initialState: uiSlice_initialState,
  reducers: {
    setMapModalOpen: (state, action) => {
      state.isMapModalOpen = action.payload;
    },
    setSettingsOpen: (state, action) => {
      state.isSettingsOpen = action.payload;
    },
    setTerminalOpen: (state, action) => {
      state.isTerminalOpen = action.payload;
      // Also set global flag for game loop
      try {
        window.__GAME_TERMINAL_OPEN__ = action.payload;
      } catch {}
    },
    setPauseMenuOpen: (state, action) => {
      state.isPauseMenuOpen = action.payload;
    },
    addNotification: (state, action) => {
      state.notifications.push({
        id: Date.now(),
        timestamp: new Date().toISOString(),
        ...action.payload
      });
    },
    removeNotification: (state, action) => {
      state.notifications = state.notifications.filter(n => n.id !== action.payload);
    },
    clearNotifications: state => {
      state.notifications = [];
    },
    setCameraScrollX: (state, action) => {
      state.cameraScrollX = action.payload;
    },
    setShouldCenterMap: (state, action) => {
      state.shouldCenterMap = action.payload;
    },
    resetUI: () => uiSlice_initialState
  }
});
const {
  setMapModalOpen,
  setSettingsOpen,
  setTerminalOpen,
  setPauseMenuOpen,
  addNotification,
  removeNotification,
  clearNotifications,
  setCameraScrollX,
  setShouldCenterMap,
  resetUI
} = uiSlice.actions;
/* harmony default export */ const slices_uiSlice = (uiSlice.reducer);
;// ./src/store/index.js
/**
 * Redux Store Configuration
 * Centralized state management for the game
 */






const store = (0,redux_toolkit_modern/* configureStore */.U1)({
  reducer: {
    game: slices_gameSlice,
    player: slices_playerSlice,
    settings: slices_settingsSlice,
    ui: slices_uiSlice
  },
  middleware: getDefaultMiddleware => getDefaultMiddleware({
    serializableCheck: {
      // Ignore these action types for serialization checks
      ignoredActions: ['game/setActiveMap', 'player/updateState'],
      // Ignore these field paths in all actions
      ignoredActionPaths: ['payload.projectiles', 'payload.timestamp'],
      // Ignore these paths in the state
      ignoredPaths: ['game.activeMapData', 'player.projectiles']
    }
  }),
  devTools: "production" !== 'production'
});
/* harmony default export */ const src_store = (store);
;// ./src/styles/theme.js
/**
 * Theme Configuration for Styled Components
 * Centralized design tokens and theme variables
 */

const theme = {
  colors: {
    primary: '#4CAF50',
    secondary: '#2196F3',
    danger: '#f44336',
    warning: '#ff9800',
    success: '#8bc34a',
    info: '#00bcd4',
    dark: '#222',
    darkGray: '#333',
    mediumGray: '#555',
    lightGray: '#777',
    background: '#111',
    surface: '#f9f9f9',
    overlay: 'rgba(0, 0, 0, 0.6)',
    text: '#333',
    textLight: '#666',
    textDark: '#fff',
    border: '#ddd',
    borderLight: '#eee'
  },
  spacing: {
    xs: '4px',
    sm: '8px',
    md: '16px',
    lg: '24px',
    xl: '32px',
    xxl: '48px'
  },
  borderRadius: {
    sm: '4px',
    md: '6px',
    lg: '8px',
    xl: '12px',
    round: '50%'
  },
  shadows: {
    sm: '0 2px 4px rgba(0,0,0,0.1)',
    md: '0 4px 8px rgba(0,0,0,0.2)',
    lg: '0 10px 25px rgba(0,0,0,0.5)'
  },
  fontSize: {
    xs: '11px',
    sm: '12px',
    md: '14px',
    base: '16px',
    lg: '18px',
    xl: '24px',
    xxl: '32px'
  },
  fontWeight: {
    light: 300,
    normal: 400,
    medium: 500,
    semibold: 600,
    bold: 700
  },
  transitions: {
    fast: '0.15s ease',
    normal: '0.3s ease',
    slow: '0.5s ease'
  },
  zIndex: {
    base: 1,
    dropdown: 100,
    modal: 1000,
    tooltip: 1100,
    notification: 1200
  },
  breakpoints: {
    mobile: '480px',
    tablet: '768px',
    desktop: '1024px',
    wide: '1280px'
  }
};
/* harmony default export */ const styles_theme = (theme);
;// ./src/styles/GlobalStyles.js
/**
 * Global Styles using Styled Components
 */


const GlobalStyles = (0,styled_components_browser_esm/* createGlobalStyle */.DU)(["*{margin:0;padding:0;box-sizing:border-box;}body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI','Roboto','Oxygen','Ubuntu','Cantarell','Fira Sans','Droid Sans','Helvetica Neue',sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;overflow:hidden;}code{font-family:source-code-pro,Menlo,Monaco,Consolas,'Courier New',monospace;}button{cursor:pointer;font-family:inherit;&:disabled{cursor:not-allowed;opacity:0.6;}}input,textarea,select{font-family:inherit;}a{text-decoration:none;color:inherit;}ul,ol{list-style:none;}img{max-width:100%;height:auto;}::-webkit-scrollbar{width:10px;height:10px;}::-webkit-scrollbar-track{background:#222;}::-webkit-scrollbar-thumb{background:#555;border-radius:5px;&:hover{background:#777;}}"]);
/* harmony default export */ const styles_GlobalStyles = (GlobalStyles);
// EXTERNAL MODULE: ./node_modules/i18next/dist/esm/i18next.js
var i18next = __webpack_require__(2635);
// EXTERNAL MODULE: ./node_modules/react-i18next/dist/es/index.js + 22 modules
var es = __webpack_require__(2022);
;// ./src/i18n/translations/lv/navigation_home.json
const navigation_home_namespaceObject = /*#__PURE__*/JSON.parse('{"NAVIGATION_HOME":"Mjas","NAVIGATION_NEW_GAME":"Jauna Sple","NAVIGATION_EDITOR":"Karu Editors","NAVIGATION_CRYSTALS":"Kristli","NAVIGATION_REPOSITORY":"Repozitorijs"}');
;// ./src/i18n/translations/no/navigation_home.json
const no_navigation_home_namespaceObject = /*#__PURE__*/JSON.parse('{"NAVIGATION_HOME":"Hjem","NAVIGATION_NEW_GAME":"Nyt Spill","NAVIGATION_EDITOR":"Map Editor","NAVIGATION_CRYSTALS":"Krystaller","NAVIGATION_REPOSITORY":"depot"}');
;// ./src/i18n/translations/en/navigation_home.json
const en_navigation_home_namespaceObject = /*#__PURE__*/JSON.parse('{"NAVIGATION_HOME":"Home","NAVIGATION_NEW_GAME":"New Game","NAVIGATION_EDITOR":"Map Editor","NAVIGATION_CRYSTALS":"Crystals","NAVIGATION_REPOSITORY":"Repository"}');
;// ./src/i18n/translations/ru/navigation_home.json
const ru_navigation_home_namespaceObject = /*#__PURE__*/JSON.parse('{"NAVIGATION_HOME":"","NAVIGATION_NEW_GAME":" ","NAVIGATION_EDITOR":" ","NAVIGATION_CRYSTALS":"","NAVIGATION_REPOSITORY":"P"}');
;// ./src/i18n/translations/ja/navigation_home.json
const ja_navigation_home_namespaceObject = /*#__PURE__*/JSON.parse('{"NAVIGATION_HOME":"","NAVIGATION_NEW_GAME":"","NAVIGATION_EDITOR":"","NAVIGATION_CRYSTALS":"","NAVIGATION_REPOSITORY":""}');
;// ./src/i18n/i18n.js







const lv_navigation = {
  ...navigation_home_namespaceObject
};
const no_navigation = {
  ...no_navigation_home_namespaceObject
};
const en_navigation = {
  ...en_navigation_home_namespaceObject
};
const ru_navigation = {
  ...ru_navigation_home_namespaceObject
};
const ja_navigation = {
  ...ja_navigation_home_namespaceObject
};
i18next/* default.use */.Ay.use(es/* initReactI18next */.r9).init({
  lng: "lv",
  fallbackLng: "lv",
  supportedLngs: ["lv", "no", "en", "ru", "ja"],
  ns: ["navigation"],
  defaultNS: "navigation",
  interpolation: {
    escapeValue: false
  },
  resources: {
    lv: {
      navigation: lv_navigation
    },
    no: {
      navigation: no_navigation
    },
    en: {
      navigation: en_navigation
    },
    ru: {
      navigation: ru_navigation
    },
    ja: {
      navigation: ja_navigation
    }
  }
});
/* harmony default export */ const i18n_i18n = ((/* unused pure expression or super */ null && (i18n)));
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js
var injectStylesIntoStyleTag = __webpack_require__(5072);
var injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleDomAPI.js
var styleDomAPI = __webpack_require__(7825);
var styleDomAPI_default = /*#__PURE__*/__webpack_require__.n(styleDomAPI);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertBySelector.js
var insertBySelector = __webpack_require__(7659);
var insertBySelector_default = /*#__PURE__*/__webpack_require__.n(insertBySelector);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js
var setAttributesWithoutAttributes = __webpack_require__(5056);
var setAttributesWithoutAttributes_default = /*#__PURE__*/__webpack_require__.n(setAttributesWithoutAttributes);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertStyleElement.js
var insertStyleElement = __webpack_require__(540);
var insertStyleElement_default = /*#__PURE__*/__webpack_require__.n(insertStyleElement);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleTagTransform.js
var styleTagTransform = __webpack_require__(1113);
var styleTagTransform_default = /*#__PURE__*/__webpack_require__.n(styleTagTransform);
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./src/index.css
var cjs_js_src = __webpack_require__(6523);
;// ./src/index.css

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (styleTagTransform_default());
options.setAttributes = (setAttributesWithoutAttributes_default());

      options.insert = insertBySelector_default().bind(null, "head");
    
options.domAPI = (styleDomAPI_default());
options.insertStyleElement = (insertStyleElement_default());

var update = injectStylesIntoStyleTag_default()(cjs_js_src/* default */.A, options);




       /* harmony default export */ const src = (cjs_js_src/* default */.A && cjs_js_src/* default */.A.locals ? cjs_js_src/* default */.A.locals : undefined);

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(4848);
;// ./src/sections/section.header.navigation.chapters.js




const NavLinkButton = (0,styled_components_browser_esm/* default */.Ay)(chunk_4WY6JWTD/* NavLink */.k2).withConfig({
  displayName: "sectionheadernavigationchapters__NavLinkButton",
  componentId: "sc-1gii1an-0"
})(["display:flex;align-items:center;justify-content:center;background-color:transparent;color:lightgray;border:1px solid rgba(255,255,255,0.3);padding:0 10px;font-size:13px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;cursor:pointer;transition:all 0.3s ease;white-space:nowrap;border-radius:0;text-decoration:none;&:hover{background-color:#f4c542;color:#2a2a2a;border-color:#f4c542;}&.active{background-color:rgba(255,255,255,0.15);border-color:rgba(255,255,255,0.5);color:black;}"]);
function SectionHeaderNavigationChapters() {
  const {
    t
  } = (0,es/* useTranslation */.Bd)("navigation");
  const chapter_home = t("NAVIGATION_HOME");
  const chapter_game = t("NAVIGATION_NEW_GAME");
  const chapter_editor = t("NAVIGATION_EDITOR");
  const chapter_crystals = t("NAVIGATION_CRYSTALS");
  const chapter_repository = t("NAVIGATION_REPOSITORY");

  // JAUNS: Funkcija, kas nosta signlu atvrt modlo logu
  const handleNewGameClick = () => {
    // Nostam globlu notikumu, ko 'game.jsx' vars uztvert
    window.dispatchEvent(new Event('open-new-game-modal'));
  };
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("nav", {
    style: {
      display: "flex",
      gap: "0"
    },
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(NavLinkButton, {
      to: "/",
      className: ({
        isActive
      }) => isActive ? "active" : "",
      children: chapter_home
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(NavLinkButton, {
      to: "/game",
      onClick: handleNewGameClick,
      className: ({
        isActive
      }) => isActive ? "active" : "",
      children: chapter_game
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(NavLinkButton, {
      to: "/editor",
      className: ({
        isActive
      }) => isActive ? "active" : "",
      children: chapter_editor
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(NavLinkButton, {
      to: "/crystals",
      className: ({
        isActive
      }) => isActive ? "active" : "",
      children: chapter_crystals
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(NavLinkButton, {
      to: "/repository",
      className: ({
        isActive
      }) => isActive ? "active" : "",
      children: chapter_repository
    })]
  });
}
;// ./src/sections/section.header.navigation.languages.js



const NavButton = styled_components_browser_esm/* default */.Ay.button.withConfig({
  displayName: "sectionheadernavigationlanguages__NavButton",
  componentId: "sc-19qmfot-0"
})(["display:flex;align-items:center;justify-content:center;background-color:transparent;color:lightgray;border:1px solid rgba(255,255,255,0.3);padding:0 10px;font-size:13px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;cursor:pointer;transition:all 0.3s ease;white-space:nowrap;border-radius:0;&:hover{background-color:#f4c542;color:#2a2a2a;border-color:#f4c542;}&.active{background-color:rgba(255,255,255,0.15);border-color:rgba(255,255,255,0.5);color:black;}"]);
function SectionHeaderNavigationLanguages() {
  const {
    i18n
  } = (0,es/* useTranslation */.Bd)();
  const currentLang = i18n.language || 'lv';
  const handleLanguageChange = newLang => {
    i18n.changeLanguage(newLang);
  };
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("nav", {
    style: {
      display: "flex",
      gap: "0"
    },
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(NavButton, {
      className: currentLang === 'lv' ? 'active' : '',
      onClick: () => handleLanguageChange('lv'),
      children: "LV"
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(NavButton, {
      className: currentLang === 'no' ? 'active' : '',
      onClick: () => handleLanguageChange('no'),
      children: "NO"
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(NavButton, {
      className: currentLang === 'en' ? 'active' : '',
      onClick: () => handleLanguageChange('en'),
      children: "EN"
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(NavButton, {
      className: currentLang === 'ru' ? 'active' : '',
      onClick: () => handleLanguageChange('ru'),
      children: "RU"
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(NavButton, {
      className: currentLang === 'ja' ? 'active' : '',
      onClick: () => handleLanguageChange('ja'),
      children: "JA"
    })]
  });
}
;// ./src/sections/section.header.navigation.logo.js


const StyledLogo = styled_components_browser_esm/* default */.Ay.p.withConfig({
  displayName: "sectionheadernavigationlogo__StyledLogo",
  componentId: "sc-b07jnv-0"
})(["text-transform:uppercase;"]);
function SectionHeaderNavigationLogo() {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(StyledLogo, {
    children: "Element Masters"
  });
}
;// ./src/sections/section.header.js





const StyledSectionHeaderNavigation = styled_components_browser_esm/* default */.Ay.div.withConfig({
  displayName: "sectionheader__StyledSectionHeaderNavigation",
  componentId: "sc-2elt43-0"
})(["display:flex;flex-direction:row;width:100%;height:auto;border:solid 1px lightgrey;.innerHeader{display:flex;flex-direction:row;width:100%;height:auto;margin:5px 20px;.innerHeaderLogo{display:flex;flex-direction:row;width:220px;height:auto;}.innerHeaderChapters{display:flex;flex-direction:row;justify-content:center;width:100%;height:auto;}.innerHeaderLanguages{display:flex;flex-direction:row;width:auto;height:auto;}}"]);
function SectionHeader() {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(StyledSectionHeaderNavigation, {
    children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      className: "innerHeader",
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        className: "innerHeaderLogo",
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(SectionHeaderNavigationLogo, {})
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        className: "innerHeaderChapters",
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(SectionHeaderNavigationChapters, {})
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        className: "innerHeaderLanguages",
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(SectionHeaderNavigationLanguages, {})
      })]
    })
  });
}
/* harmony default export */ const section_header = (SectionHeader);
;// ./src/sections/section.footer.js


const StyledSectionHeaderFooter = styled_components_browser_esm/* default */.Ay.div.withConfig({
  displayName: "sectionfooter__StyledSectionHeaderFooter",
  componentId: "sc-1vo14jg-0"
})(["display:flex;flex-direction:row;justify-content:center;width:100%;height:auto;border:solid 1px lightgray;.innerFooter{display:flex;flex-direction:row;justify-content:flex-end;width:100%;height:auto;margin:5px 20px;}p{font-size:12px;color:lightgrey;}"]);
function SectionFooter() {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(StyledSectionHeaderFooter, {
    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: "innerFooter",
      children: /*#__PURE__*/(0,jsx_runtime.jsx)("p", {
        children: "element_masters v.0.0.0"
      })
    })
  });
}
/* harmony default export */ const section_footer = (SectionFooter);
;// ./src/sections/section.content.js


const StyledSectionContent = styled_components_browser_esm/* default */.Ay.div.withConfig({
  displayName: "sectioncontent__StyledSectionContent",
  componentId: "sc-do75gr-0"
})(["display:flex;flex-direction:column;width:100%;height:100%;border:solid 1px lightgray;"]);
function SectionContent({
  children
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(StyledSectionContent, {
    children: children
  });
}
/* harmony default export */ const section_content = (SectionContent);
;// ./src/engine/registry/index.js
[]; /**
    * Game Registry Module
    * Loads all JSON files and creates a registry array.
    * Executed only once during initialization.
    */

let _registry = null;

/**
 * Initialize the registry by loading all JSON, image, and sound assets.
 * This is executed only once when the module is first imported.
 * @returns {Array} The loaded registry items
 */
const initRegistry = () => {
  // If registry already exists, do nothing
  if (_registry) return _registry;
  console.time("Registry Load Time");
  try {
    // 1. Load JSON data
    const jsonContext = __webpack_require__(6570);

    // 2. Load IMAGES
    const imageContext = __webpack_require__(1621);

    // 3. Load SOUNDS (non-fatal: if not supported or directory doesn't exist, continue without sounds)
    let soundContext = null;
    try {
      soundContext = __webpack_require__(6431);
    } catch (e) {
      // Sound context not available  not fatal
      soundContext = null;
    }

    // Check if sound context is available
    if (!soundContext) {
      console.warn('Sound context unavailable. Continuing without pre-resolved sound assets.');
    }

    // Helper function for path resolution
    const resolvePath = rawPath => {
      if (!rawPath) return null;
      try {
        // Convert JSON path to relative Webpack path
        // Example: "/assets/images/blocks/dirt.png" -> "./blocks/dirt.png"
        const cleanPath = rawPath.replace('/assets/images/', './').replace('src/assets/images/', './');
        const relativePath = cleanPath.startsWith('./') ? cleanPath : `./${cleanPath}`;
        const imageModule = imageContext(relativePath);
        return imageModule.default || imageModule;
      } catch (e) {
        console.warn(`Image not found: ${rawPath}`);
        return rawPath; // If not found, return original path
      }
    };
    let _warnedUnresolvedSound = false;
    const resolveSound = rawPath => {
      if (!rawPath) return null;
      // Normalize path for sound context
      const normalize = p => {
        let out = p;
        out = out.replace('/assets/sounds/', './').replace('src/assets/sounds/', './');
        out = out.replace('/assets/sound/', './').replace('src/assets/sound/', './');
        return out.startsWith('./') ? out : `./${out}`;
      };
      const rel = normalize(rawPath);
      // Try to resolve with sound context
      if (soundContext) {
        try {
          const mod = soundContext(rel);
          return mod.default || mod;
        } catch {}
      }
      // Unable to resolve in bundler  return original path to try loading via public URL
      if (!_warnedUnresolvedSound) {
        console.warn(`SFX not bundled: ${rawPath}. Will try loading via public URL. Place files under src/assets/sound, or copy to public/assets/sound.`);
        _warnedUnresolvedSound = true;
      }
      return rawPath;
    };
    _registry = jsonContext.keys().map(key => {
      const data = jsonContext(key);
      const item = data.default || data;

      // Apstrdjam vienu bildi (vecais variants)
      let resolvedTexture = resolvePath(item.texture);

      // Apstrdjam bilu masvu (jaunais variants animcijm)
      let resolvedTextures = [];
      if (item.textures && Array.isArray(item.textures)) {
        resolvedTextures = item.textures.map(path => resolvePath(path));
      }
      return {
        ...item,
        texture: resolvedTexture,
        // Viena bilde (ja ir)
        textures: resolvedTextures,
        // Masvs (ja ir)
        // Skaas ce (ja ir)  prvrsts uz bundlera URL
        sfx: resolveSound(item.sfx || item.sfxResolved || null)
      };
    });

    // --- JAUNS: Pcapstrde (Linking & Merging) ---
    // Ms ejam cauri visiem elementiem un mekljam tos, kuriem ir 'defaultAnimation'.
    // Ja atrodam, ms kopjam vizulos datus no animcijas uz galveno objektu.

    _registry.forEach(item => {
      if (item.defaultAnimation) {
        // Mekljam animcijas objektu pc ID
        // Piezme: Tav piemr player.json ir "player_default", bet fail id ir "player_default_100". 
        // eit ms minm atrast preczu vai daju atbilstbu, lai kods strdtu abos gadjumos.
        const animItem = _registry.find(r => r.id === item.defaultAnimation || r.id === item.defaultAnimation + "_100");
        if (animItem) {
          // Kopjam vizulos datus uz galveno 'player' objektu
          if (!item.texture) item.texture = animItem.texture;
          if (!item.textures || item.textures.length === 0) item.textures = animItem.textures;
          if (!item.animationSpeed) item.animationSpeed = animItem.animationSpeed;

          // Iezmjam animcijas objektu k 'hidden', lai to nerdtu Editor
          animItem.isHiddenInEditor = true;
        }

        // Tpat paslpjam ar dead un target animcijas, ja ts eksist k atsevii itemi
        if (item.deadAnimation) {
          const deadItem = _registry.find(r => r.id === item.deadAnimation);
          if (deadItem) deadItem.isHiddenInEditor = true;
        }
        if (item.targetAnimation) {
          const targetItem = _registry.find(r => r.id === item.targetAnimation || r.id === item.targetAnimation + "_100");
          if (targetItem) targetItem.isHiddenInEditor = true;
        }
      }
    });
    console.log(` Game Registry initialized. Loaded ${_registry.length} items.`);
  } catch (error) {
    console.error(" Failed to load Game Registry:", error);
    _registry = [];
  }
  console.timeEnd("Registry Load Time");
  return _registry;
};

// Automtiski inicializjam, kad is fails tiek importts pirmo reizi
initRegistry();

// Eksportjam funkciju, lai piektu datiem (getter)
const getRegistry = () => {
  return _registry;
};

// Eksportjam palgfunkciju, lai mekltu pc ID
const findItemById = id => {
  return _registry ? _registry.find(item => item.id === id) : null;
};
/* harmony default export */ const registry = ((/* unused pure expression or super */ null && (_registry)));
;// ./src/App.js






// Import the registry getter from the centralized engine registry
// The import itself ensures that the registry code executes and data loads into memory.


function App() {
  (0,react.useEffect)(() => {
    // Verify that registry data is loaded into memory
    const items = getRegistry();
    console.log("App start - Current Registry in Memory:", items);
  }, []);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    style: {
      display: 'flex',
      flexDirection: 'column',
      justifyContent: 'center',
      alignItems: 'center',
      width: '100vw',
      height: '100vh'
    },
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(section_header, {}), /*#__PURE__*/(0,jsx_runtime.jsx)(section_content, {
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(chunk_4WY6JWTD/* Outlet */.sv, {})
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(section_footer, {})]
  });
}
/* harmony default export */ const src_App = (App);
;// ./src/sections/chapters/home.jsx

function Home() {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
    children: /*#__PURE__*/(0,jsx_runtime.jsx)("p", {
      children: "Home"
    })
  });
}
// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(5556);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);
// EXTERNAL MODULE: ./node_modules/pixi.js/lib/index.mjs + 50 modules
var lib = __webpack_require__(110);
;// ./src/Pixi/TextureCache.js
// Lightweight texture cache around PIXI.Texture.from
// Usage:
//   const cache = new TextureCache();
//   const tex = cache.get(url);
//   cache.dispose(); // optional


class TextureCache {
  constructor() {
    this._map = new Map();
  }
  get(url) {
    if (!url) return null;
    const m = this._map;
    if (m.has(url)) return m.get(url);
    const tex = lib/* Texture */.gPd.from(url);
    m.set(url, tex);
    return tex;
  }
  has(url) {
    return this._map.has(url);
  }
  dispose(url) {
    // Do not destroy textures created by Texture.from (managed by Pixi's cache);
    // only release our Map reference.
    if (url && this._map.has(url)) this._map.delete(url);
  }
  clear() {
    this._map.clear();
  }
}
;// ./src/Pixi/layers/ParallaxBackground.js


// Parallax background helper. Manages a single tiling sprite (or solid sprite) inside a given container.
// API:
//   const par = new ParallaxBackground(container, textureCache);
//   par.build({ worldWidth, worldHeight, url, color, factor });
//   par.setScroll(cameraX, factor);
//   par.destroy();
class ParallaxBackground {
  constructor(container, textureCache) {
    this.container = container;
    this.cache = textureCache;
    this.sprite = null;
    this._worldW = 0;
    this._worldH = 0;
  }
  build({
    worldWidth,
    worldHeight,
    url,
    color,
    factor = 0.3
  }) {
    const layer = this.container;
    if (!layer) return;
    this.clear();
    this._worldW = worldWidth;
    this._worldH = worldHeight;
    if (url) {
      const tex = this.cache?.get(url) || lib/* Texture */.gPd.from(url);
      if (tex?.baseTexture) tex.baseTexture.wrapMode = lib/* WRAP_MODES */.uRw.REPEAT;
      const sprite = new lib/* TilingSprite */.t9Q({
        texture: tex,
        width: worldWidth,
        height: worldHeight
      });
      // Fit the height exactly, preserve horizontal scale (tileScale.x = 1)
      const texH = tex.height || tex.baseTexture?.height || 1;
      const scaleY = worldHeight / texH;
      sprite.tileScale.set(1, scaleY);
      sprite.x = 0;
      sprite.y = 0;
      sprite.alpha = 0.9;
      try {
        sprite.filters = [new lib/* BlurFilter */.eV2({
          strength: 1.2,
          quality: 2
        })];
      } catch {}
      layer.addChild(sprite);
      this.sprite = sprite;
      // initial scroll
      this.setScroll(0, factor);
    } else {
      const hex = typeof color === 'string' && color.startsWith('#') ? parseInt(color.slice(1), 16) : Number(color) || 0x87CEEB;
      const solid = new lib/* Sprite */.kxk(lib/* Texture */.gPd.WHITE);
      solid.tint = hex;
      solid.width = worldWidth;
      solid.height = worldHeight;
      solid.alpha = 0.95;
      try {
        solid.filters = [new lib/* BlurFilter */.eV2({
          strength: 0.8,
          quality: 2
        })];
      } catch {}
      layer.addChild(solid);
      this.sprite = solid;
    }
  }
  setScroll(cameraX, factor = 0.3) {
    if (!this.sprite) return;
    if ('tilePosition' in this.sprite) {
      this.sprite.tilePosition.x = -cameraX * factor;
      this.sprite.tilePosition.y = 0;
    }
  }
  resize(worldWidth, worldHeight) {
    if (!this.sprite) return;
    this._worldW = worldWidth;
    this._worldH = worldHeight;
    this.sprite.width = worldWidth;
    this.sprite.height = worldHeight;
    const tex = this.sprite.texture;
    const texH = tex?.height || tex?.baseTexture?.height || 1;
    if (this.sprite.tileScale && texH > 0) {
      const scaleY = worldHeight / texH;
      this.sprite.tileScale.set(1, scaleY);
    }
  }
  clear() {
    const layer = this.container;
    if (!layer) return;
    if (this.sprite) {
      try {
        layer.removeChild(this.sprite);
      } catch {}
      try {
        this.sprite.destroy?.();
      } catch {}
      this.sprite = null;
    }
  }
  destroy() {
    this.clear();
    this.container = null;
    this.cache = null;
  }
}
;// ./src/Pixi/layers/TileChunkLayer.js
// TileChunkLayer: builds a static tile background using chunked RenderTextures
// to drastically reduce sprite count on large maps.
//
// Usage:
//   const layer = new TileChunkLayer(app, container, textureCache);
//   layer.build({ mapWidth, mapHeight, tileSize, tileMapData, registryItems, chunkSize:16 });
//   layer.destroy();


class TileChunkLayer {
  constructor(app, container, textureCache) {
    this.app = app;
    this.container = container; // parent PIXI.Container to hold chunk sprites
    this.cache = textureCache;
    this.chunkSize = 16;
    this._chunks = []; // sprites per chunk
    this._mapKey = '';
  }
  destroy() {
    this.clear();
    this.app = null;
    this.container = null;
    this.cache = null;
  }
  clear() {
    if (this._chunks) {
      for (let i = 0; i < this._chunks.length; i++) {
        const spr = this._chunks[i];
        if (!spr) continue;
        try {
          this.container?.removeChild(spr);
        } catch {}
        try {
          spr.texture?.destroy?.(true);
        } catch {}
        try {
          spr.destroy?.();
        } catch {}
      }
    }
    this._chunks = [];
  }
  build(params) {
    const {
      mapWidth,
      mapHeight,
      tileSize,
      tileMapData,
      registryItems,
      chunkSize = 16
    } = params || {};
    if (!this.app || !this.container) return;
    if (!Array.isArray(tileMapData) || !Array.isArray(registryItems)) return;
    this.chunkSize = Math.max(8, Math.min(64, chunkSize | 0 || 16));

    // If identical map key, skip rebuild
    const key = `${mapWidth}x${mapHeight}x${tileSize}#${tileMapData.length}`;
    if (key === this._mapKey && this._chunks.length) return;
    this._mapKey = key;
    this.clear();
    const app = this.app;
    const renderer = app.renderer;
    const worldW = mapWidth * tileSize;
    const worldH = mapHeight * tileSize;
    const getDef = id => registryItems.find(r => r.id === id);
    const getTex = url => this.cache?.get(url) || (url ? Texture.from(url) : null);
    const chunksX = Math.ceil(mapWidth / this.chunkSize);
    const chunksY = Math.ceil(mapHeight / this.chunkSize);
    for (let cy = 0; cy < chunksY; cy++) {
      for (let cx = 0; cx < chunksX; cx++) {
        const tilesW = Math.min(this.chunkSize, mapWidth - cx * this.chunkSize);
        const tilesH = Math.min(this.chunkSize, mapHeight - cy * this.chunkSize);
        const pxW = tilesW * tileSize;
        const pxH = tilesH * tileSize;

        // Build offscreen container for this chunk
        const off = new Container();
        off.x = 0;
        off.y = 0;
        let hasAny = false;
        for (let ty = 0; ty < tilesH; ty++) {
          for (let tx = 0; tx < tilesW; tx++) {
            const gx = cx * this.chunkSize + tx;
            const gy = cy * this.chunkSize + ty;
            const idx = gy * mapWidth + gx;
            const id = tileMapData[idx];
            if (!id) continue;
            const def = getDef(id);
            if (!def) continue;

            // Only static tiles here; animated tiles will be handled by PixiStage for now
            const isAnimated = Array.isArray(def.textures) && def.textures.length > 1;
            const url = isAnimated ? null : def.texture || null;
            if (!url) continue;
            const tex = getTex(url);
            if (!tex) continue;
            const spr = new Sprite(tex);
            spr.x = tx * tileSize;
            spr.y = ty * tileSize;
            spr.width = tileSize;
            spr.height = tileSize;
            off.addChild(spr);
            hasAny = true;
          }
        }
        if (!hasAny) {
          // nothing in this chunk; skip creating RT
          off.destroy({
            children: true
          });
          continue;
        }

        // Render to texture and create a single sprite
        const rt = RenderTexture.create({
          width: pxW,
          height: pxH,
          resolution: renderer.resolution
        });
        renderer.render({
          container: off,
          target: rt,
          clear: true
        });
        // Clean up offscreen
        off.destroy({
          children: true
        });
        const chunkSprite = new Sprite(rt);
        chunkSprite.x = cx * this.chunkSize * tileSize;
        chunkSprite.y = cy * this.chunkSize * tileSize;
        this.container.addChild(chunkSprite);
        this._chunks.push(chunkSprite);
      }
    }
  }
}
;// ./src/Pixi/effects/weather/Rain.js


// Simple rain system with variable speeds and single-bounce behavior on solid tiles.
class WeatherRain {
  constructor(container, api, getIntensity) {
    this.container = container;
    this.api = api;
    this.getIntensity = getIntensity || (() => 0);
    this.width = api.mapWidth * api.tileSize;
    this.height = api.mapHeight * api.tileSize;
    this.particles = [];
    this.intensity = 0;
    const area = this.width * this.height;
    // Reasonable particle cap depending on map area to keep FPS stable
    this.maxParticles = Math.max(160, Math.floor(area / 2600));
  }
  setIntensity(v) {
    this.intensity = Math.max(0, Math.min(100, Number(v) || 0));
  }
  spawnOne() {
    const g = new lib/* Graphics */.A1g();
    g.clear();
    // Draw a thin slanted line to mimic a raindrop motion blur
    g.lineStyle(0);
    g.beginFill(0x4aa3ff, 0.92);
    // Slightly longer/brighter to be more visible
    g.drawRect(0, 0, 1.3, 9);
    g.endFill();
    const x = Math.random() * this.width;
    const y = -10 - Math.random() * 30;
    const speed = 520 + Math.random() * 520; // px/s, different speeds for depth
    const vx = Math.random() * 60 - 30; // slight wind
    const vy = speed;
    g.x = x;
    g.y = y;
    g.rotation = 0.15; // slight tilt
    this.container.addChild(g);
    this.particles.push({
      g,
      x,
      y,
      vx,
      vy,
      bounces: 0,
      alive: true
    });
  }
  update(dtMs) {
    // adjust intensity dynamically
    this.setIntensity(this.getIntensity());

    // Constant-density controller: keep active particles near target count
    const norm = Math.max(0, Math.min(1, this.intensity / 100));
    const scaled = Math.pow(norm, 1.15);
    let target = Math.floor(this.maxParticles * scaled);
    if (scaled > 0 && target < 8) target = 8; // small baseline so low intensity still visible

    const deficit = target - this.particles.length;
    if (deficit > 0) {
      // Smooth ramp, spawn only a fraction per frame to avoid bursts
      const maxPerFrame = 48;
      const smooth = Math.max(1, Math.ceil(target * 0.02));
      const toSpawn = Math.min(deficit, smooth, maxPerFrame);
      for (let i = 0; i < toSpawn; i++) this.spawnOne();
    }
    // Gentle over-target culling to keep density steady
    if (this.particles.length > target) {
      const surplus = this.particles.length - target;
      const toCull = Math.min(surplus, Math.max(1, Math.ceil(this.particles.length * 0.02)));
      for (let i = 0; i < toCull; i++) {
        const p = this.particles.pop();
        if (!p) break;
        try {
          p.g.parent && p.g.parent.removeChild(p.g);
        } catch {}
        try {
          p.g.destroy();
        } catch {}
      }
    }
    const gAcc = 1800; // gravity px/s^2
    const dt = dtMs / 1000;
    const toRemove = [];
    for (let i = 0; i < this.particles.length; i++) {
      const p = this.particles[i];
      if (!p.alive) {
        toRemove.push(i);
        continue;
      }
      p.vy += gAcc * dt;
      let nx = p.x + p.vx * dt;
      let ny = p.y + p.vy * dt;

      // Liquid surface interaction: water/lava
      try {
        if (typeof this.api.getLiquidSurfaceY === 'function') {
          // Prefer closest surface above current ny
          const syWater = this.api.getLiquidSurfaceY('water', nx);
          if (Number.isFinite(syWater) && ny >= syWater) {
            // Hit water surface  spawn small splash and despawn
            const speed = Math.max(0, Math.min(1500, p.vy));
            const strength = Math.min(2, 0.4 + speed / 900);
            if (typeof this.api.onWaterImpact === 'function') this.api.onWaterImpact({
              x: nx,
              strength
            });
            p.alive = false;
            toRemove.push(i);
            continue;
          }
          const syLava = this.api.getLiquidSurfaceY('lava', nx);
          if (Number.isFinite(syLava) && ny >= syLava) {
            // Hit lava  steam puff and despawn
            const speed = Math.max(0, Math.min(1500, p.vy));
            const strength = Math.min(2, 0.35 + speed / 1200);
            if (typeof this.api.onLavaImpact === 'function') this.api.onLavaImpact({
              x: nx,
              y: syLava,
              strength
            });
            p.alive = false;
            toRemove.push(i);
            continue;
          }
        }
      } catch {}

      // Collision check (treat as point)
      if (this.api.isSolidAt(nx, ny)) {
        // Backtrack slightly to stand above surface
        let guard = 0;
        while (this.api.isSolidAt(nx, ny) && guard < 6) {
          ny -= 1;
          guard++;
        }
        // Bounce once, then fade out quickly on next impact
        if (p.bounces === 0 && Math.abs(p.vy) > 150) {
          p.vy = -p.vy * 0.3; // dampened bounce
          p.vx *= 0.8;
          p.bounces++;
        } else {
          // Small splash effect: shrink line and fade
          p.alive = false;
          toRemove.push(i);
        }
      }
      p.x = nx;
      p.y = ny;
      p.g.x = p.x;
      p.g.y = p.y;

      // Off-screen cleanup
      if (p.y > this.height + 40 || p.x < -40 || p.x > this.width + 40) {
        p.alive = false;
        toRemove.push(i);
      }
    }

    // remove in reverse
    for (let j = toRemove.length - 1; j >= 0; j--) {
      const idx = toRemove[j];
      const p = this.particles[idx];
      if (p && p.g && p.g.parent) p.g.parent.removeChild(p.g);
      if (p && p.g && p.g.destroy) try {
        p.g.destroy();
      } catch {}
      this.particles.splice(idx, 1);
    }
  }
  destroy() {
    this.particles.forEach(p => {
      try {
        p.g.parent && p.g.parent.removeChild(p.g);
      } catch {}
      try {
        p.g.destroy();
      } catch {}
    });
    this.particles = [];
  }
}
;// ./src/Pixi/effects/weather/Snow.js


// Snow system: slow fluttering flakes with varied speeds; stop on blocks without bouncing.
class WeatherSnow {
  constructor(container, api, getIntensity) {
    this.container = container;
    this.api = api;
    this.getIntensity = getIntensity || (() => 0);
    this.width = api.mapWidth * api.tileSize;
    this.height = api.mapHeight * api.tileSize;
    this.flakes = [];
    this.intensity = 0;
    const area = this.width * this.height;
    // Snow lasts longer; keep a tighter cap than rain for performance
    this.maxFlakes = Math.max(120, Math.floor(area / 3800));
  }
  setIntensity(v) {
    this.intensity = Math.max(0, Math.min(100, Number(v) || 0));
  }
  spawnOne() {
    const g = new lib/* Graphics */.A1g();
    g.clear();
    // Slightly larger/more visible flakes on average
    const r = 1.2 + Math.random() * 2.0; // radius
    g.beginFill(0xffffff, 0.97);
    g.drawCircle(0, 0, r);
    g.endFill();
    const x = Math.random() * this.width;
    const y = -10 - Math.random() * 30;
    const speed = 40 + Math.random() * 80; // slower than rain, but a bit more range
    const drift = Math.random() * 50 - 25; // horizontal drift
    g.x = x;
    g.y = y;
    this.container.addChild(g);
    this.flakes.push({
      g,
      x,
      y,
      vx: drift,
      vy: speed,
      alive: true,
      settled: false,
      life: 1.0,
      phase: 'fall',
      restMs: 0
    });
  }
  update(dtMs) {
    // adjust intensity dynamically
    this.setIntensity(this.getIntensity());

    // Constant-density controller to avoid wavey bursts
    const norm = Math.max(0, Math.min(1, this.intensity / 100));
    const scaled = Math.pow(norm, 1.15);
    let target = Math.floor(this.maxFlakes * scaled);
    if (scaled > 0 && target < 10) target = 10;
    const deficit = target - this.flakes.length;
    if (deficit > 0) {
      const maxPerFrame = 24; // slower than rain
      const smooth = Math.max(1, Math.ceil(target * 0.015));
      const toSpawn = Math.min(deficit, smooth, maxPerFrame);
      for (let i = 0; i < toSpawn; i++) this.spawnOne();
    }
    // Gentle over-target culling to keep density steady when slider decreases
    if (this.flakes.length > target) {
      const surplus = this.flakes.length - target;
      const toCull = Math.min(surplus, Math.max(1, Math.ceil(this.flakes.length * 0.015)));
      for (let i = 0; i < toCull; i++) {
        const f = this.flakes.pop();
        if (!f) break;
        try {
          f.g.parent && f.g.parent.removeChild(f.g);
        } catch {}
        try {
          f.g.destroy();
        } catch {}
      }
    }
    const gAcc = 200; // gentle gravity
    const dt = dtMs / 1000;
    const toRemove = [];
    for (let i = 0; i < this.flakes.length; i++) {
      const f = this.flakes[i];
      if (!f.alive) {
        toRemove.push(i);
        continue;
      }
      if (f.phase === 'fall') {
        f.vy = Math.min(140, f.vy + gAcc * dt);
        // small oscillation for flutter
        f.vx += Math.sin((f.y + i) * 0.02) * 7 * dt;
        let nx = f.x + f.vx * dt;
        let ny = f.y + f.vy * dt;

        // Liquid interaction first
        try {
          if (typeof this.api.getLiquidSurfaceY === 'function') {
            const sYwater = this.api.getLiquidSurfaceY('water', nx);
            if (Number.isFinite(sYwater) && ny >= sYwater) {
              // Land on water surface and rest for a bit
              ny = sYwater - 0.5;
              f.x = nx;
              f.y = ny;
              f.vx = 0;
              f.vy = 0;
              f.phase = 'rest';
              f.restMs = 800 + Math.random() * 400; // 0.8..1.2s
              // Do not continue to solid collision checks this frame
              // Update display and proceed to next flake
              f.g.x = f.x;
              f.g.y = f.y;
              continue;
            }
            const sYlava = this.api.getLiquidSurfaceY('lava', nx);
            if (Number.isFinite(sYlava) && ny >= sYlava) {
              // Steam puff and despawn
              if (typeof this.api.onLavaImpact === 'function') this.api.onLavaImpact({
                x: nx,
                y: sYlava,
                strength: 0.5
              });
              f.alive = false;
              toRemove.push(i);
              continue;
            }
          }
        } catch {}

        // Solid collision
        if (this.api.isSolidAt(nx, ny)) {
          // backtrack up to stand above the surface
          let guard = 0;
          while (this.api.isSolidAt(nx, ny) && guard < 10) {
            ny -= 1;
            guard++;
          }
          f.settled = true;
          f.vx = 0;
          f.vy = 0;
          f.phase = 'rest';
          f.restMs = 800 + Math.random() * 400;
        }
        f.x = nx;
        f.y = ny;
      } else if (f.phase === 'rest') {
        // Flake rests on surface for a short time (water or ground), then starts sinking/falling slowly
        f.restMs -= dtMs;
        if (f.restMs <= 0) {
          f.phase = 'sinking';
          // resume gentle fall with reduced alpha
          f.vx = Math.random() * 20 - 10;
          f.vy = 20 + Math.random() * 20;
        }
      } else if (f.phase === 'sinking') {
        // Continue downward slowly; fade out progressively
        f.vy = Math.min(60, f.vy + gAcc * 0.3 * dt);
        f.x += f.vx * dt;
        f.y += f.vy * dt;
        f.life -= 0.22 * dt;
        if (f.life <= 0) {
          f.alive = false;
          toRemove.push(i);
        }
      }
      f.g.x = f.x;
      f.g.y = f.y;
      if (f.phase === 'rest' || f.phase === 'sinking' || f.settled) f.g.alpha = Math.max(0, Math.min(1, f.life));
      if (f.y > this.height + 40 || f.x < -40 || f.x > this.width + 40) {
        f.alive = false;
        toRemove.push(i);
      }
    }
    for (let j = toRemove.length - 1; j >= 0; j--) {
      const idx = toRemove[j];
      const f = this.flakes[idx];
      if (f && f.g && f.g.parent) f.g.parent.removeChild(f.g);
      if (f && f.g && f.g.destroy) try {
        f.g.destroy();
      } catch {}
      this.flakes.splice(idx, 1);
    }
  }
  destroy() {
    this.flakes.forEach(f => {
      try {
        f.g.parent && f.g.parent.removeChild(f.g);
      } catch {}
      try {
        f.g.destroy();
      } catch {}
    });
    this.flakes = [];
  }
}
;// ./src/Pixi/effects/weather/Clouds.js


// Clouds overlay: organic cloud blobs drifting in the top 30% of the screen.
class WeatherClouds {
  constructor(container, api, getIntensity) {
    this.container = container;
    this.api = api;
    this.getIntensity = getIntensity || (() => 0);
    this.width = api.mapWidth * api.tileSize;
    this.height = api.mapHeight * api.tileSize;
    this.bandHeight = Math.max(1, Math.floor(this.height * 0.3)); // top 30%
    this.patches = [];
    this.intensity = 0;

    // Soft blur for nicer cloud appearance
    try {
      this.container.filters = [new lib/* BlurFilter */.eV2({
        strength: 2.0,
        quality: 2
      })];
    } catch {}
    this.rebuild();
  }
  setIntensity(v) {
    const nv = Math.max(0, Math.min(100, Number(v) || 0));
    if (nv === this.intensity) return;
    this.intensity = nv;
    this.rebuild();
  }
  rebuild() {
    // Clear existing
    for (const p of this.patches) {
      try {
        p.g.parent && p.g.parent.removeChild(p.g);
      } catch {}
      try {
        p.g.destroy();
      } catch {}
    }
    this.patches = [];
    const count = Math.round(this.intensity / 100 * 18); // a bit fewer than fog by default
    for (let i = 0; i < count; i++) {
      const g = new lib/* Graphics */.A1g();
      const w = 140 + Math.random() * 300; // cloud size
      const h = 80 + Math.random() * 160;
      const x = Math.random() * (this.width + 200) - 100;
      const y = -40 + Math.random() * (this.bandHeight - 20); // only in band
      const alpha = 0.08 + this.intensity / 100 * (0.12 + Math.random() * 0.08);
      const speed = 8 + Math.random() * 22; // horizontal drift speed
      const vy = (Math.random() - 0.5) * 4; // subtle vertical drift

      // Draw an organic cloud using overlapping circles (soft edges)
      g.beginFill(0xffffff, 1.0);
      const rx = w * 0.5;
      const ry = h * 0.5;
      const circles = 8 + Math.floor(Math.random() * 6); // 8..13 lobes
      const baseR = Math.min(rx, ry) * 0.55;
      for (let k = 0; k < circles; k++) {
        const t = k / circles * Math.PI * 2 + Math.random() * 0.6;
        const dist = 0.2 + Math.random() * 0.35;
        const cx = Math.cos(t) * rx * dist;
        const cy = Math.sin(t) * ry * dist;
        const r = baseR * (0.7 + Math.random() * 0.7);
        g.drawCircle(cx, cy, r);
      }
      // central mass
      g.drawCircle(0, 0, baseR * (0.9 + Math.random() * 0.5));
      g.endFill();
      g.alpha = alpha;
      g.x = x;
      g.y = y;
      this.container.addChild(g);
      this.patches.push({
        g,
        w,
        h,
        vx: speed * (Math.random() < 0.5 ? -1 : 1),
        vy,
        alpha,
        phase: Math.random() * Math.PI * 2
      });
    }
  }
  update(dtMs) {
    // live intensity update
    const cur = Math.max(0, Math.min(100, this.getIntensity()));
    if (cur !== this.intensity) this.setIntensity(cur);
    const dt = dtMs / 1000;
    const W = this.width;
    const bandTop = -100; // allow spawn/wrap margin above
    const bandBottom = this.bandHeight - 20; // keep away from lower area
    for (const p of this.patches) {
      // drift
      p.g.x += p.vx * dt;
      p.g.y += p.vy * dt;

      // very gentle alpha oscillation
      p.phase += dt * 0.35;
      const osc = (Math.sin(p.phase) + 1) * 0.5; // 0..1
      p.g.alpha = Math.max(0.04, Math.min(0.55, p.alpha * (0.75 + 0.5 * osc)));

      // wrap horizontally
      if (p.g.x < -180) p.g.x = W + 180;
      if (p.g.x > W + 180) p.g.x = -180;
      // constrain within top band vertically (wrap within band only)
      if (p.g.y < bandTop) p.g.y = bandBottom;
      if (p.g.y > bandBottom) p.g.y = bandTop;
    }
  }
  destroy() {
    try {
      this.container.filters = [];
    } catch {}
    for (const p of this.patches) {
      try {
        p.g.parent && p.g.parent.removeChild(p.g);
      } catch {}
      try {
        p.g.destroy();
      } catch {}
    }
    this.patches = [];
  }
}
;// ./src/Pixi/effects/weather/Fog.js


// Full-screen fog overlay: a semi-transparent rectangle covering entire viewport.
// Intensity 0..100 maps to alpha 0..0.65.
class WeatherFog {
  constructor(container, api, getIntensity) {
    this.container = container;
    this.api = api;
    this.getIntensity = getIntensity || (() => 0);
    this.width = api.mapWidth * api.tileSize;
    this.height = api.mapHeight * api.tileSize;
    this.intensity = 0;
    this.time = 0; // ms accumulator for subtle breathing

    // Base tint rectangle drawn once; alpha controlled via displayObject alpha (no redraws per frame)
    this.g = new lib/* Graphics */.A1g();
    this.container.addChild(this.g);

    // Build procedural noise texture once (small size, repeats as tiling sprites)
    this.noiseTex = WeatherFog._createNoiseTexture(128, 128);
    this.layer1 = new lib/* TilingSprite */.t9Q(this.noiseTex, this.width, this.height);
    this.layer2 = new lib/* TilingSprite */.t9Q(this.noiseTex, this.width, this.height);
    // Different scales for parallax effect
    this.layer1.tileScale.set(1.0, 1.0);
    this.layer2.tileScale.set(0.6, 0.8);
    // Start with zero alpha; will be set based on intensity
    this.layer1.alpha = 0;
    this.layer2.alpha = 0;
    this.container.addChild(this.layer1);
    this.container.addChild(this.layer2);

    // Precompute parameters
    this._recalcParams();
    this._draw();
  }
  _alphaFromIntensity(v) {
    const t = Math.max(0, Math.min(100, Number(v) || 0)) / 100; // 0..1
    return Math.max(0, Math.min(0.65, t * 0.65));
  }
  setIntensity(v) {
    const nv = Math.max(0, Math.min(100, Number(v) || 0));
    if (nv === this.intensity) return;
    this.intensity = nv;
    this._recalcParams();
    this._applyAlphas(0); // update layer alphas based on new intensity
    this._draw();
  }
  resize(width, height) {
    const w = Math.max(1, Math.floor(width));
    const h = Math.max(1, Math.floor(height));
    if (w === this.width && h === this.height) return;
    this.width = w;
    this.height = h;
    // Resize tiling sprites and redraw base rect
    if (this.layer1) {
      this.layer1.width = w;
      this.layer1.height = h;
    }
    if (this.layer2) {
      this.layer2.width = w;
      this.layer2.height = h;
    }
    this._draw();
  }
  _draw() {
    const w = this.width;
    const h = this.height;
    const g = this.g;
    g.clear();
    const baseAlpha = this._alphaFromIntensity(this.intensity);
    if (baseAlpha <= 0) {
      g.alpha = 0;
      return;
    }
    // Draw once with alpha 1, then control real alpha via g.alpha each frame
    g.beginFill(0x9fb7c9, 1);
    g.drawRect(0, 0, w, h);
    g.endFill();
    g.alpha = baseAlpha;
  }
  update(dtMs) {
    // Live intensity update from settings
    const cur = Math.max(0, Math.min(100, this.getIntensity()));
    if (cur !== this.intensity) this.setIntensity(cur);

    // Advance time for breathing/pulse
    const dt = Math.max(0, Number(dtMs) || 16.67);
    this.time += dt;
    // Very subtle breathing: sine between ~0.96 .. 1.04
    const pulse = 1 + 0.04 * Math.sin(this.time * 0.0012);
    this._applyAlphas(pulse);

    // Scroll noise layers slowly
    if (this.layer1) {
      this.layer1.tilePosition.x += this.speed1.x * dt;
      this.layer1.tilePosition.y += this.speed1.y * dt;
    }
    if (this.layer2) {
      this.layer2.tilePosition.x += this.speed2.x * dt;
      this.layer2.tilePosition.y += this.speed2.y * dt;
    }
  }
  destroy() {
    if (this.g) {
      try {
        this.g.parent && this.g.parent.removeChild(this.g);
      } catch {}
      try {
        this.g.destroy();
      } catch {}
    }
    this.g = null;
    try {
      if (this.layer1) {
        this.layer1.parent && this.layer1.parent.removeChild(this.layer1);
        this.layer1.destroy(true);
      }
    } catch {}
    try {
      if (this.layer2) {
        this.layer2.parent && this.layer2.parent.removeChild(this.layer2);
        this.layer2.destroy(true);
      }
    } catch {}
    this.layer1 = null;
    this.layer2 = null;
    try {
      this.noiseTex?.destroy(true);
    } catch {}
    this.noiseTex = null;
  }
  _applyAlphas(pulseFactor = 1) {
    const base = this._alphaFromIntensity(this.intensity);
    // Noise contribution grows with intensity but remains subtle
    const t = Math.max(0, Math.min(1, this.intensity / 100));
    const noiseAlpha = base * (0.25 + 0.35 * t); // up to ~0.4 of base
    if (this.g) this.g.alpha = base * pulseFactor;
    if (this.layer1) this.layer1.alpha = noiseAlpha * 0.8;
    if (this.layer2) this.layer2.alpha = noiseAlpha;
  }
  _recalcParams() {
    // Map intensity to drift speeds (pixels per ms)
    const t = Math.max(0, Math.min(1, this.intensity / 100));
    const lerp = (a, b, u) => a + (b - a) * u;
    // Two layers drifting in different directions
    this.speed1 = {
      x: lerp(0.005, 0.025, t),
      y: lerp(0.0, 0.012, t)
    };
    this.speed2 = {
      x: lerp(-0.006, -0.018, t),
      y: lerp(0.004, 0.02, t)
    };
  }

  // Static helper: generate small grayscale noise texture
  static _createNoiseTexture(w = 128, h = 128) {
    const canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');
    const img = ctx.createImageData(w, h);
    // Use a gentle noise range to avoid harsh contrast
    for (let i = 0; i < img.data.length; i += 4) {
      const v = 200 + Math.floor(Math.random() * 55); // 200..254
      img.data[i] = v;
      img.data[i + 1] = v;
      img.data[i + 2] = v;
      img.data[i + 3] = 255;
    }
    ctx.putImageData(img, 0, 0);
    return lib/* Texture */.gPd.from(canvas);
  }
}
;// ./src/Pixi/effects/weather/Thunder.js


// Thunder/Lightning weather effect
// API:
//   new WeatherThunder(container, api, getIntensity)
//   setIntensity(v), resize(w,h), update(dtMs), destroy()
// Notes:
// - Renders inside weather layer (below fog). Blocks/tiles remain above fog.
// - Picks random strike targets above solid tiles using api.isSolidAt(x,y).
class WeatherThunder {
  constructor(container, api, getIntensity) {
    this.container = container;
    this.api = api || {};
    this.getIntensity = getIntensity || (() => 0);
    this.width = (api?.mapWidth || 0) * (api?.tileSize || 32);
    this.height = (api?.mapHeight || 0) * (api?.tileSize || 32);
    this.intensity = 0;
    this.time = 0;
    this.nextStrikeMs = Infinity; // scheduled delay to next strike
    this.flashAlpha = 0; // global white flash
    this.flashDecay = 0.0;
    this.boltAlive = false;
    this.boltTime = 0; // ms since bolt spawned
    this.boltDuration = 0; // ms total

    // Graphics
    this.flashG = new lib/* Graphics */.A1g();
    this.boltG = new lib/* Graphics */.A1g();
    // Add slight glow to bolt
    try {
      this.boltG.filters = [new lib/* BlurFilter */.eV2(2, 1)];
    } catch {}
    this.container.addChild(this.flashG);
    this.container.addChild(this.boltG);

    // Build once
    this._scheduleNextStrike(true);
  }
  setIntensity(v) {
    const nv = Math.max(0, Math.min(100, Number(v) || 0));
    if (nv === this.intensity) return;
    this.intensity = nv;
    if (nv <= 0) {
      // disable visuals
      this.flashAlpha = 0;
      this.boltAlive = false;
      this._redrawFlash();
      this._clearBolt();
      this.nextStrikeMs = Infinity;
    } else if (!Number.isFinite(this.nextStrikeMs) || this.nextStrikeMs === Infinity) {
      this._scheduleNextStrike(true);
    }
  }
  resize(w, h) {
    const W = Math.max(1, Math.floor(w));
    const H = Math.max(1, Math.floor(h));
    if (W === this.width && H === this.height) return;
    this.width = W;
    this.height = H;
    // redraw flash when active
    if (this.flashAlpha > 0) this._redrawFlash();
  }
  update(dtMs) {
    // live intensity updates
    const curInt = Math.max(0, Math.min(100, this.getIntensity()));
    if (curInt !== this.intensity) this.setIntensity(curInt);
    const dt = Math.max(0, Number(dtMs) || 16.67);
    if (this.intensity <= 0) return;

    // Update scheduling
    this.nextStrikeMs -= dt;
    if (this.nextStrikeMs <= 0) {
      // Perform strike: trigger screen flash and draw bolt
      this._triggerFlash();
      this._createBolt();
      this._scheduleNextStrike(false); // schedule next time after immediate strike window
    }

    // Flash decay
    if (this.flashAlpha > 0) {
      // exponential-like decay via linear factor raised with dt
      const decayPerMs = this.flashDecay || 0.004; // higher = quicker fade
      this.flashAlpha = Math.max(0, this.flashAlpha - decayPerMs * dt);
      this._redrawFlash();
    }

    // Bolt lifetime
    if (this.boltAlive) {
      this.boltTime += dt;
      const t = this.boltTime / Math.max(1, this.boltDuration);
      // Fade color/alpha over time
      const remain = Math.max(0, 1 - t);
      this.boltG.alpha = 0.25 + 0.75 * remain;
      if (this.boltTime >= this.boltDuration) {
        this._clearBolt();
      }
    }
  }
  destroy() {
    try {
      this.flashG.parent && this.flashG.parent.removeChild(this.flashG);
    } catch {}
    try {
      this.flashG.destroy(true);
    } catch {}
    try {
      this.boltG.parent && this.boltG.parent.removeChild(this.boltG);
    } catch {}
    try {
      this.boltG.destroy(true);
    } catch {}
    this.flashG = null;
    this.boltG = null;
    this.container = null;
  }

  // Internal helpers
  _scheduleNextStrike(initial) {
    // Map intensity 1..100 to delay: from ~9000..6000 ms down to ~2500..1000 ms
    if (this.intensity <= 0) {
      this.nextStrikeMs = Infinity;
      return;
    }
    const t = Math.max(0, Math.min(1, this.intensity / 100));
    const minDelay = this._lerp(1000, 2500, 1 - t); // at high intensity, between 12.5s
    const maxDelay = this._lerp(2500, 9000, 1 - t); // at low intensity, up to ~9s
    const delay = this._rand(minDelay, maxDelay);
    this.nextStrikeMs = initial ? this._rand(400, 1400) : delay; // first strike quicker on enable
  }
  _triggerFlash() {
    // Brightness based on intensity, with slight randomness
    const t = Math.max(0, Math.min(1, this.intensity / 100));
    const base = this._lerp(0.25, 0.9, t);
    this.flashAlpha = Math.min(1, base * this._rand(0.8, 1));
    // fade time scales with intensity (brighter fades a bit slower)
    this.flashDecay = this._lerp(0.008, 0.004, t);
    this._redrawFlash();
  }
  _redrawFlash() {
    const g = this.flashG;
    g.clear();
    if (this.flashAlpha <= 0) return;
    g.beginFill(0xffffff, this.flashAlpha);
    g.drawRect(0, 0, this.width, this.height);
    g.endFill();
  }
  _createBolt() {
    // Determine target using solid scan from top
    const W = this.width,
      H = this.height;
    const x = Math.floor(this._rand(8, W - 8));
    const topY = -Math.floor(this._rand(10, 40)); // start slightly above top
    const targetY = this._findGroundY(x, H);
    const endY = Number.isFinite(targetY) ? Math.max(0, targetY - this._rand(8, 16)) : Math.floor(H * 0.6);

    // Build polyline with jittered segments from top to end
    const segments = Math.max(8, Math.floor((endY - topY) / this._rand(10, 16)));
    const jitterX = this._lerp(6, 18, Math.max(0, Math.min(1, this.intensity / 100)));
    const points = [];
    let cx = x;
    let cy = topY;
    points.push({
      x: cx,
      y: cy
    });
    for (let i = 1; i <= segments; i++) {
      const ny = topY + Math.floor((endY - topY) * i / segments);
      const nx = x + this._rand(-jitterX, jitterX);
      cx = nx;
      cy = ny;
      points.push({
        x: cx,
        y: cy
      });
    }

    // Draw main bolt
    const g = this.boltG;
    g.clear();
    const thickness = this._lerp(2, 5, Math.max(0, Math.min(1, this.intensity / 100)));
    const color = 0xCCEEFF;
    g.lineStyle({
      width: thickness,
      color,
      alpha: 1,
      alignment: 0.5,
      cap: 'round',
      join: 'round'
    });
    g.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) g.lineTo(points[i].x, points[i].y);

    // Branches: some short forks from random mid points
    const branchCount = Math.floor(this._lerp(1, 3, Math.max(0, Math.min(1, this.intensity / 100))));
    for (let b = 0; b < branchCount; b++) {
      const idx = Math.floor(this._rand(2, points.length - 2));
      const p = points[idx];
      const len = this._rand(30, 80);
      const ang = this._rand(-Math.PI * 0.5, Math.PI * 0.5);
      const bx = p.x + Math.cos(ang) * len;
      const by = p.y + Math.sin(ang) * len;
      g.lineStyle({
        width: Math.max(1, thickness * 0.55),
        color,
        alpha: 0.9,
        alignment: 0.5
      });
      g.moveTo(p.x, p.y);
      g.lineTo(bx, by);
    }
    this.boltAlive = true;
    this.boltTime = 0;
    this.boltDuration = this._rand(120, 260); // very brief
    this.boltG.alpha = 1;
  }
  _clearBolt() {
    if (!this.boltG) return;
    this.boltAlive = false;
    this.boltTime = 0;
    this.boltDuration = 0;
    try {
      this.boltG.clear();
    } catch {}
  }
  _findGroundY(worldX, maxH) {
    // Scan from top to bottom to find first solid tile boundary
    const isSolid = this.api?.isSolidAt;
    if (typeof isSolid !== 'function') return null;
    for (let y = 0; y < maxH; y += 4) {
      if (isSolid(worldX, y)) {
        return y;
      }
    }
    return null;
  }
  _rand(a, b) {
    if (b === undefined) {
      b = a;
      a = 0;
    }
    return a + Math.random() * (b - a);
  }
  _lerp(a, b, t) {
    return a + (b - a) * t;
  }
}
;// ./src/Pixi/effects/weather/index.js
// Weather effects exports





;// ./src/Pixi/effects/liquids/WaterSplashFX.js


// WaterSplashFX: lightweight pooled splash particles (droplets + ring ripples)
// API:
//   const fx = new WaterSplashFX(container)
//   fx.trigger({ x, y, strength, upward }) // upward=true for exit splash
//   fx.update(dtMs)
//   fx.resize(w,h) // noop (kept for symmetry)
//   fx.destroy()
class WaterSplashFX {
  constructor(container) {
    this.container = container;
    this.node = new lib/* Container */.mcf();
    this.container.addChild(this.node);
    this.droplets = []; // {g,x,y,vx,vy,life,max}
    this.rings = []; // {g,x,y,r,vr,life,max}
    this.maxDroplets = 48;
    this.maxRings = 6;
  }
  destroy() {
    try {
      this.node.parent && this.node.parent.removeChild(this.node);
    } catch {}
    try {
      this.node.destroy({
        children: true
      });
    } catch {}
    this.node = null;
    this.droplets = [];
    this.rings = [];
  }
  resize() {}
  trigger({
    x = 0,
    y = 0,
    strength = 1,
    upward = false
  } = {}) {
    const s = Math.max(0.2, Math.min(3, Number(strength) || 1));
    // Ring ripple on surface (entry/exit)
    if (this.rings.length < this.maxRings) {
      const g = new lib/* Graphics */.A1g();
      g.x = 0;
      g.y = 0;
      g.alpha = 0.8;
      this.node.addChild(g);
      this.rings.push({
        g,
        x,
        y,
        r: 2 + 4 * s,
        vr: 0.08 + 0.12 * s,
        life: 0,
        max: 450 + 250 * s
      });
    }
    // Droplets burst
    const count = Math.floor(8 + 18 * s);
    for (let i = 0; i < count && this.droplets.length < this.maxDroplets; i++) {
      const ang = upward ? -Math.PI * 0.15 + Math.random() * Math.PI * 0.3 : Math.PI * 0.6 + (Math.random() - 0.5) * Math.PI * 0.6;
      const spd = (0.12 + Math.random() * 0.25) * (upward ? 1.2 : 1) * (0.6 + 0.8 * s);
      const g = new lib/* Graphics */.A1g();
      g.x = 0;
      g.y = 0;
      g.alpha = 1;
      this.node.addChild(g);
      this.droplets.push({
        g,
        x,
        y,
        vx: Math.cos(ang) * spd,
        vy: Math.sin(ang) * spd,
        life: 0,
        max: 500 + Math.random() * 400
      });
    }
  }
  update(dtMs) {
    const dt = Math.max(0, Number(dtMs) || 16.67);
    // Droplets update
    for (let i = this.droplets.length - 1; i >= 0; i--) {
      const d = this.droplets[i];
      d.life += dt;
      d.vy += 0.0018 * dt; // gravity
      d.x += d.vx * dt;
      d.y += d.vy * dt;
      const t = Math.min(1, d.life / d.max);
      const alpha = 1 - t;
      const size = 1 + 1.5 * (1 - t);
      const g = d.g;
      g.clear();
      g.beginFill(0xc9ecff, Math.max(0, alpha));
      g.drawCircle(d.x, d.y, size);
      g.endFill();
      if (d.life >= d.max) {
        try {
          g.parent && g.parent.removeChild(g);
        } catch {}
        try {
          g.destroy();
        } catch {}
        this.droplets.splice(i, 1);
      }
    }
    // Rings update
    for (let i = this.rings.length - 1; i >= 0; i--) {
      const r = this.rings[i];
      r.life += dt;
      r.r += r.vr * dt;
      const t = Math.min(1, r.life / r.max);
      const alpha = 0.6 * (1 - t);
      const g = r.g;
      g.clear();
      g.lineStyle({
        width: 1.5,
        color: 0xc9ecff,
        alpha: Math.max(0, alpha)
      });
      g.drawCircle(r.x, r.y, r.r);
      if (r.life >= r.max) {
        try {
          g.parent && g.parent.removeChild(g);
        } catch {}
        try {
          g.destroy();
        } catch {}
        this.rings.splice(i, 1);
      }
    }
  }
}
;// ./src/Pixi/effects/liquids/LavaEmbers.js


// LavaEmbers: ambient embers with tiny smoke trails spawning from lava surface tiles
// API:
//   const fx = new LavaEmbers(container, api, getIntensity)
//   fx.setIntensity(v)
//   fx.rebuildSurfaces({ mapWidth, mapHeight, tileSize, tileMapData, registryItems })
//   fx.update(dtMs)
//   fx.resize(w,h)
//   fx.destroy()
class LavaEmbers {
  constructor(container, api, getIntensity) {
    this.container = container;
    this.api = api || {};
    this.getIntensity = getIntensity || (() => 0);
    this.node = new lib/* Container */.mcf();
    this.container.addChild(this.node);
    this.intensity = 0;
    this.time = 0;
    this.spawnAcc = 0;
    this.embers = []; // {g,x,y,vx,vy,life,max,trail}
    this.maxEmbers = 60;
    this.surfaces = []; // {x,y,w}
  }
  destroy() {
    try {
      this.node.parent && this.node.parent.removeChild(this.node);
    } catch {}
    try {
      this.node.destroy({
        children: true
      });
    } catch {}
    this.embers = [];
    this.surfaces = [];
  }
  setIntensity(v) {
    const nv = Math.max(0, Math.min(100, Number(v) || 0));
    this.intensity = nv;
  }
  resize() {}
  rebuildSurfaces({
    mapWidth,
    mapHeight,
    tileSize,
    tileMapData,
    registryItems
  }) {
    const getDef = id => Array.isArray(registryItems) ? registryItems.find(r => r.id === id) : null;
    const isLava = def => !!(def && def.flags && def.flags.lava);
    const W = mapWidth,
      H = mapHeight,
      TS = tileSize;
    const spans = [];
    for (let gy = 0; gy < H; gy++) {
      let runStart = -1;
      for (let gx = 0; gx < W; gx++) {
        const idx = gy * W + gx;
        const id = tileMapData[idx];
        if (!id) {
          if (runStart !== -1) {
            runStart = -1;
          }
          continue;
        }
        const def = getDef(id);
        const aboveIdx = (gy - 1) * W + gx;
        const aboveLava = gy > 0 && isLava(getDef(tileMapData[aboveIdx]));
        const hereLava = isLava(def);
        const isSurface = hereLava && !aboveLava;
        if (isSurface) {
          if (runStart === -1) runStart = gx;
        } else {
          if (runStart !== -1) {
            const w = (gx - runStart) * TS;
            if (w > 0) spans.push({
              x: runStart * TS,
              y: gy * TS,
              w
            });
            runStart = -1;
          }
        }
      }
      if (runStart !== -1) {
        const w = (W - runStart) * TS;
        if (w > 0) spans.push({
          x: runStart * TS,
          y: gy * TS,
          w
        });
      }
    }
    this.surfaces = spans;
  }
  _spawnOne() {
    if (!this.surfaces.length) return;
    if (this.embers.length >= this.maxEmbers) return;
    const s = this.surfaces[Math.floor(Math.random() * this.surfaces.length)];
    const x = s.x + Math.random() * s.w;
    const y = s.y - 2; // just above surface
    const g = new lib/* Graphics */.A1g();
    this.node.addChild(g);
    const vx = (Math.random() - 0.5) * 0.02; // small horizontal drift
    const vy = -0.05 - Math.random() * 0.06; // initial upward
    const life = 0;
    const max = 1200 + Math.random() * 1200; // 1.2..2.4s
    this.embers.push({
      g,
      x,
      y,
      vx,
      vy,
      life,
      max,
      trail: []
    });
  }
  update(dtMs) {
    const dt = Math.max(0, Number(dtMs) || 16.67);
    // live intensity
    const cur = Math.max(0, Math.min(100, this.getIntensity()));
    this.setIntensity(cur);
    if (this.intensity <= 0) return;

    // Spawn rate depends on intensity and surface count
    const baseRate = 0.0015 + 0.0035 * (this.intensity / 100); // embers per ms
    const mult = Math.max(0.5, Math.min(3, this.surfaces.length / 6));
    this.spawnAcc += dt * baseRate * mult;
    while (this.spawnAcc >= 1) {
      this._spawnOne();
      this.spawnAcc -= 1;
    }

    // Update embers
    for (let i = this.embers.length - 1; i >= 0; i--) {
      const e = this.embers[i];
      e.life += dt;
      // motion: rise then fall slightly
      e.vy += 0.00006 * dt; // gravity slowly pulls down
      e.x += e.vx * dt;
      e.y += e.vy * dt;
      // record simple smoke trail points
      if (e.trail.length < 14) e.trail.push({
        x: e.x,
        y: e.y
      });else {
        e.trail.shift();
        e.trail.push({
          x: e.x,
          y: e.y
        });
      }
      const t = Math.min(1, e.life / e.max);
      const emberAlpha = 1 - t;
      const emberSize = 1 + 1.5 * (1 - t);
      const g = e.g;
      g.clear();
      // smoke trail (fainter)
      g.lineStyle({
        width: 1,
        color: 0x555555,
        alpha: 0.25 * emberAlpha
      });
      for (let k = 1; k < e.trail.length; k++) {
        const p0 = e.trail[k - 1];
        const p1 = e.trail[k];
        g.moveTo(p0.x, p0.y);
        g.lineTo(p1.x, p1.y);
      }
      // glowing ember
      g.beginFill(0xffa229, 0.9 * emberAlpha);
      g.drawCircle(e.x, e.y, emberSize);
      g.endFill();
      if (e.life >= e.max) {
        try {
          g.parent && g.parent.removeChild(g);
        } catch {}
        try {
          g.destroy();
        } catch {}
        this.embers.splice(i, 1);
      }
    }
  }
}
;// ./src/Pixi/effects/liquids/LavaSteamFX.js


// LavaSteamFX: tiny steam puffs when rain/snow hits lava surface
// API:
//   const steam = new LavaSteamFX(parentContainer)
//   steam.trigger({ x, y, strength })
//   steam.update(dtMs)
//   steam.destroy()
class LavaSteamFX {
  constructor(container) {
    this.container = container;
    this.node = new lib/* Container */.mcf();
    this.container.addChild(this.node);
    this.puffs = []; // {g,x,y,vx,vy,life,max,r}
    this.maxPuffs = 80;
  }
  destroy() {
    try {
      this.node.parent && this.node.parent.removeChild(this.node);
    } catch {}
    try {
      this.node.destroy({
        children: true
      });
    } catch {}
    this.node = null;
    this.puffs = [];
  }
  resize() {}
  trigger({
    x = 0,
    y = 0,
    strength = 0.7
  } = {}) {
    const s = Math.max(0.2, Math.min(2.5, Number(strength) || 0.7));
    const count = Math.max(2, Math.floor(3 + 4 * s));
    for (let i = 0; i < count && this.puffs.length < this.maxPuffs; i++) {
      const g = new lib/* Graphics */.A1g();
      this.node.addChild(g);
      const vx = (Math.random() - 0.5) * (0.03 + 0.03 * s);
      const vy = -(0.08 + Math.random() * 0.08) * (0.8 + 0.4 * s);
      const r = 1.5 + Math.random() * (2.5 * s);
      const max = 450 + Math.random() * 350;
      this.puffs.push({
        g,
        x,
        y: y - 2,
        vx,
        vy,
        life: 0,
        max,
        r
      });
    }
  }
  update(dtMs) {
    const dt = Math.max(0, Number(dtMs) || 16.67);
    for (let i = this.puffs.length - 1; i >= 0; i--) {
      const p = this.puffs[i];
      p.life += dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      // slight expansion and fade
      const t = Math.min(1, p.life / p.max);
      const alpha = 0.75 * (1 - t);
      const radius = p.r * (1 + 0.8 * t);
      const g = p.g;
      g.clear();
      // soft grey-white steam
      g.beginFill(0xdfdad2, Math.max(0, alpha));
      g.drawCircle(p.x, p.y, radius);
      g.endFill();
      if (p.life >= p.max) {
        try {
          g.parent && g.parent.removeChild(g);
        } catch {}
        try {
          g.destroy();
        } catch {}
        this.puffs.splice(i, 1);
      }
    }
  }
}
;// ./src/Pixi/effects/liquids/LiquidRegionSystem.js


// LiquidRegionSystem: groups contiguous liquid tiles (water/lava) into regions
// and renders each region as a masked, animated tiling surface (weather-like style)
// while constrained to the exact sector (region) shape.
//
// API:
//   const sys = new LiquidRegionSystem(parentContainer, { mapWidth, mapHeight, tileSize });
//   sys.build({ mapWidth, mapHeight, tileSize, tileMapData, registryItems });
//   sys.update(dtMs);
//   sys.resize(mapWidth, mapHeight, tileSize);
//   sys.destroy();

class LiquidRegionSystem {
  constructor(container, opts = {}) {
    this.container = container;
    this.mapWidth = opts.mapWidth || 0;
    this.mapHeight = opts.mapHeight || 0;
    this.tileSize = opts.tileSize || 32;
    this._regions = []; // { type, node, mask, sprite, noise1, noise2, capG, topEdges, waves:[] }
    this._waterTex = null;
    this._lavaTex = null;
    this._time = 0;
    this._noiseTex = null;
  }

  // Query approximate surface Y (pixel) for a given X within liquid regions of type ('water'|'lava')
  getSurfaceY(type, x) {
    if (!Array.isArray(this._regions) || this._regions.length === 0) return null;
    const X = Math.max(0, Math.floor(Number(x) || 0));
    for (const r of this._regions) {
      if (r.type !== type) continue;
      if (!Array.isArray(r.topEdges)) continue;
      for (let i = 0; i < r.topEdges.length; i++) {
        const e = r.topEdges[i];
        if (X >= e.x && X <= e.x + e.w) {
          return e.y; // region tile top in pixels
        }
      }
    }
    return null;
  }
  destroy() {
    try {
      for (const r of this._regions) {
        try {
          if (r.node && r.node.parent) r.node.parent.removeChild(r.node);
        } catch {}
        try {
          r.node?.destroy({
            children: true
          });
        } catch {}
      }
    } catch {}
    this._regions = [];
    try {
      this._waterTex?.destroy(true);
    } catch {}
    try {
      this._lavaTex?.destroy(true);
    } catch {}
    try {
      this._noiseTex?.destroy(true);
    } catch {}
    this._waterTex = null;
    this._lavaTex = null;
    this._noiseTex = null;
  }
  clear() {
    for (const r of this._regions) {
      try {
        r.node?.parent && r.node.parent.removeChild(r.node);
      } catch {}
      try {
        r.node?.destroy({
          children: true
        });
      } catch {}
    }
    this._regions = [];
  }
  resize(mapWidth, mapHeight, tileSize) {
    const mw = Math.max(1, mapWidth | 0);
    const mh = Math.max(1, mapHeight | 0);
    const ts = Math.max(1, tileSize | 0);
    const changed = mw !== this.mapWidth || mh !== this.mapHeight || ts !== this.tileSize;
    this.mapWidth = mw;
    this.mapHeight = mh;
    this.tileSize = ts;
    if (changed) {
      // rebuild textures at new tile size; regions will be rebuilt by caller
      try {
        this._waterTex?.destroy(true);
      } catch {}
      try {
        this._lavaTex?.destroy(true);
      } catch {}
      this._waterTex = null;
      this._lavaTex = null;
    }
  }
  update(dtMs) {
    const dt = Math.max(0, Number(dtMs) || 16.67);
    this._time += dt;
    // Gentle drift speeds (px/ms) per liquid type
    const waterDrift = {
      x: 0.010,
      y: 0.004
    };
    const lavaDrift = {
      x: -0.012,
      y: 0.006
    };
    for (const r of this._regions) {
      const sprite = r.sprite;
      if (!sprite) continue;
      const drift = r.type === 'lava' ? lavaDrift : waterDrift;
      sprite.tilePosition.x += drift.x * dt;
      sprite.tilePosition.y += drift.y * dt;
      // Subtle alpha breathing for water
      if (r.type === 'water') {
        const pulse = 0.96 + 0.04 * Math.sin(this._time * 0.0012);
        sprite.alpha = 0.9 * pulse; // around ~0.86..0.94
      } else {
        sprite.alpha = 0.98;
      }

      // Animate noise overlays to break repetition
      if (r.noise1) {
        r.noise1.tilePosition.x += drift.x * 1.6 * dt;
        r.noise1.tilePosition.y += drift.y * 1.2 * dt;
      }
      if (r.noise2) {
        r.noise2.tilePosition.x += -drift.x * 1.1 * dt;
        r.noise2.tilePosition.y += drift.y * 0.9 * dt;
      }

      // Update interactive surface waves (small ripples from impacts)
      if (!Array.isArray(r.waves)) r.waves = [];
      if (r.waves.length) {
        for (let i = r.waves.length - 1; i >= 0; i--) {
          const w = r.waves[i];
          w.t += dt; // ms
          // Lifetimes: water longer than lava
          const life = r.type === 'water' ? w.lifeMsWater : w.lifeMsLava;
          if (w.t >= life) {
            r.waves.splice(i, 1);
            continue;
          }
          // expand radius over time (px)
          w.radius = w.startRadius + w.speed * (w.t / 1000);
          // exponential decay of amplitude
          const decay = Math.exp(-w.t / (r.type === 'water' ? 1400 : 900));
          w.ampNow = w.amp * decay;
        }
      }

      // Animate water surface cap (rim light) with slight sine undulation
      if (r.type === 'water' && r.capG && Array.isArray(r.topEdges) && r.topEdges.length) {
        const g = r.capG;
        const amp = Math.max(1, Math.floor(this.tileSize * 0.06));
        const thickness = Math.max(1, Math.floor(this.tileSize * 0.08));
        g.clear();
        g.beginFill(0xc9ecff, 0.35);
        for (let i = 0; i < r.topEdges.length; i++) {
          const e = r.topEdges[i];
          // slight vertical offset wave
          let dy = Math.sin(this._time * 0.002 + e.x * 0.15) * (amp * 0.5);
          // Add contributions from interactive waves (Gaussian falloff)
          if (r.waves && r.waves.length) {
            // use span center for sampling; keeps draw perf O(spans + waves)
            const centerX = e.x + e.w * 0.5;
            for (let k = 0; k < r.waves.length; k++) {
              const w = r.waves[k];
              const dx = centerX - w.cx;
              const dist = Math.abs(dx);
              if (dist > w.radius + e.w * 0.6) continue; // early reject
              const sigma = Math.max(8, w.radius * 0.6);
              const gauss = Math.exp(-(dx * dx) / (2 * sigma * sigma));
              dy += w.ampNow * gauss;
            }
            // clamp to avoid excessive displacement
            const maxDisp = Math.max(2, this.tileSize * 0.22);
            if (dy > maxDisp) dy = maxDisp;
            if (dy < -maxDisp) dy = -maxDisp;
          }
          g.drawRect(e.x, e.y - thickness + dy, e.w, thickness);
        }
        g.endFill();
      }
    }
  }
  build({
    mapWidth,
    mapHeight,
    tileSize,
    tileMapData,
    registryItems
  }) {
    if (!Array.isArray(tileMapData) || !Array.isArray(registryItems)) return;
    this.resize(mapWidth, mapHeight, tileSize);
    this.clear();
    const W = this.mapWidth;
    const H = this.mapHeight;
    const TS = this.tileSize;
    const count = W * H;
    const getDef = id => registryItems.find(r => r.id === id);
    const typeAt = i => {
      const id = tileMapData[i];
      if (!id) return null;
      const def = getDef(id);
      if (!def || !def.flags || !def.flags.liquid) return null;
      if (def.flags.water) return 'water';
      if (def.flags.lava) return 'lava';
      return 'liquid';
    };
    const visited = new Uint8Array(count);
    const dirs = [1, -1, W, -W]; // 4-connectivity

    for (let i = 0; i < count; i++) {
      if (visited[i]) continue;
      const t = typeAt(i);
      if (!t) {
        visited[i] = 1;
        continue;
      }

      // Flood fill this region for same liquid type
      const regionTiles = [];
      const queue = [i];
      visited[i] = 1;
      while (queue.length) {
        const idx = queue.pop();
        regionTiles.push(idx);
        for (let d = 0; d < 4; d++) {
          const n = idx + dirs[d];
          if (n < 0 || n >= count) continue;
          if (visited[n]) continue;
          // prevent wrapping on left/right when using +/-1
          if (d < 2) {
            const row = Math.floor(idx / W);
            const nrow = Math.floor(n / W);
            if (row !== nrow) continue;
          }
          const nt = typeAt(n);
          if (nt === t) {
            visited[n] = 1;
            queue.push(n);
          } else {
            visited[n] = visited[n] || 0;
          }
        }
      }
      if (regionTiles.length === 0) continue;
      this._addRegion(t, regionTiles, W, H, TS);
    }
  }
  _addRegion(type, tileIndices, mapWidth, mapHeight, tileSize) {
    const node = new lib/* Container */.mcf();
    const mask = new lib/* Graphics */.A1g();
    const worldW = mapWidth * tileSize;
    const worldH = mapHeight * tileSize;

    // Draw mask as union of tile rects (grid-aligned)
    // To avoid hairline gaps between rows/columns due to AA/subpixel sampling,
    // slightly expand each rect by a small bleed so neighbors overlap.
    mask.clear();
    mask.beginFill(0xffffff, 1);
    const bleed = 0.5; // px
    for (let k = 0; k < tileIndices.length; k++) {
      const idx = tileIndices[k];
      const gx = idx % mapWidth;
      const gy = Math.floor(idx / mapWidth);
      mask.drawRect(gx * tileSize - bleed, gy * tileSize - bleed, tileSize + bleed * 2, tileSize + bleed * 2);
    }
    mask.endFill();
    const tex = type === 'lava' ? this._lavaTex || (this._lavaTex = this._createLavaTexture(tileSize)) : this._waterTex || (this._waterTex = this._createWaterTexture(tileSize));
    const tiling = new lib/* TilingSprite */.t9Q(tex, worldW, worldH);
    tiling.tileScale.set(1, 1);
    tiling.alpha = type === 'lava' ? 0.98 : 0.92;
    // Ensure integer placement to reduce sampling seams
    tiling.x = 0;
    tiling.y = 0;

    // Constrain fill to region mask
    node.addChild(tiling);
    // Add subtle noise overlays to break repetition
    const noiseTex = this._noiseTex || (this._noiseTex = this._createNoiseTexture(128, 128));
    const noise1 = new lib/* TilingSprite */.t9Q(noiseTex, worldW, worldH);
    const noise2 = new lib/* TilingSprite */.t9Q(noiseTex, worldW, worldH);
    // Different scales/alphas per liquid
    if (type === 'water') {
      noise1.tileScale.set(0.9, 1.1);
      noise2.tileScale.set(0.6, 0.7);
      noise1.alpha = 0.06;
      noise2.alpha = 0.08;
    } else {
      noise1.tileScale.set(1.2, 0.9);
      noise2.tileScale.set(0.7, 0.6);
      noise1.alpha = 0.08;
      noise2.alpha = 0.12;
    }
    node.addChild(noise1);
    node.addChild(noise2);
    node.addChild(mask);
    node.mask = mask;

    // Water surface rim highlight along top edges of the region
    let capG = null;
    let topEdges = null;
    if (type === 'water') {
      capG = new lib/* Graphics */.A1g();
      node.addChild(capG);
      topEdges = this._computeTopEdgeSpans(tileIndices, mapWidth, tileSize);
    }
    this.container.addChild(node);
    this._regions.push({
      type,
      node,
      mask,
      sprite: tiling,
      noise1,
      noise2,
      capG,
      topEdges,
      waves: []
    });
  }
  _createWaterTexture(tileSize) {
    const canvas = document.createElement('canvas');
    canvas.width = tileSize;
    canvas.height = tileSize;
    const ctx = canvas.getContext('2d');
    // base gradient
    const g = ctx.createLinearGradient(0, 0, 0, tileSize);
    g.addColorStop(0, '#2a5d8f');
    g.addColorStop(1, '#174369');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, tileSize, tileSize);
    // ripples
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = '#8fc0ff';
    const bands = 3;
    for (let b = 0; b < bands; b++) {
      const y = Math.floor(tileSize / bands * b + tileSize / bands * 0.5);
      ctx.fillRect(0, y, tileSize, Math.max(1, Math.floor(tileSize * 0.06)));
    }
    // top highlight
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = '#c9ecff';
    ctx.fillRect(0, 0, tileSize, Math.max(1, Math.floor(tileSize * 0.12)));
    return lib/* Texture */.gPd.from(canvas);
  }
  _createLavaTexture(tileSize) {
    const canvas = document.createElement('canvas');
    canvas.width = tileSize;
    canvas.height = tileSize;
    const ctx = canvas.getContext('2d');
    const g = ctx.createLinearGradient(0, 0, 0, tileSize);
    g.addColorStop(0, '#6b1a07');
    g.addColorStop(1, '#c43f0f');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, tileSize, tileSize);
    // veins
    ctx.globalAlpha = 0.3;
    for (let b = 0; b < 3; b++) {
      const y = Math.floor(tileSize / 3 * b + tileSize / 3 * 0.5);
      const h = Math.max(1, Math.floor(tileSize * 0.07));
      const grad = ctx.createLinearGradient(0, y, 0, y + h);
      grad.addColorStop(0, '#ffed8a');
      grad.addColorStop(1, '#ff7b00');
      ctx.fillStyle = grad;
      ctx.fillRect(0, y, tileSize, h);
    }
    // bubbles
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = '#ffd36e';
    const count = Math.max(2, Math.floor(tileSize * 0.12));
    for (let k = 0; k < count; k++) {
      const rx = Math.floor(k * 37 % tileSize);
      const ry = Math.floor(k * 53 % tileSize);
      ctx.fillRect(rx, ry, 1, 1);
    }
    return lib/* Texture */.gPd.from(canvas);
  }
  _createNoiseTexture(w = 128, h = 128) {
    const canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');
    const img = ctx.createImageData(w, h);
    for (let i = 0; i < img.data.length; i += 4) {
      // soft noise around mid-high values
      const v = 200 + Math.floor(Math.random() * 55); // 200..254
      img.data[i] = v;
      img.data[i + 1] = v;
      img.data[i + 2] = v;
      img.data[i + 3] = 255;
    }
    ctx.putImageData(img, 0, 0);
    return lib/* Texture */.gPd.from(canvas);
  }

  // Given tile indices of a region, compute horizontal spans representing its top boundary per row.
  _computeTopEdgeSpans(tileIndices, mapWidth, tileSize) {
    // Build a set for O(1) membership
    const set = new Set(tileIndices);
    const spans = [];
    // For each tile that has no neighbor directly above, create a span; merge contiguous tiles in that row
    const tilesByRow = new Map();
    for (const idx of tileIndices) {
      const gy = Math.floor(idx / mapWidth);
      const gx = idx % mapWidth;
      const above = idx - mapWidth;
      if (!set.has(above)) {
        // This tile contributes to the top edge
        const rowList = tilesByRow.get(gy) || [];
        rowList.push(gx);
        tilesByRow.set(gy, rowList);
      }
    }
    // Merge contiguous gx into spans
    for (const [gy, cols] of tilesByRow.entries()) {
      cols.sort((a, b) => a - b);
      let start = null;
      let prev = null;
      for (const gx of cols) {
        if (start === null) {
          start = gx;
          prev = gx;
          continue;
        }
        if (gx === prev + 1) {
          prev = gx;
          continue;
        }
        // flush previous span
        spans.push({
          x: start * tileSize,
          y: gy * tileSize,
          w: (prev - start + 1) * tileSize
        });
        start = gx;
        prev = gx;
      }
      if (start !== null) {
        spans.push({
          x: start * tileSize,
          y: gy * tileSize,
          w: (prev - start + 1) * tileSize
        });
      }
    }
    return spans;
  }

  // Public: add a ripple/wave on a liquid surface of given type at world x
  // type: 'water'|'lava'
  // x: world pixel X
  // strength: 0.2..3 roughly; maps to amplitude and speed
  addWave(type, x, strength = 1) {
    const t = type === 'lava' ? 'lava' : 'water';
    const X = Math.max(0, Math.min(this.mapWidth * this.tileSize, Number(x) || 0));
    // Find region and a top edge span containing x
    for (const r of this._regions) {
      if (r.type !== t) continue;
      const spans = r.topEdges;
      if (!Array.isArray(spans) || spans.length === 0) continue;
      for (let i = 0; i < spans.length; i++) {
        const e = spans[i];
        if (X >= e.x && X <= e.x + e.w) {
          if (!Array.isArray(r.waves)) r.waves = [];
          // Cap total waves to keep perf stable
          if (r.waves.length > 24) r.waves.shift();
          const ts = this.tileSize;
          const s = Math.max(0.15, Math.min(3, Number(strength) || 1));
          const baseAmp = t === 'water' ? ts * 0.18 : ts * 0.10; // pixels
          const amp = baseAmp * (0.4 + 0.6 * Math.min(1.0, s));
          const speed = t === 'water' ? 40 + 60 * s : 30 + 40 * s; // px/s growth
          const startRadius = Math.max(4, ts * 0.2);
          // lifetimes in ms
          const lifeMsWater = 1600 + 900 * s;
          const lifeMsLava = 900 + 600 * s;
          r.waves.push({
            cx: X,
            t: 0,
            amp,
            ampNow: amp,
            speed,
            radius: startRadius,
            startRadius,
            lifeMsWater,
            lifeMsLava
          });
          return true;
        }
      }
    }
    return false;
  }
}
;// ./src/Pixi/effects/liquids/index.js
// Liquid effects exports




;// ./src/Pixi/ui/HealthBar.js
// Lightweight reusable health bar for PixiJS
// Usage:
//   import { HealthBar } from './HealthBar';
//   const hb = new HealthBar({ width: 32, height: 4, offsetY: -6 });
//   container.addChild(hb);
//   hb.update(currentHealth, maxHealth);


class HealthBar extends lib/* Container */.mcf {
  constructor(options = {}) {
    super();
    const {
      width = 32,
      height = 4,
      offsetX = 0,
      offsetY = -6,
      thresholds = {
        warn: 0.55,
        danger: 0.35
      },
      colors = {
        ok: 0x2ecc71,
        warn: 0xf1c40f,
        danger: 0xe74c3c
      },
      // Use a neutral gray track instead of near-black; keep border options for backward compat (unused)
      trackColor = 0x666666,
      borderColor = 0x000000,
      borderAlpha = 0.8
    } = options;
    this._w = Math.max(4, Math.floor(width));
    this._h = Math.max(2, Math.floor(height));
    this._pct = -1; // force first draw
    this._color = 0xffffff;
    this._thresholds = thresholds;
    this._colors = colors;
    this._trackColor = trackColor;
    this._borderColor = borderColor;
    this._borderAlpha = borderAlpha;
    this.x = offsetX || 0;
    this.y = offsetY || 0;
    this._track = new lib/* Graphics */.A1g();
    this._fill = new lib/* Graphics */.A1g();
    this.addChild(this._track);
    this.addChild(this._fill);
    this._redrawAll();
  }
  resize(width, height) {
    const w = Math.max(4, Math.floor(width || this._w));
    const h = Math.max(2, Math.floor(height || this._h));
    if (w === this._w && h === this._h) return;
    this._w = w;
    this._h = h;
    this._redrawAll();
  }
  update(current, max) {
    const m = Math.max(0, Number(max) || 0);
    if (m <= 0 || !Number.isFinite(current)) {
      this.visible = false;
      return;
    }
    const c = Math.max(0, Math.min(m, Number(current)));
    const pct = m > 0 ? c / m : 0;
    this.visible = true;
    const color = pct < this._thresholds.danger ? this._colors.danger : pct < this._thresholds.warn ? this._colors.warn : this._colors.ok;

    // Only redraw fill if percent or color changed noticeably
    if (Math.abs(pct - this._pct) > 0.001 || color !== this._color) {
      this._pct = pct;
      this._color = color;
      this._redrawFill();
    }
  }
  _redrawAll() {
    // Track (no border)
    const w = this._w,
      h = this._h;
    this._track.clear();
    this._track.beginFill(this._trackColor, 0.85);
    this._track.drawRoundedRect(0, 0, w, h, Math.min(3, h * 0.5));
    this._track.endFill();
    // Redraw fill with current state
    this._redrawFill();
  }
  _redrawFill() {
    const w = this._w,
      h = this._h;
    const innerW = Math.max(0, Math.floor(w * Math.max(0, Math.min(1, this._pct))));
    const radius = Math.min(2, Math.floor(h / 2));
    this._fill.clear();
    if (innerW <= 0) return;
    this._fill.beginFill(this._color, 1);
    // Draw flush with track (no border/padding)
    this._fill.drawRoundedRect(0, 0, innerW, h, radius);
    this._fill.endFill();
  }
}
/* harmony default export */ const ui_HealthBar = (HealthBar);
;// ./src/renderer/stage/layers/LayerOrder.js
// Centralized z-order constants for Pixi stage layers
// Higher numbers render above lower numbers when sortableChildren = true
const LAYERS = Object.freeze({
  parallax: 10,
  objBehind: 20,
  player: 30,
  projectiles: 40,
  objFront: 50,
  weather: 60,
  fog: 70,
  liquids: 80,
  liquidFx: 90,
  tiles: 100,
  tilesAnim: 110,
  overlay: 120
});
/* harmony default export */ const LayerOrder = (LAYERS);
;// ./src/sections/chapters/PixiStage.jsx











// Suppress noisy Pixi Assets warnings for inlined data URLs (we load textures directly)

lib/* Assets */.sP.setPreferences?.({
  skipCacheIdWarning: true
});

// Minimal Pixi-based stage that replaces DOM grid rendering
// Props:
// - mapWidth, mapHeight: grid dimensions in tiles
// - tileSize: pixel size of one tile (default 32)
// - tileMapData: array of IDs for background layer
// - objectMapData: array of IDs for entities layer (excluding player)
// - registryItems: array of registry entries with { id, texture, textures, animationSpeed, width, height }
// - playerState: { x, y, direction, animation, health, width, height }
// - playerVisuals: registry item to use for the player visuals
const PixiStage = ({
  mapWidth,
  mapHeight,
  tileSize = 32,
  tileMapData = [],
  objectMapData = [],
  objectTextureIndices = {},
  registryItems = [],
  playerState,
  playerVisuals,
  backgroundImage,
  backgroundColor,
  backgroundParallaxFactor = 0.3,
  cameraScrollX = 0,
  weatherRain = 0,
  weatherSnow = 0,
  weatherClouds = 0,
  projectiles = [],
  healthBarEnabled = true,
  weatherFog = 0,
  weatherThunder = 0,
  oxygenBarEnabled = true,
  lavaBarEnabled = true,
  waterSplashesEnabled = true,
  lavaEmbersEnabled = true
}) => {
  const mountRef = (0,react.useRef)(null);
  const appRef = (0,react.useRef)(null);
  const parallaxRef = (0,react.useRef)(null);
  const parallaxSpriteRef = (0,react.useRef)(null);
  const parallaxHelperRef = (0,react.useRef)(null); // ParallaxBackground helper
  const cameraScrollRef = (0,react.useRef)(0);
  const parallaxFactorRef = (0,react.useRef)(Number(backgroundParallaxFactor) || 0.3);
  const bgRef = (0,react.useRef)(null);
  const bgAnimRef = (0,react.useRef)(null); // animated tiles container above baked chunks
  const bgChunkLayerRef = (0,react.useRef)(null); // TileChunkLayer instance
  const objBehindRef = (0,react.useRef)(null); // objects behind player
  const objFrontRef = (0,react.useRef)(null); // objects above player
  const playerRef = (0,react.useRef)(null); // container holding default/target sprites
  const playerSpriteRefs = (0,react.useRef)({
    def: null,
    hit: null
  });
  const playerHealthBarRef = (0,react.useRef)(null);
  const playerStateRef = (0,react.useRef)(null);
  const weatherLayerRef = (0,react.useRef)(null);
  const liquidLayerRef = (0,react.useRef)(null);
  const liquidSystemRef = (0,react.useRef)(null);
  const fogLayerRef = (0,react.useRef)(null); // reused as clouds overlay layer
  const weatherSystemsRef = (0,react.useRef)({
    rain: null,
    snow: null,
    clouds: null,
    thunder: null
  });
  const projectilesLayerRef = (0,react.useRef)(null);
  const projectileSpritesRef = (0,react.useRef)(new Map()); // id -> sprite
  const projectilesPropRef = (0,react.useRef)([]);
  const pixiTextureCacheRef = (0,react.useRef)(null); // central TextureCache
  const hbEnabledRef = (0,react.useRef)(healthBarEnabled !== false);
  const oxyEnabledRef = (0,react.useRef)(oxygenBarEnabled !== false);
  const lavaEnabledRef = (0,react.useRef)(lavaBarEnabled !== false);
  const overlayLayerRef = (0,react.useRef)(null); // topmost overlay (underwater tint)
  const underwaterRef = (0,react.useRef)({
    g: null,
    time: 0
  });
  const waterFramesRef = (0,react.useRef)(null); // cached procedural water textures
  const lavaFramesRef = (0,react.useRef)(null); // cached procedural lava textures
  const overlayHBRef = (0,react.useRef)(null); // health bar rendered above water
  const oxygenBarRef = (0,react.useRef)(null); // oxygen bar when in water
  const lavaBarRef = (0,react.useRef)(null); // lava resistance bar when in lava
  const waterFxRef = (0,react.useRef)(null); // water splash FX
  const lavaEmbersRef = (0,react.useRef)(null); // lava ember FX
  const lavaSteamRef = (0,react.useRef)(null); // lava steam FX (rain/snow impacts)
  const splashesEnabledRef = (0,react.useRef)(waterSplashesEnabled !== false);
  const embersEnabledRef = (0,react.useRef)(lavaEmbersEnabled !== false);
  const waterStateRef = (0,react.useRef)({
    inWater: false,
    headUnder: false,
    vy: 0
  });

  // keep latest player state and camera scroll for ticker without re-subscribing
  (0,react.useEffect)(() => {
    playerStateRef.current = playerState;
  }, [playerState]);
  (0,react.useEffect)(() => {
    projectilesPropRef.current = Array.isArray(projectiles) ? projectiles : [];
  }, [projectiles]);
  (0,react.useEffect)(() => {
    hbEnabledRef.current = healthBarEnabled !== false;
  }, [healthBarEnabled]);
  (0,react.useEffect)(() => {
    oxyEnabledRef.current = oxygenBarEnabled !== false;
  }, [oxygenBarEnabled]);
  (0,react.useEffect)(() => {
    lavaEnabledRef.current = lavaBarEnabled !== false;
  }, [lavaBarEnabled]);
  (0,react.useEffect)(() => {
    splashesEnabledRef.current = waterSplashesEnabled !== false;
  }, [waterSplashesEnabled]);
  (0,react.useEffect)(() => {
    embersEnabledRef.current = lavaEmbersEnabled !== false;
  }, [lavaEmbersEnabled]);
  (0,react.useEffect)(() => {
    cameraScrollRef.current = Number(cameraScrollX) || 0;
  }, [cameraScrollX]);
  (0,react.useEffect)(() => {
    parallaxFactorRef.current = Number(backgroundParallaxFactor) || 0.3;
  }, [backgroundParallaxFactor]);

  // Small helper cache for textures
  const textureCacheRef = (0,react.useRef)(new Map());
  const getTexture = url => {
    if (!url) return null;
    const cache = textureCacheRef.current;
    if (cache.has(url)) return cache.get(url);
    const tex = lib/* Texture */.gPd.from(url);
    cache.set(url, tex);
    return tex;
  };

  // Background images resolver (from src/assets/background)
  // Meta stores `/assets/background/<name>`
  let bgContext;
  try {
    // webpack require.context (CRA)
    // relative to this file: '../../assets/background'
    bgContext = __webpack_require__(8870);
  } catch (e) {
    bgContext = null;
  }
  const resolveBackgroundUrl = metaPath => {
    if (!bgContext) return null;
    if (!metaPath) {
      const keys = bgContext.keys();
      if (keys && keys.length) {
        const mod = bgContext(keys[0]);
        return mod.default || mod;
      }
      return null;
    }
    const name = metaPath.split('/').pop();
    const rel = `./${name}`;
    try {
      const mod = bgContext(rel);
      return mod.default || mod;
    } catch (e) {
      // fallback to first available
      const keys = bgContext.keys();
      if (keys && keys.length) {
        const mod = bgContext(keys[0]);
        return mod.default || mod;
      }
      return null;
    }
  };

  // Build or rebuild parallax background via helper
  const rebuildParallax = () => {
    const app = appRef.current;
    const layer = parallaxRef.current;
    if (!app || !layer) return;
    if (!pixiTextureCacheRef.current) pixiTextureCacheRef.current = new TextureCache();
    if (!parallaxHelperRef.current) parallaxHelperRef.current = new ParallaxBackground(layer, pixiTextureCacheRef.current);
    const url = resolveBackgroundUrl(backgroundImage);
    parallaxHelperRef.current.build({
      worldWidth: mapWidth * tileSize,
      worldHeight: mapHeight * tileSize,
      url,
      color: backgroundColor,
      factor: parallaxFactorRef.current || 0.3
    });
    parallaxSpriteRef.current = parallaxHelperRef.current.sprite;
  };

  // Convert ms-per-frame (JSON) to Pixi AnimatedSprite speed factor (1 = 60fps)
  const msToSpeed = ms => {
    const m = Number(ms);
    const msPerFrame = Number.isFinite(m) && m > 0 ? m : 500;
    const fps = 1000 / msPerFrame;
    return fps / 60; // Pixi speed factor
  };
  const getRegItem = id => registryItems.find(r => r.id === id);

  // Solid collision helper for world tiles (used by weather systems)
  const isSolidAt = (wx, wy) => {
    // Allow particles (snow/rain) to spawn above the top edge and fall into the world.
    // Negative Y should NOT be treated as solid, otherwise flakes will "settle" off-screen.
    if (wy < 0) return false;
    // Keep left-of-world as solid to avoid pushing from outside horizontally.
    if (wx < 0) return true;
    const gx = Math.floor(wx / tileSize);
    const gy = Math.floor(wy / tileSize);
    if (gx < 0 || gy < 0 || gx >= mapWidth || gy >= mapHeight) return false; // below world is not solid
    const idx = gy * mapWidth + gx;
    const id = tileMapData[idx];
    if (!id) return false;
    const def = getRegItem(id);
    if (!def) return false;
    const c = def.collision;
    if (!c) return false;
    if (c === true) return true;
    if (typeof c === 'object') {
      return !!(c.top || c.bottom || c.left || c.right);
    }
    return false;
  };

  // Initialize Application
  (0,react.useEffect)(() => {
    let destroyed = false;
    const init = async () => {
      const app = new lib/* Application */.lgM();
      await app.init({
        width: mapWidth * tileSize,
        height: mapHeight * tileSize,
        backgroundAlpha: 0,
        antialias: false,
        autoDensity: true
      });
      if (destroyed) {
        app.destroy(true);
        return;
      }
      appRef.current = app;
      // Enable zIndex ordering for stage children
      try {
        app.stage.sortableChildren = true;
      } catch {}
      const bg = new lib/* Container */.mcf();
      const bgAnim = new lib/* Container */.mcf();
      const objBehind = new lib/* Container */.mcf();
      const objFront = new lib/* Container */.mcf();
      const playerLayer = new lib/* Container */.mcf();
      const weatherLayer = new lib/* Container */.mcf();
      const liquidLayer = new lib/* Container */.mcf();
      const liquidFxLayer = new lib/* Container */.mcf();
      const fogLayer = new lib/* Container */.mcf();
      const projLayer = new lib/* Container */.mcf();
      const overlayLayer = new lib/* Container */.mcf();

      // Assign zIndex following centralized layer order
      try {
        bg.zIndex = LayerOrder.tiles;
        bgAnim.zIndex = LayerOrder.tilesAnim;
        objBehind.zIndex = LayerOrder.objBehind;
        objFront.zIndex = LayerOrder.objFront;
        playerLayer.zIndex = LayerOrder.player;
        weatherLayer.zIndex = LayerOrder.weather;
        fogLayer.zIndex = LayerOrder.fog;
        liquidLayer.zIndex = LayerOrder.liquids;
        liquidFxLayer.zIndex = LayerOrder.liquidFx;
        projLayer.zIndex = LayerOrder.projectiles;
        overlayLayer.zIndex = LayerOrder.overlay;
      } catch {}
      bgRef.current = bg;
      bgAnimRef.current = bgAnim;
      objBehindRef.current = objBehind;
      objFrontRef.current = objFront;

      // Parallax layer (behind everything)
      const parallaxLayer = new lib/* Container */.mcf();
      try {
        parallaxLayer.zIndex = LayerOrder.parallax;
      } catch {}
      parallaxRef.current = parallaxLayer;
      app.stage.addChild(parallaxLayer);
      // Objects and weather first
      app.stage.addChild(objBehind); // objects behind player
      app.stage.addChild(playerLayer);
      app.stage.addChild(projLayer); // projectiles above player
      app.stage.addChild(objFront); // objects above player
      // Weather renders below fog
      app.stage.addChild(weatherLayer);
      // Fog overlays objects and weather (Variant 1)
      app.stage.addChild(fogLayer);
      // Liquids should be visible like blocks even when fog is enabled  render ABOVE fog
      app.stage.addChild(liquidLayer);
      // Liquid FX (splashes/steam) must appear in front of liquids
      app.stage.addChild(liquidFxLayer);
      // Finally, tiles ("blocks") drawn last so they appear in front of fog (and in front of liquids)
      app.stage.addChild(bg);
      app.stage.addChild(bgAnim); // animated tiles above baked layer
      // Topmost overlay for effects like underwater tint
      app.stage.addChild(overlayLayer);
      weatherLayerRef.current = weatherLayer;
      liquidLayerRef.current = liquidLayer;
      // Assign overlay layer ref BEFORE attaching any custom properties to it
      overlayLayerRef.current = overlayLayer;
      // store FX layer ref
      const liquidFxLayerRefLocal = liquidFxLayer;
      // Save on ref object via a symbol-like property to avoid new ref declaration
      // We'll attach to overlayLayerRef to keep simple access (defensively check ref)
      try {
        if (overlayLayerRef.current) {
          overlayLayerRef.current.__liquidFxLayer = liquidFxLayerRefLocal;
        }
      } catch {}
      fogLayerRef.current = fogLayer;
      projectilesLayerRef.current = projLayer;

      // Preload textures to avoid Assets cache warnings for data URLs and ensure textures are ready
      try {
        const urlSet = new Set();
        const addUrl = u => {
          if (typeof u === 'string' && u.length) urlSet.add(u);
        };
        registryItems.forEach(def => {
          addUrl(def?.texture);
          if (Array.isArray(def?.textures)) def.textures.forEach(addUrl);
        });
        if (playerVisuals) {
          addUrl(playerVisuals.texture);
          if (Array.isArray(playerVisuals.textures)) playerVisuals.textures.forEach(addUrl);
        }
        const bgUrl = resolveBackgroundUrl(backgroundImage);
        if (bgUrl) addUrl(bgUrl);
        const urls = Array.from(urlSet);
        if (urls.length) {
          await lib/* Assets */.sP.load(urls);
        }
      } catch (e) {
        console.warn('Pixi Assets preload encountered an issue (continuing):', e);
      }

      // Create player container with two variants: default and hit (target)
      const playerContainer = new lib/* Container */.mcf();
      playerLayer.addChild(playerContainer);
      const buildSpriteFromDef = def => {
        if (!def) return null;
        let spr = null;
        if (Array.isArray(def.textures) && def.textures.length > 1) {
          const frames = def.textures.map(u => getTexture(u)).filter(Boolean);
          if (frames.length > 0) {
            spr = new lib/* AnimatedSprite */.Dl5(frames);
            spr.animationSpeed = msToSpeed(def.animationSpeed);
            spr.play();
          }
        }
        if (!spr) {
          const tex = getTexture(def.texture) || lib/* Texture */.gPd.WHITE;
          spr = new lib/* Sprite */.kxk(tex);
        }
        spr.anchor.set(0, 0);
        return spr;
      };

      // Default visuals from prop
      const defaultDef = playerVisuals || null;
      // Target visuals: try specific IDs
      const targetDef = Array.isArray(registryItems) ? registryItems.find(r => r.id === 'player_target_100') || registryItems.find(r => r.id === 'player_target') : null;
      const defSprite = buildSpriteFromDef(defaultDef) || new lib/* Sprite */.kxk(lib/* Texture */.gPd.WHITE);
      const hitSprite = buildSpriteFromDef(targetDef) || null;
      playerContainer.addChild(defSprite);
      if (hitSprite) playerContainer.addChild(hitSprite);

      // Health bar above player (reusable component)
      try {
        const hb = new ui_HealthBar({
          width: playerState?.width || tileSize,
          height: 4,
          offsetX: 0,
          offsetY: -5
        });
        playerContainer.addChild(hb); // added last to render on top
        playerHealthBarRef.current = hb;
      } catch {}

      // Initial visibility
      defSprite.visible = true;
      if (hitSprite) hitSprite.visible = false;
      playerRef.current = playerContainer;
      playerSpriteRefs.current = {
        def: defSprite,
        hit: hitSprite
      };

      // Mount canvas
      if (mountRef.current) {
        mountRef.current.innerHTML = '';
        mountRef.current.appendChild(app.canvas);
      }

      // Build underwater overlay graphic (full-screen tint when submerged)
      try {
        const g = new lib/* Graphics */.A1g();
        overlayLayer.addChild(g);
        underwaterRef.current.g = g;
        const redrawOverlay = () => {
          const W = mapWidth * tileSize;
          const H = mapHeight * tileSize;
          g.clear();
          g.beginFill(0x1d4875, 1); // deep blue tint
          g.drawRect(0, 0, W, H);
          g.endFill();
          g.alpha = 0; // initially hidden
          g.visible = false;
        };
        redrawOverlay();
      } catch {}

      // Build overlay bars (health over water, oxygen, lava)
      try {
        const makeBar = colors => new ui_HealthBar({
          width: playerState?.width || tileSize,
          height: 4,
          offsetX: 0,
          offsetY: 0,
          colors
        });
        // Health overlay bar (uses default colors from HealthBar)
        const hbOverlay = new ui_HealthBar({
          width: playerState?.width || tileSize,
          height: 4,
          offsetX: 0,
          offsetY: 0
        });
        hbOverlay.visible = false;
        overlayLayer.addChild(hbOverlay);
        overlayHBRef.current = hbOverlay;
        // Oxygen bar (cyan/blue scheme)
        const oxyColors = {
          ok: 0x2ecdf1,
          warn: 0x3498db,
          danger: 0x1f6fb2
        };
        const oxyBar = makeBar(oxyColors);
        oxyBar.visible = false;
        overlayLayer.addChild(oxyBar);
        oxygenBarRef.current = oxyBar;
        // Lava bar (orange/red scheme)
        const lavaColors = {
          ok: 0xffa229,
          warn: 0xff7b00,
          danger: 0xff3b1a
        };
        const lvBar = makeBar(lavaColors);
        lvBar.visible = false;
        overlayLayer.addChild(lvBar);
        lavaBarRef.current = lvBar;
      } catch {}

      // Handle WebGL context loss/restoration gracefully to avoid crashes
      if (app.canvas) {
        app.canvas.addEventListener('webglcontextlost', e => {
          e.preventDefault(); // allow Pixi to handle restoration
          console.warn('WebGL context was lost. Attempting to restore...');
        });
        app.canvas.addEventListener('webglcontextrestored', () => {
          console.info('WebGL context restored. Rebuilding layers...');
          rebuildLayers();
          rebuildParallax();
          try {
            if (liquidSystemRef.current) liquidSystemRef.current.destroy();
          } catch {}
          try {
            liquidSystemRef.current = new LiquidRegionSystem(liquidLayerRef.current, {
              mapWidth,
              mapHeight,
              tileSize
            });
            liquidSystemRef.current.build({
              mapWidth,
              mapHeight,
              tileSize,
              tileMapData,
              registryItems
            });
          } catch (e) {
            console.warn('LiquidRegionSystem rebuild failed after context restore:', e);
          }
          // Rebuild ember surfaces after context restore
          try {
            if (lavaEmbersRef.current) {
              lavaEmbersRef.current.rebuildSurfaces({
                mapWidth,
                mapHeight,
                tileSize,
                tileMapData,
                registryItems
              });
            }
          } catch {}
        });
      }

      // First draw of map layers
      rebuildLayers();
      // Initialize liquid regions
      try {
        if (liquidSystemRef.current) {
          liquidSystemRef.current.destroy();
        }
        liquidSystemRef.current = new LiquidRegionSystem(liquidLayerRef.current, {
          mapWidth,
          mapHeight,
          tileSize
        });
        liquidSystemRef.current.build({
          mapWidth,
          mapHeight,
          tileSize,
          tileMapData,
          registryItems
        });
      } catch (e) {
        console.warn('LiquidRegionSystem init failed:', e);
      }
      // FX systems
      try {
        // Ensure splashes render IN FRONT of water: parent to liquid FX layer if available
        const fxParent = overlayLayerRef.current?.__liquidFxLayer || liquidLayerRef.current;
        waterFxRef.current = new WaterSplashFX(fxParent);
      } catch {}
      try {
        const fxParent = overlayLayerRef.current?.__liquidFxLayer || liquidLayerRef.current;
        lavaSteamRef.current = new LavaSteamFX(fxParent);
      } catch {}
      try {
        lavaEmbersRef.current = new LavaEmbers(liquidLayerRef.current, {
          mapWidth,
          mapHeight,
          tileSize
        }, () => embersEnabledRef.current ? 100 : 0);
        lavaEmbersRef.current.rebuildSurfaces({
          mapWidth,
          mapHeight,
          tileSize,
          tileMapData,
          registryItems
        });
      } catch {}
      // Build or rebuild parallax background
      rebuildParallax();

      // Update player and parallax each frame
      app.ticker.add(() => {
        const s = playerStateRef.current;
        // Update player sprite if available
        if (s && playerRef.current) {
          const container = playerRef.current;
          const {
            def,
            hit
          } = playerSpriteRefs.current || {};

          // Resize child sprites to match player state
          if (def) {
            if (s.width) def.width = s.width;
            if (s.height) def.height = s.height;
          }
          if (hit) {
            if (s.width) hit.width = s.width;
            if (s.height) hit.height = s.height;
          }

          // Update health bar size and value
          const hb = playerHealthBarRef.current;
          if (hb) {
            const enabled = hbEnabledRef.current !== false;
            const inWater = !!s.inWater;
            const inLava = s.liquidType === 'lava';
            if (!enabled) {
              hb.visible = false;
            } else {
              // When in water or lava, hide the player-attached HB and use overlay version instead
              hb.visible = !(inWater || inLava);
              const effectiveWidth = s.width || def?.width || tileSize;
              hb.resize(effectiveWidth, 4);
              hb.y = -Math.max(4, Math.floor((s.height || def?.height || tileSize) * 0.12)); // small offset above sprite
              hb.update(s.health, Number(s.maxHealth) || 100);
            }
          }

          // Choose which is visible based on hit timer
          const isHit = Number(s.hitTimerMs) > 0 && !!hit;
          if (def) def.visible = !isHit;
          if (hit) hit.visible = isHit;

          // Direction flip is applied to the container
          const dir = s.direction || 1;
          const mag = Math.abs(container.scale.x || 1);
          container.scale.x = dir >= 0 ? mag : -mag;

          // Position container; when flipped, offset by width
          const effectiveWidth = s.width || def?.width || tileSize;
          container.x = dir >= 0 ? s.x || 0 : (s.x || 0) + effectiveWidth;
          container.y = s.y || 0;
        }

        // Update parallax background tile offset based on camera scroll
        const f = parallaxFactorRef.current;
        const camX = cameraScrollRef.current || 0;
        if (parallaxHelperRef.current) {
          parallaxHelperRef.current.setScroll(camX, f);
        }

        // Weather update with delta time
        const dt = app.ticker?.deltaMS || 16.67;
        const systems = weatherSystemsRef.current;
        if (systems.rain) systems.rain.update(dt);
        if (systems.snow) systems.snow.update(dt);
        if (systems.clouds) systems.clouds.update(dt);
        if (systems.fog) systems.fog.update(dt);
        if (systems.thunder) systems.thunder.update(dt);
        // Liquids region update
        try {
          liquidSystemRef.current?.update(dt);
        } catch {}

        // FX systems update
        try {
          lavaEmbersRef.current?.update(dt);
        } catch {}
        try {
          waterFxRef.current?.update(dt);
        } catch {}
        try {
          lavaSteamRef.current?.update(dt);
        } catch {}

        // Underwater overlay animation (only for water) and water splash triggers
        try {
          const u = underwaterRef.current;
          const sNow = playerStateRef.current || {};
          if (u && u.g) {
            const submerged = !!(sNow && sNow.headUnderWater && sNow.liquidType === 'water');
            if (submerged) {
              u.time += dt;
              const pulse = 0.12 + 0.06 * Math.sin(u.time * 0.0025);
              u.g.visible = true;
              u.g.alpha = pulse; // subtle
            } else if (u.g.visible) {
              // fade out quickly
              u.g.alpha *= 0.85;
              if (u.g.alpha < 0.01) {
                u.g.alpha = 0;
                u.g.visible = false;
              }
            }
          }
          // Splash detection: transitions air<->water
          try {
            const prev = waterStateRef.current || {
              inWater: false,
              headUnder: false,
              vy: 0
            };
            const nowInWater = !!sNow.inWater;
            const nowLiquid = sNow.liquidType;
            const centerX = (sNow.x || 0) + (sNow.width || tileSize) * 0.5;
            // Enter water
            if (splashesEnabledRef.current && nowLiquid === 'water' && nowInWater && !prev.inWater) {
              const sy = liquidSystemRef.current?.getSurfaceY?.('water', centerX);
              const vy = Number(sNow.vy) || 0;
              const strength = Math.min(3, Math.max(0.2, Math.abs(vy) * 0.12));
              waterFxRef.current?.trigger({
                x: centerX,
                y: Number.isFinite(sy) ? sy : sNow.y || 0,
                strength,
                upward: false
              });
              // Kick water surface ripple (larger on fast entry)
              try {
                liquidSystemRef.current?.addWave?.('water', centerX, Math.min(2.5, 0.6 + Math.abs(vy) * 0.08));
              } catch {}
            }
            // Exit water
            if (splashesEnabledRef.current && prev.inWater && !nowInWater) {
              const sy = liquidSystemRef.current?.getSurfaceY?.('water', centerX);
              const vy = Number(sNow.vy) || 0;
              const strength = Math.min(3, Math.max(0.2, Math.abs(vy) * 0.08));
              waterFxRef.current?.trigger({
                x: centerX,
                y: Number.isFinite(sy) ? sy : sNow.y || 0,
                strength,
                upward: true
              });
              // Smaller ripple on exit
              try {
                liquidSystemRef.current?.addWave?.('water', centerX, Math.min(2.0, 0.4 + Math.abs(vy) * 0.05));
              } catch {}
            }
            waterStateRef.current = {
              inWater: nowInWater,
              headUnder: !!sNow.headUnderWater,
              vy: Number(sNow.vy) || 0
            };
          } catch {}
        } catch {}

        // Overlay bars update/positioning
        try {
          const s2 = playerStateRef.current || {};
          const effW = s2.width || tileSize;
          const effH = s2.height || tileSize;
          // Compute anchor top Y above player
          const baseYOffset = Math.max(4, Math.floor(effH * 0.12));
          const baseX = s2.x || 0;
          const baseY = (s2.y || 0) - baseYOffset;

          // Overlay health when in water or lava
          const hbO = overlayHBRef.current;
          if (hbO) {
            const enabled = hbEnabledRef.current !== false;
            const show = enabled && (!!s2.inWater || s2.liquidType === 'lava');
            hbO.visible = !!show;
            if (show) {
              hbO.x = baseX;
              hbO.y = baseY;
              hbO.resize(effW, 4);
              hbO.update(s2.health, Number(s2.maxHealth) || 100);
            }
          }

          // Compute stacking Y for additional bars
          let nextBarY = baseY;
          if (hbO && hbO.visible) nextBarY += 6;

          // Oxygen bar when in water OR when oxygen hasn't refilled to max yet
          const oxyBar = oxygenBarRef.current;
          if (oxyBar) {
            const enabled = oxyEnabledRef.current !== false;
            const maxOxy = Math.max(1, Number(s2.maxOxygen) || 100);
            const curOxy = Math.max(0, Number(s2.oxygen));
            const show = enabled && (s2.liquidType === 'water' || s2.inWater || curOxy < maxOxy);
            oxyBar.visible = !!show;
            if (show) {
              oxyBar.x = baseX;
              oxyBar.y = nextBarY;
              oxyBar.resize(effW, 4);
              oxyBar.update(Number.isFinite(curOxy) ? curOxy : maxOxy, maxOxy);
              nextBarY += 6;
            }
          }

          // Lava bar when in lava OR when lavaResist hasn't refilled to max yet
          const lvBar = lavaBarRef.current;
          if (lvBar) {
            const enabled = lavaEnabledRef.current !== false;
            const maxLv = Math.max(1, Number(s2.maxLavaResist) || 100);
            const curLv = Math.max(0, Number(s2.lavaResist));
            const show = enabled && (s2.liquidType === 'lava' || curLv < maxLv);
            lvBar.visible = !!show;
            if (show) {
              lvBar.x = baseX;
              lvBar.y = nextBarY;
              lvBar.resize(effW, 4);
              lvBar.update(Number.isFinite(curLv) ? curLv : maxLv, maxLv);
            }
          }
        } catch {}

        // Projectiles sync/update: create missing sprites, remove stale, update positions
        const layer = projectilesLayerRef.current;
        if (layer) {
          const map = projectileSpritesRef.current;
          const list = projectilesPropRef.current || [];
          const seen = new Set();
          for (let i = 0; i < list.length; i++) {
            const p = list[i];
            const key = p.id;
            seen.add(key);
            let spr = map.get(key);
            if (!spr) {
              const def = getRegItem(p.defId);
              if (def && Array.isArray(def.textures) && def.textures.length > 1) {
                const frames = def.textures.map(u => getTexture(u)).filter(Boolean);
                if (frames.length > 0) {
                  spr = new lib/* AnimatedSprite */.Dl5(frames);
                  spr.animationSpeed = msToSpeed(def.animationSpeed);
                  spr.play();
                }
              }
              if (!spr) {
                const tex = getTexture(getRegItem(p.defId)?.texture) || lib/* Texture */.gPd.WHITE;
                spr = new lib/* Sprite */.kxk(tex);
              }
              spr.anchor.set(0.5, 0.5);
              spr.width = Math.max(2, p.w || tileSize * 0.25);
              spr.height = Math.max(2, p.h || tileSize * 0.25);
              layer.addChild(spr);
              map.set(key, spr);
            }
            spr.x = p.x + (p.dir >= 0 ? 0 : 0);
            spr.y = p.y;
            const mag = Math.abs(spr.scale.x || 1);
            spr.scale.x = p.dir >= 0 ? mag : -mag;
          }
          // remove sprites that no longer exist
          for (const [key, spr] of map.entries()) {
            if (!seen.has(key)) {
              try {
                spr.parent && spr.parent.removeChild(spr);
              } catch {}
              try {
                spr.destroy && spr.destroy();
              } catch {}
              map.delete(key);
            }
          }
        }
      });
    };
    const rebuildLayers = () => {
      const app = appRef.current;
      if (!app || !bgRef.current || !objBehindRef.current || !objFrontRef.current) return;

      // Clear previous
      bgRef.current.removeChildren();
      objBehindRef.current.removeChildren();
      objFrontRef.current.removeChildren();

      // Helper: resolve registry item by id
      const getDef = id => registryItems.find(r => r.id === id);
      const isWaterDef = def => !!(def && def.flags && def.flags.water);
      const isLavaDef = def => !!(def && def.flags && def.flags.lava);

      // Generate procedural water frames (cached per tile size)
      const getWaterFrames = () => {
        if (waterFramesRef.current && waterFramesRef.current.size === tileSize) return waterFramesRef.current.frames;
        const frames = [];
        const F = 8; // frame count
        for (let i = 0; i < F; i++) {
          const canvas = document.createElement('canvas');
          canvas.width = tileSize;
          canvas.height = tileSize;
          const ctx = canvas.getContext('2d');
          // background gradient
          const g = ctx.createLinearGradient(0, 0, 0, tileSize);
          g.addColorStop(0, '#2a5d8f');
          g.addColorStop(1, '#174369');
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, tileSize, tileSize);
          // animated ripples via sine stripes
          ctx.globalAlpha = 0.25;
          ctx.fillStyle = '#8fc0ff';
          const t = i / F;
          const bands = 3;
          for (let b = 0; b < bands; b++) {
            const y = Math.floor(tileSize / bands * b + tileSize / bands * 0.5 + Math.sin((t + b * 0.33) * Math.PI * 2) * (tileSize * 0.08));
            ctx.fillRect(0, y, tileSize, Math.max(1, Math.floor(tileSize * 0.06)));
          }
          // soft top highlight
          ctx.globalAlpha = 0.18;
          ctx.fillStyle = '#c9ecff';
          ctx.fillRect(0, 0, tileSize, Math.max(1, Math.floor(tileSize * 0.12)));
          const tex = lib/* Texture */.gPd.from(canvas);
          frames.push(tex);
        }
        waterFramesRef.current = {
          size: tileSize,
          frames
        };
        return frames;
      };

      // Generate procedural lava frames (cached per tile size)
      const getLavaFrames = () => {
        if (lavaFramesRef.current && lavaFramesRef.current.size === tileSize) return lavaFramesRef.current.frames;
        const frames = [];
        const F = 8;
        for (let i = 0; i < F; i++) {
          const canvas = document.createElement('canvas');
          canvas.width = tileSize;
          canvas.height = tileSize;
          const ctx = canvas.getContext('2d');
          // base gradient (dark red to orange)
          const g = ctx.createLinearGradient(0, 0, 0, tileSize);
          g.addColorStop(0, '#6b1a07');
          g.addColorStop(1, '#c43f0f');
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, tileSize, tileSize);
          // glowing veins
          const t = i / F;
          ctx.globalAlpha = 0.3;
          for (let b = 0; b < 3; b++) {
            const y = Math.floor(tileSize / 3 * b + tileSize / 3 * 0.5 + Math.sin((t * 2 + b * 0.6) * Math.PI * 2) * (tileSize * 0.1));
            const h = Math.max(1, Math.floor(tileSize * 0.07));
            const grad = ctx.createLinearGradient(0, y, 0, y + h);
            grad.addColorStop(0, '#ffed8a');
            grad.addColorStop(1, '#ff7b00');
            ctx.fillStyle = grad;
            ctx.fillRect(0, y, tileSize, h);
          }
          // bubbles/dots
          ctx.globalAlpha = 0.25;
          ctx.fillStyle = '#ffd36e';
          const count = Math.max(2, Math.floor(tileSize * 0.12));
          for (let k = 0; k < count; k++) {
            const rx = Math.floor((k * 37 + i * 13) % tileSize);
            const ry = Math.floor((k * 53 + i * 29) % tileSize);
            ctx.fillRect(rx, ry, 1, 1);
          }
          const tex = lib/* Texture */.gPd.from(canvas);
          frames.push(tex);
        }
        lavaFramesRef.current = {
          size: tileSize,
          frames
        };
        return frames;
      };

      // Background tiles (skip liquids here; they will be rendered by LiquidRegionSystem)
      for (let i = 0; i < mapWidth * mapHeight; i++) {
        const id = tileMapData[i];
        if (!id) continue;
        const def = getRegItem(id);
        if (!def) continue;
        let sprite;
        let frames = null;
        if (isWaterDef(def) || isLavaDef(def)) {
          // liquids are handled by LiquidRegionSystem; skip per-tile sprite
          continue;
        } else {
          if (Array.isArray(def.textures) && def.textures.length > 1) {
            frames = def.textures.map(u => getTexture(u)).filter(Boolean);
          }
          if (frames && frames.length > 0) {
            sprite = new lib/* AnimatedSprite */.Dl5(frames);
            sprite.animationSpeed = msToSpeed(def.animationSpeed);
            sprite.play();
          } else {
            const tex = getTexture(def.texture) || null;
            if (!tex) continue;
            sprite = new lib/* Sprite */.kxk(tex);
          }
        }
        const x = i % mapWidth * tileSize;
        const y = Math.floor(i / mapWidth) * tileSize;
        sprite.x = x;
        sprite.y = y;
        sprite.width = tileSize;
        sprite.height = tileSize;
        bgRef.current.addChild(sprite);
      }

      // Objects (non-player)
      for (let i = 0; i < mapWidth * mapHeight; i++) {
        const id = objectMapData[i];
        if (!id || id.includes('player')) continue;
        const def = getRegItem(id);
        if (!def) continue;
        let sprite;
        let frames = null;
        if (Array.isArray(def.textures) && def.textures.length > 1) {
          frames = def.textures.map(u => getTexture(u)).filter(Boolean);
        }
        if (frames && frames.length > 0) {
          sprite = new lib/* AnimatedSprite */.Dl5(frames);
          sprite.animationSpeed = msToSpeed(def.animationSpeed);
          sprite.play();
        } else {
          const tex = getTexture(def.texture) || null;
          if (!tex) continue;
          sprite = new lib/* Sprite */.kxk(tex);
        }
        const x = i % mapWidth * tileSize;
        const y = Math.floor(i / mapWidth) * tileSize;
        sprite.x = x;
        sprite.y = y;
        sprite.width = tileSize;
        sprite.height = tileSize;
        const renderAbove = !!def.renderAbovePlayer;
        if (renderAbove) {
          objFrontRef.current.addChild(sprite);
        } else {
          objBehindRef.current.addChild(sprite);
        }
      }
    };
    init();
    return () => {
      destroyed = true;
      if (appRef.current) {
        appRef.current.destroy(true);
        appRef.current = null;
      }
      // Destroy liquid system
      try {
        liquidSystemRef.current?.destroy();
      } catch {}
      liquidSystemRef.current = null;
      // Destroy FX systems
      try {
        waterFxRef.current?.destroy();
      } catch {}
      waterFxRef.current = null;
      try {
        lavaEmbersRef.current?.destroy();
      } catch {}
      lavaEmbersRef.current = null;
      try {
        lavaSteamRef.current?.destroy();
      } catch {}
      lavaSteamRef.current = null;
      // Destroy parallax helper and texture cache (releasing references only)
      try {
        parallaxHelperRef.current?.destroy();
      } catch {}
      parallaxHelperRef.current = null;
      try {
        pixiTextureCacheRef.current?.clear?.();
      } catch {}
      pixiTextureCacheRef.current = null;
      // Destroy weather systems
      try {
        weatherSystemsRef.current.rain?.destroy();
        weatherSystemsRef.current.snow?.destroy();
        weatherSystemsRef.current.fog?.destroy();
      } catch {}
      // destroy projectile sprites
      try {
        const map = projectileSpritesRef.current;
        for (const spr of map.values()) {
          try {
            spr.parent && spr.parent.removeChild(spr);
          } catch {}
          try {
            spr.destroy && spr.destroy();
          } catch {}
        }
        projectileSpritesRef.current.clear();
      } catch {}
      textureCacheRef.current.forEach(t => t.destroy && t.destroy(true));
      textureCacheRef.current.clear();
    };

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [mapWidth, mapHeight, tileSize, playerVisuals]);

  // Rebuild layers when map data changes
  (0,react.useEffect)(() => {
    const app = appRef.current;
    if (!app) return;
    // Rebuild background and object layers
    if (bgRef.current && objBehindRef.current && objFrontRef.current) {
      // Simple approach: full rebuild
      // Background
      bgRef.current.removeChildren();
      // Helpers for liquid rendering
      const isWaterDef = def => !!(def && def.flags && def.flags.water);
      const isLavaDef = def => !!(def && def.flags && def.flags.lava);
      const getWaterFrames = () => {
        if (waterFramesRef.current && waterFramesRef.current.size === tileSize) return waterFramesRef.current.frames;
        const frames = [];
        const F = 8;
        for (let i = 0; i < F; i++) {
          const canvas = document.createElement('canvas');
          canvas.width = tileSize;
          canvas.height = tileSize;
          const ctx = canvas.getContext('2d');
          const g = ctx.createLinearGradient(0, 0, 0, tileSize);
          g.addColorStop(0, '#2a5d8f');
          g.addColorStop(1, '#174369');
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, tileSize, tileSize);
          ctx.globalAlpha = 0.25;
          ctx.fillStyle = '#8fc0ff';
          const t = i / F;
          const bands = 3;
          for (let b = 0; b < bands; b++) {
            const yb = Math.floor(tileSize / bands * b + tileSize / bands * 0.5 + Math.sin((t + b * 0.33) * Math.PI * 2) * (tileSize * 0.08));
            ctx.fillRect(0, yb, tileSize, Math.max(1, Math.floor(tileSize * 0.06)));
          }
          ctx.globalAlpha = 0.18;
          ctx.fillStyle = '#c9ecff';
          ctx.fillRect(0, 0, tileSize, Math.max(1, Math.floor(tileSize * 0.12)));
          const tex = lib/* Texture */.gPd.from(canvas);
          frames.push(tex);
        }
        waterFramesRef.current = {
          size: tileSize,
          frames
        };
        return frames;
      };
      const getLavaFrames = () => {
        if (lavaFramesRef.current && lavaFramesRef.current.size === tileSize) return lavaFramesRef.current.frames;
        const frames = [];
        const F = 8;
        for (let i = 0; i < F; i++) {
          const canvas = document.createElement('canvas');
          canvas.width = tileSize;
          canvas.height = tileSize;
          const ctx = canvas.getContext('2d');
          const g = ctx.createLinearGradient(0, 0, 0, tileSize);
          g.addColorStop(0, '#6b1a07');
          g.addColorStop(1, '#c43f0f');
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, tileSize, tileSize);
          const t = i / F;
          ctx.globalAlpha = 0.3;
          for (let b = 0; b < 3; b++) {
            const yb = Math.floor(tileSize / 3 * b + tileSize / 3 * 0.5 + Math.sin((t * 2 + b * 0.6) * Math.PI * 2) * (tileSize * 0.1));
            const h = Math.max(1, Math.floor(tileSize * 0.07));
            const grad = ctx.createLinearGradient(0, yb, 0, yb + h);
            grad.addColorStop(0, '#ffed8a');
            grad.addColorStop(1, '#ff7b00');
            ctx.fillStyle = grad;
            ctx.fillRect(0, yb, tileSize, h);
          }
          ctx.globalAlpha = 0.25;
          ctx.fillStyle = '#ffd36e';
          const count = Math.max(2, Math.floor(tileSize * 0.12));
          for (let k = 0; k < count; k++) {
            const rx = Math.floor((k * 37 + i * 13) % tileSize);
            const ry = Math.floor((k * 53 + i * 29) % tileSize);
            ctx.fillRect(rx, ry, 1, 1);
          }
          const tex = lib/* Texture */.gPd.from(canvas);
          frames.push(tex);
        }
        lavaFramesRef.current = {
          size: tileSize,
          frames
        };
        return frames;
      };

      // Background tiles (skip liquids; handled by LiquidRegionSystem)
      for (let i = 0; i < mapWidth * mapHeight; i++) {
        const id = tileMapData[i];
        if (!id) continue;
        const def = registryItems.find(r => r.id === id);
        if (!def) continue;
        if (isWaterDef(def) || isLavaDef(def)) continue;
        let sprite;
        let frames = null;
        if (Array.isArray(def.textures) && def.textures.length > 1) {
          frames = def.textures.map(u => getTexture(u)).filter(Boolean);
        }
        if (frames && frames.length > 0) {
          sprite = new lib/* AnimatedSprite */.Dl5(frames);
          sprite.animationSpeed = msToSpeed(def.animationSpeed);
          sprite.play();
        } else {
          const tex = getTexture(def.texture) || null;
          if (!tex) continue;
          sprite = new lib/* Sprite */.kxk(tex);
        }
        const x = i % mapWidth * tileSize;
        const y = Math.floor(i / mapWidth) * tileSize;
        sprite.x = x;
        sprite.y = y;
        sprite.width = tileSize;
        sprite.height = tileSize;
        bgRef.current.addChild(sprite);
      }

      // Rebuild liquid regions for new tile data
      try {
        if (liquidSystemRef.current) {
          liquidSystemRef.current.destroy();
        }
        if (liquidLayerRef.current) {
          liquidSystemRef.current = new LiquidRegionSystem(liquidLayerRef.current, {
            mapWidth,
            mapHeight,
            tileSize
          });
          liquidSystemRef.current.build({
            mapWidth,
            mapHeight,
            tileSize,
            tileMapData,
            registryItems
          });
        }
      } catch (e) {
        console.warn('LiquidRegionSystem rebuild failed (map data change):', e);
      }
      // Rebuild ember surfaces on map change
      try {
        lavaEmbersRef.current?.rebuildSurfaces({
          mapWidth,
          mapHeight,
          tileSize,
          tileMapData,
          registryItems
        });
      } catch {}

      // Objects
      objBehindRef.current.removeChildren();
      objFrontRef.current.removeChildren();
      for (let i = 0; i < mapWidth * mapHeight; i++) {
        const id = objectMapData[i];
        if (!id || id.includes('player')) continue;
        const def = registryItems.find(r => r.id === id);
        if (!def) continue;
        let sprite;
        let frames = null;
        if (Array.isArray(def.textures) && def.textures.length > 1) {
          frames = def.textures.map(u => getTexture(u)).filter(Boolean);
        }
        if (frames && frames.length > 0) {
          sprite = new lib/* AnimatedSprite */.Dl5(frames);
          sprite.animationSpeed = msToSpeed(def.animationSpeed);
          // Check if this object has a specific texture index override
          const textureIndex = objectTextureIndices[i];
          if (typeof textureIndex === 'number' && textureIndex >= 0 && textureIndex < frames.length) {
            sprite.gotoAndStop(textureIndex); // Show specific frame (e.g., used berry bush)
          } else {
            sprite.play(); // Normal animation
          }
        } else {
          const tex = getTexture(def.texture) || null;
          if (!tex) continue;
          sprite = new lib/* Sprite */.kxk(tex);
        }
        const x = i % mapWidth * tileSize;
        const y = Math.floor(i / mapWidth) * tileSize;
        sprite.x = x;
        sprite.y = y;
        sprite.width = tileSize;
        sprite.height = tileSize;
        const renderAbove = !!def.renderAbovePlayer;
        if (renderAbove) {
          objFrontRef.current.addChild(sprite);
        } else {
          objBehindRef.current.addChild(sprite);
        }
      }
    }
  }, [tileMapData, objectMapData, objectTextureIndices, registryItems, mapWidth, mapHeight, tileSize]);

  // Weather systems lifecycle and intensity updates
  (0,react.useEffect)(() => {
    const app = appRef.current;
    const weatherLayer = weatherLayerRef.current;
    const fogLayer = fogLayerRef.current;
    if (!app || !weatherLayer || !fogLayer) return;
    const api = {
      isSolidAt,
      mapWidth,
      mapHeight,
      tileSize,
      // Liquids surface queries for weather interactions
      getLiquidSurfaceY: (type, x) => {
        try {
          return liquidSystemRef.current?.getSurfaceY?.(type, x);
        } catch {
          return null;
        }
      },
      // FX hooks for water/lava impacts from weather
      onWaterImpact: ({
        x,
        strength = 0.8
      }) => {
        try {
          const sy = liquidSystemRef.current?.getSurfaceY?.('water', x);
          if (Number.isFinite(sy)) waterFxRef.current?.trigger({
            x,
            y: sy,
            strength: Math.max(0.2, Math.min(2, strength)),
            upward: false
          });
          // Also deform water surface with ripples
          try {
            liquidSystemRef.current?.addWave?.('water', x, Math.max(0.2, Math.min(2.2, strength)));
          } catch {}
        } catch {}
      },
      onLavaImpact: ({
        x,
        y,
        strength = 0.6
      }) => {
        try {
          const sy = liquidSystemRef.current?.getSurfaceY?.('lava', x);
          const yy = Number.isFinite(y) ? y : Number.isFinite(sy) ? sy : null;
          if (yy != null) lavaSteamRef.current?.trigger({
            x,
            y: yy,
            strength
          });
        } catch {}
      }
    };
    const getRainIntensity = () => Math.max(0, Math.min(100, Number(weatherRain) || 0));
    const getSnowIntensity = () => Math.max(0, Math.min(100, Number(weatherSnow) || 0));
    const getCloudsIntensity = () => Math.max(0, Math.min(100, Number(weatherClouds) || 0));
    const getThunderIntensity = () => Math.max(0, Math.min(100, Number(weatherThunder) || 0));

    // Always reset systems to apply possible dimension changes cleanly
    try {
      weatherSystemsRef.current.rain?.destroy();
    } catch {}
    try {
      weatherSystemsRef.current.snow?.destroy();
    } catch {}
    try {
      weatherSystemsRef.current.clouds?.destroy();
    } catch {}
    try {
      weatherSystemsRef.current.fog?.destroy();
    } catch {}
    try {
      weatherSystemsRef.current.thunder?.destroy();
    } catch {}
    weatherSystemsRef.current.rain = null;
    weatherSystemsRef.current.snow = null;
    weatherSystemsRef.current.clouds = null;
    weatherSystemsRef.current.fog = null;
    weatherSystemsRef.current.thunder = null;

    // Rain
    if (getRainIntensity() > 0) {
      if (!weatherSystemsRef.current.rain) {
        weatherSystemsRef.current.rain = new WeatherRain(weatherLayer, api, getRainIntensity);
      }
      weatherSystemsRef.current.rain.setIntensity(getRainIntensity());
    } else {
      weatherSystemsRef.current.rain?.destroy();
      weatherSystemsRef.current.rain = null;
    }

    // Snow
    if (getSnowIntensity() > 0) {
      if (!weatherSystemsRef.current.snow) {
        weatherSystemsRef.current.snow = new WeatherSnow(weatherLayer, api, getSnowIntensity);
      }
      weatherSystemsRef.current.snow.setIntensity(getSnowIntensity());
    } else {
      weatherSystemsRef.current.snow?.destroy();
      weatherSystemsRef.current.snow = null;
    }

    // Clouds
    if (getCloudsIntensity() > 0) {
      if (!weatherSystemsRef.current.clouds) {
        weatherSystemsRef.current.clouds = new WeatherClouds(fogLayer, api, getCloudsIntensity);
      }
      weatherSystemsRef.current.clouds.setIntensity(getCloudsIntensity());
    } else {
      weatherSystemsRef.current.clouds?.destroy();
      weatherSystemsRef.current.clouds = null;
    }

    // Full-screen Fog overlay (affects entire screen)
    const getFogIntensity = () => Math.max(0, Math.min(100, Number(weatherFog) || 0));
    if (getFogIntensity() > 0) {
      if (!weatherSystemsRef.current.fog) {
        weatherSystemsRef.current.fog = new WeatherFog(fogLayer, api, getFogIntensity);
      }
      weatherSystemsRef.current.fog.setIntensity(getFogIntensity());
      // ensure fog overlay covers full current canvas size
      try {
        weatherSystemsRef.current.fog.resize(mapWidth * tileSize, mapHeight * tileSize);
      } catch {}
    } else {
      weatherSystemsRef.current.fog?.setIntensity(0);
    }

    // Thunder/Lightning (in weather layer, below fog)
    if (getThunderIntensity() > 0) {
      if (!weatherSystemsRef.current.thunder) {
        weatherSystemsRef.current.thunder = new WeatherThunder(weatherLayer, api, getThunderIntensity);
      }
      weatherSystemsRef.current.thunder.setIntensity(getThunderIntensity());
      try {
        weatherSystemsRef.current.thunder.resize(mapWidth * tileSize, mapHeight * tileSize);
      } catch {}
    } else {
      // We keep instance if present but set intensity to 0 or destroy? To free resources, destroy.
      try {
        weatherSystemsRef.current.thunder?.destroy();
      } catch {}
      weatherSystemsRef.current.thunder = null;
    }
  }, [weatherRain, weatherSnow, weatherClouds, weatherFog, weatherThunder, mapWidth, mapHeight, tileSize, tileMapData]);

  // Rebuild parallax when props change
  (0,react.useEffect)(() => {
    const app = appRef.current;
    if (!app) return;
    rebuildParallax();
  }, [backgroundImage, backgroundColor, backgroundParallaxFactor, mapWidth, mapHeight, tileSize]);

  // Resize application when map size changes
  (0,react.useEffect)(() => {
    const app = appRef.current;
    if (!app) return;
    app.renderer.resize(mapWidth * tileSize, mapHeight * tileSize);
    // Resize parallax background
    if (parallaxHelperRef.current) {
      parallaxHelperRef.current.resize(mapWidth * tileSize, mapHeight * tileSize);
    }
    // Resize fog overlay to match new world size
    try {
      weatherSystemsRef.current.fog?.resize(mapWidth * tileSize, mapHeight * tileSize);
    } catch {}
    try {
      weatherSystemsRef.current.thunder?.resize(mapWidth * tileSize, mapHeight * tileSize);
    } catch {}
    // FX resize (no-op for current implementations)
    try {
      waterFxRef.current?.resize(mapWidth * tileSize, mapHeight * tileSize);
    } catch {}
    try {
      lavaEmbersRef.current?.resize(mapWidth * tileSize, mapHeight * tileSize);
    } catch {}
    // Resize underwater overlay
    try {
      const g = underwaterRef.current?.g;
      if (g) {
        g.clear();
        g.beginFill(0x1d4875, 1);
        g.drawRect(0, 0, mapWidth * tileSize, mapHeight * tileSize);
        g.endFill();
        g.alpha = 0;
        g.visible = false;
      }
    } catch {}
  }, [mapWidth, mapHeight, tileSize]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    ref: mountRef,
    style: {
      width: mapWidth * tileSize,
      height: mapHeight * tileSize
    }
  });
};
PixiStage.propTypes = {
  mapWidth: (prop_types_default()).number.isRequired,
  mapHeight: (prop_types_default()).number.isRequired,
  tileSize: (prop_types_default()).number,
  tileMapData: (prop_types_default()).array,
  objectMapData: (prop_types_default()).array,
  registryItems: (prop_types_default()).array,
  playerState: prop_types_default().shape({
    x: (prop_types_default()).number,
    y: (prop_types_default()).number,
    direction: (prop_types_default()).number,
    animation: (prop_types_default()).string,
    health: (prop_types_default()).number,
    width: (prop_types_default()).number,
    height: (prop_types_default()).number,
    projectiles: (prop_types_default()).array
  }),
  playerVisuals: (prop_types_default()).object,
  backgroundImage: (prop_types_default()).string,
  backgroundColor: (prop_types_default()).string,
  backgroundParallaxFactor: (prop_types_default()).number,
  cameraScrollX: (prop_types_default()).number,
  shouldCenter: (prop_types_default()).bool,
  runtimeSettings: (prop_types_default()).object
};
/* harmony default export */ const chapters_PixiStage = (PixiStage);
;// ./src/utilities/useInput.js

const useInput = () => {
  const keys = (0,react.useRef)({
    w: false,
    a: false,
    s: false,
    d: false,
    space: false,
    mouseLeft: false
  });
  (0,react.useEffect)(() => {
    const isTerminalOpen = () => {
      try {
        return !!window.__GAME_TERMINAL_OPEN__;
      } catch {
        return false;
      }
    };
    const clearKeys = () => {
      keys.current.w = false;
      keys.current.a = false;
      keys.current.s = false;
      keys.current.d = false;
      keys.current.space = false;
      keys.current.mouseLeft = false;
    };
    const handleKeyDown = e => {
      // Do not toggle when typing into inputs/textareas/contenteditable
      const tag = e.target && e.target.tagName ? e.target.tagName.toUpperCase() : '';
      const typing = tag === 'INPUT' || tag === 'TEXTAREA' || e.target && e.target.isContentEditable;

      // Toggle in-game terminal with 'T'
      if (!typing && e.code === 'KeyT' && !e.repeat) {
        try {
          window.dispatchEvent(new CustomEvent('game-toggle-terminal'));
        } catch {}
        clearKeys();
        // prevent game movement while toggling
        if (typeof e.preventDefault === 'function') e.preventDefault();
        return;
      }

      // Prevent browser scrolling / focus hijack for game controls only when NOT typing and terminal is closed
      if (!typing && !isTerminalOpen()) {
        switch (e.code) {
          case 'KeyW':
          case 'ArrowUp':
          case 'KeyA':
          case 'ArrowLeft':
          case 'KeyS':
          case 'ArrowDown':
          case 'KeyD':
          case 'ArrowRight':
          case 'Space':
            if (typeof e.preventDefault === 'function') e.preventDefault();
            break;
          default:
            break;
        }
      }

      // If terminal is open, ignore gameplay inputs so player doesn't move while typing
      if (isTerminalOpen()) return;
      switch (e.code) {
        case 'KeyW':
        case 'ArrowUp':
          keys.current.w = true;
          break;
        case 'KeyA':
        case 'ArrowLeft':
          keys.current.a = true;
          break;
        case 'KeyS':
        case 'ArrowDown':
          keys.current.s = true;
          break;
        case 'KeyD':
        case 'ArrowRight':
          keys.current.d = true;
          break;
        case 'Space':
          keys.current.space = true;
          break;
        default:
          break;
      }
    };
    const handleMouseDown = e => {
      // Left button only
      if (e.button !== 0) return;
      if (isTerminalOpen()) return;
      keys.current.mouseLeft = true;
    };
    const handleMouseUp = e => {
      if (e.button !== 0) return;
      if (isTerminalOpen()) return;
      keys.current.mouseLeft = false;
    };
    const handleKeyUp = e => {
      // Allow closing terminal with Escape (terminal component also handles it)
      if (e.code === 'Escape') return;
      if (isTerminalOpen()) {
        // When terminal is open, we do not change gameplay key states here
        return;
      }
      switch (e.code) {
        case 'KeyW':
        case 'ArrowUp':
          keys.current.w = false;
          break;
        case 'KeyA':
        case 'ArrowLeft':
          keys.current.a = false;
          break;
        case 'KeyS':
        case 'ArrowDown':
          keys.current.s = false;
          break;
        case 'KeyD':
        case 'ArrowRight':
          keys.current.d = false;
          break;
        case 'Space':
          keys.current.space = false;
          break;
        default:
          break;
      }
    };
    const onToggleTerminal = () => clearKeys();

    // non-passive to allow preventDefault on Space/Arrow keys
    window.addEventListener('keydown', handleKeyDown, {
      passive: false
    });
    window.addEventListener('keyup', handleKeyUp, {
      passive: false
    });
    window.addEventListener('game-toggle-terminal', onToggleTerminal);
    window.addEventListener('mousedown', handleMouseDown, {
      passive: true
    });
    window.addEventListener('mouseup', handleMouseUp, {
      passive: true
    });
    return () => {
      window.removeEventListener('keydown', handleKeyDown, {
        passive: false
      });
      window.removeEventListener('keyup', handleKeyUp, {
        passive: false
      });
      window.removeEventListener('game-toggle-terminal', onToggleTerminal);
      window.removeEventListener('mousedown', handleMouseDown, {
        passive: true
      });
      window.removeEventListener('mouseup', handleMouseUp, {
        passive: true
      });
    };
  }, []);
  return keys;
};
;// ./src/engine/gameplay/hazards.js
// Hazard damage calculation (migrated from GameEngine/checkHazardDamage.js)

function checkHazardDamage({
  currentX,
  currentY,
  mapWidth,
  objectLayerData,
  deltaMs,
  registryItems,
  TILE_SIZE,
  MOVE_SPEED,
  JUMP_FORCE,
  hazardDamageAccumulatorRef,
  lastHazardIndexRef,
  triggeredHazardsRef,
  gameState
}) {
  if (!objectLayerData) {
    hazardDamageAccumulatorRef.current = 0;
    lastHazardIndexRef.current = null;
    return;
  }
  const width = gameState.current.width;
  const height = gameState.current.height;

  // Player AABB in world pixels
  const playerLeft = currentX;
  const playerRight = currentX + width;
  const playerTop = currentY;
  const playerBottom = currentY + height;

  // Overlapped tile rectangle (inclusive)
  const minGX = Math.floor(playerLeft / TILE_SIZE);
  const maxGX = Math.floor((playerRight - 1) / TILE_SIZE);
  const minGY = Math.floor(playerTop / TILE_SIZE);
  const maxGY = Math.floor((playerBottom - 1) / TILE_SIZE);

  // Collect candidate hazards that match direction rules
  const candidates = [];
  const pushCandidate = (idx, def, touch) => {
    const dirs = def.damageDirections || {
      top: true,
      bottom: true,
      left: true,
      right: true
    };
    const ok = touch.top && dirs.top || touch.bottom && dirs.bottom || touch.left && dirs.left || touch.right && dirs.right;
    if (!ok) return;
    candidates.push({
      index: idx,
      def,
      touch
    });
  };
  for (let gy = minGY; gy <= maxGY; gy++) {
    for (let gx = minGX; gx <= maxGX; gx++) {
      const idx = gy * mapWidth + gx;
      if (idx < 0 || idx >= objectLayerData.length) continue;
      const objId = objectLayerData[idx];
      if (!objId) continue;
      const def = registryItems.find(r => r.id === objId);
      if (!def || def.type !== 'hazard') continue;
      const tileLeft = gx * TILE_SIZE;
      const tileRight = tileLeft + TILE_SIZE;
      const tileTop = gy * TILE_SIZE;
      const tileBottom = tileTop + TILE_SIZE;
      const overlapsHorizontally = playerRight > tileLeft && playerLeft < tileRight;
      const overlapsVertically = playerBottom > tileTop && playerTop < tileBottom;
      if (!overlapsHorizontally || !overlapsVertically) continue;

      // Allow per-hazard touch margin; default 4px
      let m = Number(def.touchMargin);
      if (!Number.isFinite(m)) m = 4;
      m = Math.max(1, Math.min(8, m));
      let touchingTop = playerBottom >= tileTop && playerBottom <= tileTop + m;
      let touchingBottom = playerTop <= tileBottom && playerTop >= tileBottom - m;
      let touchingLeft = playerRight >= tileRight - m && playerRight <= tileRight;
      let touchingRight = playerLeft <= tileLeft + m && playerLeft >= tileLeft;

      // Fallback: infer side by smallest penetration when inside tile
      if (!touchingTop && !touchingBottom && !touchingLeft && !touchingRight) {
        const distTop = Math.abs(playerBottom - tileTop);
        const distBottom = Math.abs(tileBottom - playerTop);
        const distLeft = Math.abs(playerRight - tileLeft);
        const distRight = Math.abs(tileRight - playerLeft);
        const min = Math.min(distTop, distBottom, distLeft, distRight);
        touchingTop = min === distTop;
        touchingBottom = !touchingTop && min === distBottom;
        touchingLeft = !touchingTop && !touchingBottom && min === distLeft;
        touchingRight = !touchingTop && !touchingBottom && !touchingLeft;
      }
      pushCandidate(idx, def, {
        top: touchingTop,
        bottom: touchingBottom,
        left: touchingLeft,
        right: touchingRight
      });
    }
  }
  if (candidates.length === 0) {
    hazardDamageAccumulatorRef.current = 0;
    lastHazardIndexRef.current = null;
    return;
  }

  // Choose deterministic candidate: prefer top > bottom > left > right
  const sideScore = t => (t.top ? 4 : 0) + (t.bottom ? 3 : 0) + (t.left ? 2 : 0) + (t.right ? 1 : 0);
  candidates.sort((a, b) => sideScore(b.touch) - sideScore(a.touch));
  const chosen = candidates[0];
  const index = chosen.index;
  const objDef = chosen.def;
  const touch = chosen.touch;

  // Update active hazard index
  const prevIndex = lastHazardIndexRef.current;
  lastHazardIndexRef.current = index;
  const damageOnce = !!objDef.damageOnce;
  const baseDamage = objDef.damage ?? 0;
  const dps = objDef.damagePerSecond ?? baseDamage;
  if (damageOnce) {
    if (!triggeredHazardsRef.current.has(index)) {
      triggeredHazardsRef.current.add(index);
      gameState.current.health = Math.max(0, gameState.current.health - baseDamage);
      // Hit flash to trigger temporary target animation
      const HIT_FLASH_MS = 500;
      const prev = Number(gameState.current.hitTimerMs) || 0;
      gameState.current.hitTimerMs = Math.max(prev, HIT_FLASH_MS);
      if (touch.top) {
        gameState.current.vy = -JUMP_FORCE * 0.4;
      } else if (touch.left) {
        gameState.current.vx = -MOVE_SPEED * 1.5;
      } else if (touch.right) {
        gameState.current.vx = MOVE_SPEED * 1.5;
      }
      return;
    }
  } else {
    // Continuous DPS: reset accumulator if we switched tiles
    const firstTouch = prevIndex !== index;
    if (firstTouch) {
      // Immediate damage on first contact, then start ticking
      hazardDamageAccumulatorRef.current = 0;
      const immediate = Number.isFinite(baseDamage) && baseDamage > 0 ? baseDamage : dps;
      if (immediate > 0) {
        gameState.current.health = Math.max(0, gameState.current.health - immediate);
        // Hit flash on immediate hit
        const HIT_FLASH_MS = 500;
        const prev = Number(gameState.current.hitTimerMs) || 0;
        gameState.current.hitTimerMs = Math.max(prev, HIT_FLASH_MS);
      }
      // Skip DPS accumulation this same frame to avoid double damage on long frames
      return;
    }
    hazardDamageAccumulatorRef.current += deltaMs;
    const TICK_MS = 1000;
    while (hazardDamageAccumulatorRef.current >= TICK_MS) {
      hazardDamageAccumulatorRef.current -= TICK_MS;
      gameState.current.health = Math.max(0, gameState.current.health - dps);
      // Refresh hit timer on each damage tick
      const HIT_FLASH_MS = 500;
      const prev = Number(gameState.current.hitTimerMs) || 0;
      gameState.current.hitTimerMs = Math.max(prev, HIT_FLASH_MS);
    }
  }
}
/* harmony default export */ const hazards = (null);
;// ./src/engine/gameplay/spawnProjectile.js
// Projectile spawning extracted from useGameEngine.js

function spawnProjectile_spawnProjectile(ctx, originX, originY, direction) {
  const {
    findItemById,
    TILE_SIZE,
    parseBool,
    projectilesRef,
    projectileIdRef,
    playShotSfx
  } = ctx;
  const pDef = findItemById('fireball_basic');
  const id = projectileIdRef.current++;
  const w = Math.max(2, (pDef?.width || 0.25) * TILE_SIZE);
  const h = Math.max(2, (pDef?.height || 0.25) * TILE_SIZE);
  const speedPxPerSec = pDef?.speed ? pDef.speed * 60 : 14 * 60;
  const vx = (direction >= 0 ? 1 : -1) * speedPxPerSec;
  const vy = 0;
  const life = Math.max(200, pDef?.lifespan || 600);
  const ricochetFlag = typeof pDef?.ricochetOnTiles !== 'undefined' ? !!pDef.ricochetOnTiles : parseBool(pDef?.collisionWithPenetration, true);
  const proj = {
    id,
    x: originX,
    y: originY,
    vx,
    vy,
    w,
    h,
    life,
    defId: pDef?.id || 'fireball_basic',
    dir: direction >= 0 ? 1 : -1,
    cwt: !!(pDef && pDef.collisionWithTiles),
    hbs: Math.max(0.1, Math.min(1.0, pDef?.hitboxScale ?? 1)),
    ric: ricochetFlag
  };
  projectilesRef.current.push(proj);
  try {
    const vol = Math.max(0, Math.min(1, pDef?.sfxVolume ?? 1));
    playShotSfx(pDef?.sfx, vol);
  } catch {}
}
;// ./src/engine/gameplay/collectItem.js
// Item collection extracted from useGameEngine.js

// Collects item under player's center if pickup-able.
// Args (ctx): { registryItems, TILE_SIZE, MAX_HEALTH, playShotSfx, onStateUpdate, gameState }
// Params: currentX, currentY, mapWidth, objectLayerData
function collectItem(ctx, currentX, currentY, mapWidth, objectLayerData) {
  const {
    registryItems,
    TILE_SIZE,
    MAX_HEALTH,
    playShotSfx,
    onStateUpdate,
    gameState
  } = ctx;
  if (!objectLayerData) return;
  const centerX = currentX + gameState.current.width / 2;
  const centerY = currentY + gameState.current.height / 2;
  const gridX = Math.floor(centerX / TILE_SIZE);
  const gridY = Math.floor(centerY / TILE_SIZE);
  const index = gridY * mapWidth + gridX;
  if (index < 0 || index >= objectLayerData.length) return;
  const itemId = objectLayerData[index];
  if (!itemId) return;
  const itemDef = registryItems.find(r => r.id === itemId);
  if (!itemDef || !itemDef.pickup || itemId.includes('player')) return;

  // Skip interactables - they are handled by checkInteractables()
  if (itemDef.name && itemDef.name.startsWith('interactable.')) return;

  // Health pickup
  if (itemDef.effect && itemDef.effect.health) {
    const healthBonus = parseInt(itemDef.effect.health, 10);
    if (gameState.current.health >= MAX_HEALTH) return;
    const newHealth = Math.min(gameState.current.health + healthBonus, MAX_HEALTH);
    gameState.current.health = newHealth;
    try {
      const vol = Math.max(0, Math.min(1, itemDef?.sfxVolume ?? 1));
      playShotSfx(itemDef?.sfx, vol);
    } catch {}
    if (onStateUpdate) onStateUpdate('collectItem', index);
    return;
  }

  // Fireball ammo pickup
  if (itemDef.effect && itemDef.effect.fireball) {
    const ammoBonus = parseInt(itemDef.effect.fireball, 10) || 0;
    gameState.current.ammo = Math.max(0, (gameState.current.ammo || 0) + ammoBonus);
    try {
      const vol = Math.max(0, Math.min(1, itemDef?.sfxVolume ?? 1));
      playShotSfx(itemDef?.sfx, vol);
    } catch {}
    if (onStateUpdate) onStateUpdate('collectItem', index);
    return;
  }
}
;// ./src/engine/gameplay/interactables.js
// Interactables logic - objects that can be used once and change state
// Unlike items (which disappear), interactables stay but change texture

function checkInteractables(ctx, currentX, currentY, mapWidth, objectLayerData) {
  const {
    registryItems,
    TILE_SIZE,
    MAX_HEALTH,
    playShotSfx,
    onStateUpdate,
    gameState
  } = ctx;
  if (!objectLayerData) return;
  const centerX = currentX + gameState.current.width / 2;
  const centerY = currentY + gameState.current.height / 2;
  const gridX = Math.floor(centerX / TILE_SIZE);
  const gridY = Math.floor(centerY / TILE_SIZE);
  const index = gridY * mapWidth + gridX;
  if (index < 0 || index >= objectLayerData.length) return;
  const objId = objectLayerData[index];
  if (!objId) return;
  const objDef = registryItems.find(r => r.id === objId);
  if (!objDef || !objDef.name || !objDef.name.startsWith('interactable.')) return;

  // Check if already used (track used interactables in gameState)
  if (!gameState.current.usedInteractables) {
    gameState.current.usedInteractables = new Set();
  }
  if (gameState.current.usedInteractables.has(index)) return; // Already used

  // Check if has effect
  if (!objDef.effect) return;

  // Health effect
  if (objDef.effect.health) {
    const healthBonus = parseInt(objDef.effect.health, 10);
    if (gameState.current.health >= MAX_HEALTH) return; // Don't use if already full health

    const newHealth = Math.min(gameState.current.health + healthBonus, MAX_HEALTH);
    gameState.current.health = newHealth;

    // Play sound
    try {
      const vol = Math.max(0, Math.min(1, objDef?.sfxVolume ?? 1));
      playShotSfx(objDef?.sfx, vol);
    } catch {}

    // Mark as used
    gameState.current.usedInteractables.add(index);

    // Notify state update with 'interactable' event - this will switch to next texture
    if (onStateUpdate) onStateUpdate('interactable', index);
    return;
  }

  // Future: Add other interactable effects (ammo, etc.)
  if (objDef.effect.fireball) {
    const ammoBonus = parseInt(objDef.effect.fireball, 10) || 0;
    gameState.current.ammo = Math.max(0, (gameState.current.ammo || 0) + ammoBonus);
    try {
      const vol = Math.max(0, Math.min(1, objDef?.sfxVolume ?? 1));
      playShotSfx(objDef?.sfx, vol);
    } catch {}
    gameState.current.usedInteractables.add(index);
    if (onStateUpdate) onStateUpdate('interactable', index);
    return;
  }
}
;// ./src/engine/gameplay/updateProjectiles.js
// Projectile update and ricochet simulation extracted from useGameEngine.js

// ctx: { projectilesRef, TILE_SIZE, isSolidAtPixel, findItemById }
// updateProjectiles(ctx, deltaMs, mapWidth, mapHeight)
function updateProjectiles(ctx, deltaMs, mapWidth, mapHeight) {
  const {
    projectilesRef,
    TILE_SIZE,
    isSolidAtPixel,
    findItemById
  } = ctx;
  const dtProj = deltaMs / 1000;
  const worldW = mapWidth * TILE_SIZE;
  const worldH = mapHeight * TILE_SIZE;
  const isSolidRect = (cx, cy, hw, hh) => {
    const pts = [{
      x: cx - hw,
      y: cy - hh
    }, {
      x: cx + hw,
      y: cy - hh
    }, {
      x: cx - hw,
      y: cy + hh
    }, {
      x: cx + hw,
      y: cy + hh
    }];
    for (let k = 0; k < pts.length; k++) {
      const pt = pts[k];
      if (isSolidAtPixel(pt.x, pt.y, mapWidth, mapHeight)) return true;
    }
    return false;
  };
  if (!projectilesRef.current.length) return;
  for (let i = projectilesRef.current.length - 1; i >= 0; i--) {
    const p = projectilesRef.current[i];
    if (p.bounces == null) p.bounces = 0;
    const maxBounces = Number.isFinite(p.maxBounces) ? p.maxBounces : findItemById(p.defId)?.maxBounces ?? 3;
    const bounceDamp = Number.isFinite(p.bounceDamping) ? p.bounceDamping : findItemById(p.defId)?.bounceDamping ?? 0.6;
    const ricRand = Number.isFinite(p.ricochetRandom) ? p.ricochetRandom : findItemById(p.defId)?.ricochetRandom ?? 0.15;
    const maxDelta = Math.max(Math.abs(p.vx * dtProj), Math.abs(p.vy * dtProj));
    let steps = Math.ceil(maxDelta / 4);
    if (!Number.isFinite(steps) || steps < 1) steps = 1;
    steps = Math.min(steps, 20);
    const stepTime = dtProj / steps;
    let cx = p.x;
    let cy = p.y;
    const hw = p.w * (p.hbs || 1) * 0.5;
    const hh = p.h * (p.hbs || 1) * 0.5;
    let removed = false;
    for (let s = 0; s < steps; s++) {
      // 1) X axis
      let nextX = cx + p.vx * stepTime;
      if (p.cwt && isSolidRect(nextX, cy, hw, hh)) {
        if (p.ric) {
          p.vx = -p.vx * bounceDamp;
          const sp = Math.max(40, Math.hypot(p.vx, p.vy));
          const jitter = (Math.random() * 2 - 1) * sp * ricRand;
          p.vy += jitter * 0.15;
          p.bounces += 1;
          p.life = Math.max(0, p.life - 80);
        } else {
          removed = true;
          break;
        }
      } else {
        cx = nextX;
      }

      // 2) Y axis
      let nextY = cy + p.vy * stepTime;
      if (p.cwt && isSolidRect(cx, nextY, hw, hh)) {
        if (p.ric) {
          p.vy = -p.vy * bounceDamp;
          const sp = Math.max(40, Math.hypot(p.vx, p.vy));
          const jitter = (Math.random() * 2 - 1) * sp * ricRand;
          p.vx += jitter * 0.15;
          p.bounces += 1;
          p.life = Math.max(0, p.life - 80);
        } else {
          removed = true;
          break;
        }
      } else {
        cy = nextY;
      }

      // 3) Corner stuck safeguard
      if (p.cwt && isSolidRect(cx, cy, hw, hh)) {
        if (p.ric) {
          p.vx = -p.vx * bounceDamp;
          p.vy = -p.vy * bounceDamp;
          p.bounces += 1;
          cx -= Math.sign(p.vx || 1) * 0.5;
          cy -= Math.sign(p.vy || 1) * 0.5;
        } else {
          removed = true;
          break;
        }
      }
    }
    p.x = cx;
    p.y = cy;
    p.life -= deltaMs;
    if (p.life <= 0 || p.x < -32 || p.y < -32 || p.x > worldW + 32 || p.y > worldH + 32 || removed || (p.bounces || 0) > (maxBounces || 0)) {
      projectilesRef.current.splice(i, 1);
      continue;
    }
  }
}
;// ./src/engine/audio/audio.js
// Audio utilities extracted from useGameEngine.js

// Usage: playSfx({ soundEnabledRef, audioCtxRef, audioCtxUnlockedRef }, url, volume)
function playSfx(ctx, url, volume) {
  const {
    soundEnabledRef,
    audioCtxRef
  } = ctx || {};
  try {
    if (!soundEnabledRef?.current) return;
    const vol = Math.max(0, Math.min(1, volume ?? 1));
    // 1) Try HTMLAudio first
    if (url && typeof url === 'string' && url.length > 0) {
      try {
        const audio = new Audio(url);
        audio.volume = vol;
        audio.addEventListener?.('error', () => {
          try {
            audio.pause();
          } catch {}
          beepFallback(ctx, vol);
        }, {
          once: true
        });
        const p = audio.play?.();
        if (p && typeof p.catch === 'function') p.catch(() => beepFallback(ctx, vol));
        return;
      } catch {
        // fallback below
      }
    }
    // 2) Fallback beep via WebAudio
    beepFallback(ctx, vol);
  } catch {}
}
function beepFallback(ctx, vol) {
  try {
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) return;
    if (!ctx?.audioCtxRef) return;
    if (!ctx.audioCtxRef.current) ctx.audioCtxRef.current = new AC();
    const audioCtx = ctx.audioCtxRef.current;
    if (!audioCtx) return;
    if (audioCtx.state === 'suspended') audioCtx.resume?.();
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    // short square click ~520Hz for ~90ms
    osc.type = 'square';
    osc.frequency.setValueAtTime(520, now);
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(Math.max(0.05, (vol ?? 0.2) * 0.2), now + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.08);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(now);
    osc.stop(now + 0.09);
  } catch {}
}
;// ./src/engine/physics/horizontal.js
// Horizontal movement extracted from useGameEngine.js

// Calculates horizontal velocity/direction and resolves horizontal collision with snap.
// Args:
// - keys: input state (expects boolean a/d)
// - state: { x, width, direction }
// - MOVE_SPEED, TILE_SIZE, mapWidth, mapHeight
// - checkCollision: function(newX, newY, mapWidth, mapHeight)  boolean
// Returns: { x, vx, direction }
function moveHorizontal({
  keys,
  state,
  MOVE_SPEED,
  TILE_SIZE,
  mapWidth,
  mapHeight,
  checkCollision
}) {
  let {
    x,
    width,
    direction
  } = state;
  let vx = 0;
  if (keys?.a) {
    vx = -MOVE_SPEED;
    direction = -1;
  }
  if (keys?.d) {
    vx = MOVE_SPEED;
    direction = 1;
  }
  const proposedX = x + vx;
  if (checkCollision(proposedX, state.y ?? 0, mapWidth, mapHeight)) {
    if (vx > 0) {
      // Snap to left edge of the blocking tile
      x = Math.floor((proposedX + width) / TILE_SIZE) * TILE_SIZE - width;
    } else if (vx < 0) {
      // Snap to right edge of the blocking tile
      x = Math.ceil(proposedX / TILE_SIZE) * TILE_SIZE;
    }
    vx = 0;
  } else {
    x = proposedX;
  }
  return {
    x,
    vx,
    direction
  };
}
/* harmony default export */ const horizontal = (null);
;// ./src/engine/physics/vertical.js
// Vertical physics (gravity, jump, vertical collisions)
// Migrated from GameEngine/applyVerticalPhysics.js to make core the source of truth.

// Args:
// - keys, x, y, vy, isGrounded, animation
// - GRAVITY, TERMINAL_VELOCITY, JUMP_FORCE, TILE_SIZE
// - width, height, mapWidth, mapHeight
// - checkCollision(newX, newY, mapWidth, mapHeight)
// - isWaterAt(wx, wy): optional helper to detect liquid tiles at a world pixel
// - vx: horizontal velocity (for deciding run/idle when landing)
// - prevInWater: whether player was in water on previous frame
// Returns: { y, vy, isGrounded, animation, inWater, headUnderWater, atSurface }
function applyVerticalPhysics({
  keys,
  x,
  y,
  vy,
  isGrounded,
  animation,
  GRAVITY,
  TERMINAL_VELOCITY,
  JUMP_FORCE,
  TILE_SIZE,
  width,
  height,
  mapWidth,
  mapHeight,
  checkCollision,
  vx,
  isWaterAt,
  prevInWater
}) {
  // Liquid defaults (can be overridden in future via per-tile sampling)
  const LIQ_BUOYANCY = 0.5; // reduces effective gravity by 50%
  const LIQ_DRAG_Y = 0.88; // vertical damping per frame when in liquid
  const LIQ_TERMINAL = Math.max(2, Math.floor(TERMINAL_VELOCITY * 0.4));

  // Water detection using centerline points
  let inWater = false;
  let headUnderWater = false;
  let atSurface = false;
  if (typeof isWaterAt === 'function') {
    const cx = x + (width || TILE_SIZE) * 0.5;
    const headY = y + Math.min(4, (height || TILE_SIZE) * 0.125);
    const feetY = y + (height || TILE_SIZE) - 2;
    const chestY = y + (height || TILE_SIZE) * 0.45;
    inWater = !!(isWaterAt(cx, feetY) || isWaterAt(cx, chestY));
    headUnderWater = !!isWaterAt(cx, headY);
    atSurface = inWater && !headUnderWater;
  }

  // Jump
  if (keys?.space || keys?.w) {
    if (inWater) {
      // Swim stroke (allow even when not grounded)
      const swimImpulse = Math.max(2, Math.floor(JUMP_FORCE * 0.55));
      vy = Math.min(vy, 0); // prevent extra downward boost
      vy -= swimImpulse * 0.5; // smaller continuous impulse
      animation = 'jump';
    } else if (isGrounded) {
      vy = -JUMP_FORCE;
      isGrounded = false;
      animation = 'jump';
    }
  }

  // Gravity (reduced in liquid) + vertical drag
  if (inWater) {
    // Entrance damping to remove harsh fall shock
    if (!prevInWater) {
      vy *= 0.4;
    }
    vy += GRAVITY * (1 - LIQ_BUOYANCY);
    vy *= LIQ_DRAG_Y;
    if (vy > LIQ_TERMINAL) vy = LIQ_TERMINAL;
  } else {
    vy += GRAVITY;
    if (vy > TERMINAL_VELOCITY) vy = TERMINAL_VELOCITY;
  }

  // Check vertical collision at proposed Y
  if (checkCollision(x, y + vy, mapWidth, mapHeight)) {
    if (vy > 0) {
      // Landing on ground
      isGrounded = true;
      y = Math.floor((y + vy + height) / TILE_SIZE) * TILE_SIZE - height;
      if (Math.abs(vx || 0) > 0) {
        animation = 'run';
      } else {
        animation = 'idle';
      }
    } else if (vy < 0) {
      // Hitting ceiling
      y = Math.ceil((y + vy) / TILE_SIZE) * TILE_SIZE;
    }
    vy = 0;
  } else {
    // Free fall
    isGrounded = false;
    y += vy;
    if (vy > 0) {
      animation = 'fall';
    }
  }
  return {
    y,
    vy,
    isGrounded,
    animation,
    inWater,
    headUnderWater,
    atSurface
  };
}
/* harmony default export */ const vertical = (null);
;// ./src/engine/liquids/liquidUtils.js
// Generic liquid helpers (water, lava, etc.)
// Liquids are defined as blocks with flags.liquid === true and optional flags.water/flags.lava
// Optional physics params live under def.liquid: { buoyancy, drag:{x,y}, surface, swimmable, damagePerSecond }

/**
 * Sample registry tile definition at world pixel and return liquid info if present.
 * @param {number} wx world x in pixels
 * @param {number} wy world y in pixels
 * @param {number} mapWidthTiles
 * @param {number} mapHeightTiles
 * @param {number} TILE_SIZE
 * @param {Array<string|null>} tileData tile ids array (background layer)
 * @param {Array<object>} registryItems game registry array
 * @returns {null|{def:object, type:'water'|'lava'|'liquid', params:object}}
 */
function getLiquidAtPixel(wx, wy, mapWidthTiles, mapHeightTiles, TILE_SIZE, tileData, registryItems) {
  if (wy < 0) return null;
  const gx = Math.floor(wx / TILE_SIZE);
  const gy = Math.floor(wy / TILE_SIZE);
  if (gx < 0 || gy < 0 || gx >= mapWidthTiles || gy >= mapHeightTiles) return null;
  const idx = gy * mapWidthTiles + gx;
  const id = tileData[idx];
  if (!id) return null;
  const def = Array.isArray(registryItems) ? registryItems.find(r => r.id === id) : null;
  if (!def || !def.flags || !def.flags.liquid) return null;
  const type = def.flags.water ? 'water' : def.flags.lava ? 'lava' : 'liquid';
  const params = {
    buoyancy: Number(def?.liquid?.buoyancy),
    dragX: Number(def?.liquid?.drag?.x),
    dragY: Number(def?.liquid?.drag?.y),
    surface: !!def?.liquid?.surface,
    swimmable: def?.flags?.swimmable === true || def?.liquid?.swimmable === true,
    dps: Number(def?.liquid?.damagePerSecond),
    // Optional resource models
    oxygen: {
      drainPerSecond: Number(def?.liquid?.oxygen?.drainPerSecond),
      regenPerSecond: Number(def?.liquid?.oxygen?.regenPerSecond),
      damagePerSecondWhenDepleted: Number(def?.liquid?.oxygen?.damagePerSecondWhenDepleted)
    },
    resistance: {
      drainPerSecond: Number(def?.liquid?.resistance?.drainPerSecond),
      regenPerSecond: Number(def?.liquid?.resistance?.regenPerSecond),
      damagePerSecondWhenDepleted: Number(def?.liquid?.resistance?.damagePerSecondWhenDepleted)
    }
  };
  return {
    def,
    type,
    params
  };
}

/**
 * Convenience: returns whether any liquid exists at world pixel.
 */
function isLiquidAtPixel(wx, wy, mapWidthTiles, mapHeightTiles, TILE_SIZE, tileData, registryItems) {
  return !!getLiquidAtPixel(wx, wy, mapWidthTiles, mapHeightTiles, TILE_SIZE, tileData, registryItems);
}

/**
 * Compute liquid occupancy for a player AABB and derive head/feet status.
 * @returns { inLiquid:boolean, headUnder:boolean, atSurface:boolean, type:string|null, params:object }
 */
function sampleLiquidForAABB({
  x,
  y,
  width,
  height,
  TILE_SIZE,
  mapWidth,
  mapHeight,
  tileData,
  registryItems
}) {
  const cx = x + width * 0.5;
  const headY = y + Math.min(4, height * 0.125);
  const chestY = y + height * 0.45;
  const feetY = y + height - 2;
  const feet = getLiquidAtPixel(cx, feetY, mapWidth, mapHeight, TILE_SIZE, tileData, registryItems);
  const chest = getLiquidAtPixel(cx, chestY, mapWidth, mapHeight, TILE_SIZE, tileData, registryItems);
  const head = getLiquidAtPixel(cx, headY, mapWidth, mapHeight, TILE_SIZE, tileData, registryItems);
  const candidate = feet || chest || head;
  if (!candidate) {
    return {
      inLiquid: false,
      headUnder: false,
      atSurface: false,
      type: null,
      params: null
    };
  }
  const type = candidate.type;
  // Merge params with sane defaults if missing
  const p = {
    buoyancy: Number.isFinite(candidate.params.buoyancy) ? candidate.params.buoyancy : 0.5,
    dragX: Number.isFinite(candidate.params.dragX) ? candidate.params.dragX : 0.55,
    dragY: Number.isFinite(candidate.params.dragY) ? candidate.params.dragY : 0.65,
    surface: !!candidate.params.surface,
    swimmable: !!candidate.params.swimmable,
    dps: Number.isFinite(candidate.params.dps) ? Math.max(0, candidate.params.dps) : 0,
    oxygen: {
      drainPerSecond: Number.isFinite(candidate.params?.oxygen?.drainPerSecond) ? Math.max(0, candidate.params.oxygen.drainPerSecond) : 20,
      regenPerSecond: Number.isFinite(candidate.params?.oxygen?.regenPerSecond) ? Math.max(0, candidate.params.oxygen.regenPerSecond) : 35,
      damagePerSecondWhenDepleted: Number.isFinite(candidate.params?.oxygen?.damagePerSecondWhenDepleted) ? Math.max(0, candidate.params.oxygen.damagePerSecondWhenDepleted) : 10
    },
    resistance: {
      drainPerSecond: Number.isFinite(candidate.params?.resistance?.drainPerSecond) ? Math.max(0, candidate.params.resistance.drainPerSecond) : 25,
      regenPerSecond: Number.isFinite(candidate.params?.resistance?.regenPerSecond) ? Math.max(0, candidate.params.resistance.regenPerSecond) : 40,
      damagePerSecondWhenDepleted: Number.isFinite(candidate.params?.resistance?.damagePerSecondWhenDepleted) ? Math.max(0, candidate.params.resistance.damagePerSecondWhenDepleted) : 15
    }
  };
  const inLiquid = !!(feet || chest);
  const headUnder = !!head;
  const atSurface = inLiquid && !headUnder;
  return {
    inLiquid,
    headUnder,
    atSurface,
    type,
    params: p
  };
}

/**
 * Manage per-second liquid damage. Mutates gameState.current.health and hitTimer.
 * @param {{accRef: {current:number}, gameState: any, JUMP_FORCE?:number}} env
 * @param {number} deltaMs
 * @param {{ dps:number }} params
 */
function tickLiquidDamage(env, deltaMs, params) {
  const dps = Math.max(0, Number(params?.dps) || 0);
  if (dps <= 0) {
    env.accRef.current = 0;
    return;
  }
  env.accRef.current += Math.max(0, Number(deltaMs) || 0);
  const TICK = 1000;
  while (env.accRef.current >= TICK) {
    env.accRef.current -= TICK;
    const cur = Number(env.gameState.current.health) || 0;
    env.gameState.current.health = Math.max(0, cur - dps);
    const HIT_FLASH_MS = 500;
    const prev = Number(env.gameState.current.hitTimerMs) || 0;
    env.gameState.current.hitTimerMs = Math.max(prev, HIT_FLASH_MS);
  }
}
/* harmony default export */ const liquidUtils = ({
  getLiquidAtPixel,
  isLiquidAtPixel,
  sampleLiquidForAABB,
  tickLiquidDamage
});
;// ./src/engine/loop/updateFrame.js
// One-frame update orchestrator (migrated from GameEngine/updateFrame.js)




// updateFrame(ctx, timestamp)  { continue: boolean }
// ctx expects:
// - mapData, objectData
// - input
// - refs: { gameState, isInitialized, lastTimeRef, projectilesRef, shootCooldownRef, liquidDamageAccumulatorRef, oxygenDepleteAccRef, lavaDepleteAccRef }
// - constants: { TILE_SIZE, GRAVITY, TERMINAL_VELOCITY, MOVE_SPEED, JUMP_FORCE }
// - helpers: { checkCollision, isWaterAt, getLiquidSample }
// - actions: {
//     collectItem(x, y, mapWidth, objectData),
//     checkHazardDamage(x, y, mapWidth, objectData, deltaMs),
//     spawnProjectile(originX, originY, direction),
//     updateProjectiles(deltaMs, mapWidth, mapHeight),
//     setPlayer(nextState),
//     onGameOver()
//   }
function updateFrame(ctx, timestamp) {
  const {
    mapData,
    objectData,
    input,
    refs,
    constants,
    helpers,
    actions
  } = ctx;
  const {
    gameState,
    isInitialized,
    lastTimeRef,
    projectilesRef,
    shootCooldownRef,
    liquidDamageAccumulatorRef,
    oxygenDepleteAccRef,
    lavaDepleteAccRef
  } = refs;
  const {
    TILE_SIZE,
    GRAVITY,
    TERMINAL_VELOCITY,
    MOVE_SPEED,
    JUMP_FORCE
  } = constants;
  const {
    checkCollision,
    isWaterAt,
    getLiquidSample
  } = helpers;
  const {
    collectItem,
    checkInteractables,
    checkHazardDamage,
    spawnProjectile,
    updateProjectiles,
    setPlayer,
    onGameOver
  } = actions;

  // Keep RAF alive even if init not finished yet
  if (!isInitialized.current || !mapData) {
    return {
      continue: true
    };
  }

  // Delta time ms
  if (!lastTimeRef.current) {
    lastTimeRef.current = timestamp;
  }
  const deltaMs = timestamp - lastTimeRef.current;
  lastTimeRef.current = timestamp;

  // Pause while terminal is open
  try {
    if (window.__GAME_TERMINAL_OPEN__) {
      return {
        continue: true
      };
    }
  } catch {}
  const mapWidth = mapData.meta?.width || mapData.width || 20;
  const mapHeight = mapData.meta?.height || mapData.height || 15;
  const keys = input.current;
  let {
    x,
    y,
    vx,
    vy,
    width,
    height,
    isGrounded,
    direction,
    animation,
    ammo
  } = gameState.current;

  // 1) Horizontal movement
  const mh = moveHorizontal({
    keys,
    state: {
      x,
      y,
      width,
      direction
    },
    MOVE_SPEED,
    TILE_SIZE,
    mapWidth,
    mapHeight,
    checkCollision
  });
  x = mh.x;
  vx = mh.vx;
  direction = mh.direction;

  // 2) Vertical physics
  const vp = applyVerticalPhysics({
    keys,
    x,
    y,
    vy,
    isGrounded,
    animation,
    GRAVITY,
    TERMINAL_VELOCITY,
    JUMP_FORCE,
    TILE_SIZE,
    width,
    height,
    mapWidth,
    mapHeight,
    checkCollision,
    vx,
    isWaterAt: (wx, wy) => {
      try {
        return typeof isWaterAt === 'function' ? !!isWaterAt(wx, wy) : false;
      } catch {
        return false;
      }
    },
    prevInWater: !!gameState.current.inWater
  });
  y = vp.y;
  vy = vp.vy;
  isGrounded = vp.isGrounded;
  animation = vp.animation;
  const inWater = !!vp.inWater;
  const headUnderWater = !!vp.headUnderWater;
  const atSurface = !!vp.atSurface;

  // 2.5) Generic liquid sampling (water, lava, etc.)
  let liquidType = null;
  let liquidParams = null;
  if (typeof getLiquidSample === 'function') {
    try {
      const sample = getLiquidSample({
        x,
        y,
        width,
        height,
        TILE_SIZE,
        mapWidth,
        mapHeight
      });
      if (sample && sample.inLiquid) {
        liquidType = sample.type || null;
        liquidParams = sample.params || null;
      }
      // Reset DPS accumulator if we just left liquids
      if (!sample || !sample.inLiquid) {
        if (liquidDamageAccumulatorRef) liquidDamageAccumulatorRef.current = 0;
      }
    } catch {}
  }

  // Extra horizontal damping when in liquids
  if (inWater || liquidType) {
    if (liquidType === 'lava') {
      vx *= 0.78;
    } else {
      vx *= 0.82;
    }
  }

  // 2.6) Apply liquid damage-per-second if defined (e.g., lava)
  // Will be gated later for lava by resistance depletion; water dps usually 0.

  // 2.7) Resource bars logic (oxygen & lava resistance indicators)
  try {
    const dt = Math.max(0, deltaMs || 0);
    // Initialize defaults if missing
    const maxOxy = Math.max(1, Number(gameState.current.maxOxygen || 100));
    const maxLava = Math.max(1, Number(gameState.current.maxLavaResist || 100));
    let oxy = Number(gameState.current.oxygen);
    let lavaRes = Number(gameState.current.lavaResist);
    if (!Number.isFinite(oxy)) oxy = maxOxy;
    if (!Number.isFinite(lavaRes)) lavaRes = maxLava;
    // Resolve per-liquid parameters (with safe defaults)
    const oxyParams = liquidParams?.oxygen || {
      drainPerSecond: 20,
      regenPerSecond: 35,
      damagePerSecondWhenDepleted: 10
    };
    const lavaParams = liquidParams?.resistance || {
      drainPerSecond: 25,
      regenPerSecond: 40,
      damagePerSecondWhenDepleted: 15
    };

    // Oxygen: drains only while head is under water; otherwise regenerates to 100 even after leaving water
    if (headUnderWater && (liquidType === 'water' || inWater)) {
      oxy -= Math.max(0, Number(oxyParams.drainPerSecond) || 0) * dt / 1000;
    } else {
      oxy += Math.max(0, Number(oxyParams.regenPerSecond) || 0) * dt / 1000;
    }
    // Clamp and write back
    oxy = Math.max(0, Math.min(maxOxy, oxy));
    gameState.current.oxygen = oxy;
    gameState.current.maxOxygen = maxOxy;

    // Lava resistance: drains while in lava; regenerates outside
    if (liquidType === 'lava') {
      lavaRes -= Math.max(0, Number(lavaParams.drainPerSecond) || 0) * dt / 1000;
    } else {
      lavaRes += Math.max(0, Number(lavaParams.regenPerSecond) || 0) * dt / 1000;
    }
    lavaRes = Math.max(0, Math.min(maxLava, lavaRes));
    gameState.current.lavaResist = lavaRes;
    gameState.current.maxLavaResist = maxLava;

    // Apply depletion health damage when at zero and still in corresponding liquid
    const tickDepleteDps = (accRef, dpsValue) => {
      const v = Math.max(0, Number(dpsValue) || 0);
      if (v <= 0) {
        accRef.current = 0;
        return;
      }
      accRef.current += dt;
      const T = 1000;
      while (accRef.current >= T) {
        accRef.current -= T;
        gameState.current.health = Math.max(0, (Number(gameState.current.health) || 0) - v);
        // Hit flash
        const HIT_FLASH_MS = 500;
        const prev = Number(gameState.current.hitTimerMs) || 0;
        gameState.current.hitTimerMs = Math.max(prev, HIT_FLASH_MS);
      }
    };

    // Oxygen depleted and still underwater  damage
    if (headUnderWater && (liquidType === 'water' || inWater) && oxy <= 0) {
      tickDepleteDps(oxygenDepleteAccRef, oxyParams.damagePerSecondWhenDepleted);
    } else if (oxygenDepleteAccRef) {
      oxygenDepleteAccRef.current = 0;
    }

    // Lava resist depleted and still in lava  health damage model is gated by base DPS below
    if (liquidType === 'lava' && lavaRes <= 0) {
      if (lavaDepleteAccRef) lavaDepleteAccRef.current = 0;
    } else if (lavaDepleteAccRef) {
      lavaDepleteAccRef.current = 0;
    }
  } catch {}

  // 2.8) Base liquid DPS (e.g., lava)  only after resource logic so we can gate by resistance
  if (liquidType && liquidParams && Number(liquidParams.dps) > 0) {
    try {
      if (liquidType === 'lava') {
        const curRes = Math.max(0, Number(gameState.current.lavaResist));
        if (curRes <= 0) {
          tickLiquidDamage({
            accRef: liquidDamageAccumulatorRef,
            gameState
          }, deltaMs, liquidParams);
        } else {
          if (liquidDamageAccumulatorRef) liquidDamageAccumulatorRef.current = 0;
        }
      } else {
        // Other liquids (if any in future) apply their DPS normally
        tickLiquidDamage({
          accRef: liquidDamageAccumulatorRef,
          gameState
        }, deltaMs, liquidParams);
      }
    } catch {}
  } else {
    if (liquidDamageAccumulatorRef) liquidDamageAccumulatorRef.current = 0;
  }

  // 3) Item collection
  collectItem(x, y, mapWidth, objectData);

  // 3.5) Interactables check (berry bushes etc.)
  try {
    checkInteractables(x, y, mapWidth, objectData);
  } catch {}

  // 4) Hazard damage check (bushes etc.)
  try {
    checkHazardDamage(x, y, mapWidth, objectData, deltaMs);
  } catch {}

  // 5) Shooting & projectiles
  // Cooldown update
  if (shootCooldownRef.current > 0) shootCooldownRef.current = Math.max(0, shootCooldownRef.current - deltaMs);
  // Get fresh ammo value after item collection
  const currentAmmo = Math.max(0, Number(gameState.current.ammo) || 0);
  if (keys?.mouseLeft && shootCooldownRef.current <= 0 && currentAmmo > 0) {
    const originX = x + width / 2;
    const originY = y + height / 2;
    spawnProjectile(originX, originY, direction >= 0 ? 1 : -1);
    shootCooldownRef.current = 350; // ms cooldown
    gameState.current.ammo = Math.max(0, currentAmmo - 1);
  }
  // Update existing projectiles
  try {
    updateProjectiles(deltaMs, mapWidth, mapHeight);
  } catch {}

  // 6) Clamp player to world bounds horizontally; allow falling below map to trigger game over
  const maxX = mapWidth * TILE_SIZE - width;
  x = Math.max(0, Math.min(maxX, x));

  // 7) Death check
  if ((Number(gameState.current.health) || 0) <= 0) {
    try {
      onGameOver && onGameOver();
    } catch {}
  }

  // 8) Decrement hit flash timer
  try {
    if (Number(gameState.current.hitTimerMs) > 0) {
      gameState.current.hitTimerMs = Math.max(0, Number(gameState.current.hitTimerMs) - deltaMs);
    }
  } catch {}

  // 9) Commit new state for renderer
  gameState.current = {
    ...gameState.current,
    x,
    y,
    vx,
    vy,
    width,
    height,
    isGrounded,
    direction,
    animation,
    inWater,
    headUnderWater,
    atSurface,
    liquidType: liquidType || null
  };
  setPlayer({
    ...gameState.current,
    projectiles: projectilesRef.current || []
  });
  return {
    continue: true
  };
}
/* harmony default export */ const loop_updateFrame = (null);
;// ./src/engine/physics/collision.js
// Collision helpers (migrated from GameEngine/collision.js)

// Check whether a world pixel (wx, wy) is solid (collides with a tile)
// Params:
// - wx, wy: world pixel coordinates
// - mapWidthTiles, mapHeightTiles: map size in tiles
// - TILE_SIZE: tile size in pixels
// - tileData: tile layer array (ids)
// - registryItems: registry to resolve tile definitions (with `collision` flag)
function collision_isSolidAtPixel(wx, wy, mapWidthTiles, mapHeightTiles, TILE_SIZE, tileData, registryItems) {
  // Allow movement above the map
  if (wy < 0) return false;
  const gx = Math.floor(wx / TILE_SIZE);
  const gy = Math.floor(wy / TILE_SIZE);
  // Out of world is not solid (projectile/later logic will clamp by bounds)
  if (gx < 0 || gy < 0 || gx >= mapWidthTiles || gy >= mapHeightTiles) return false;
  const index = gy * mapWidthTiles + gx;
  const tileId = tileData[index];
  if (!tileId) return false;
  const tileDef = registryItems.find(r => r.id === tileId);
  if (!tileDef || !tileDef.collision) return false;
  if (tileDef.collision === true) return true;
  if (typeof tileDef.collision === 'object') {
    return !!(tileDef.collision.top || tileDef.collision.bottom || tileDef.collision.left || tileDef.collision.right);
  }
  return false;
}

// AABB collision check for player rectangle at (newX, newY)
// Params:
// - newX, newY: proposed player top-left position (pixels)
// - mapWidthTiles, mapHeightTiles: map size in tiles
// - TILE_SIZE, tileData, registryItems: see above
// - width, height: player size in pixels
function collision_checkCollision(newX, newY, mapWidthTiles, mapHeightTiles, TILE_SIZE, tileData, registryItems, width, height) {
  const points = [{
    x: newX,
    y: newY
  },
  // Top Left
  {
    x: newX + width - 0.01,
    y: newY
  },
  // Top Right
  {
    x: newX,
    y: newY + height - 0.01
  },
  // Bottom Left
  {
    x: newX + width - 0.01,
    y: newY + height - 0.01
  } // Bottom Right
  ];
  for (let p of points) {
    const gridX = Math.floor(p.x / TILE_SIZE);
    const gridY = Math.floor(p.y / TILE_SIZE);
    const index = gridY * mapWidthTiles + gridX;

    // Out-of-bounds horizontally or above map is treated as solid to prevent escaping
    if (gridX < 0 || gridX >= mapWidthTiles || gridY < 0) return true;
    // Below the map is not a collision  allows falling off the world
    if (gridY >= mapHeightTiles) continue;
    const tileId = tileData[index];
    if (tileId) {
      const tileDef = registryItems.find(r => r.id === tileId);
      if (tileDef && tileDef.collision) return true;
    }
  }
  return false;
}
/* harmony default export */ const collision = ({
  isSolidAtPixel: collision_isSolidAtPixel,
  checkCollision: collision_checkCollision
});
;// ./src/engine/physics/index.js
// Physics exports



;// ./src/services/errorHandler.js
/**
 * Centralized Error Handler
 * Provides unified error handling and logging across the application
 */

class ErrorHandler {
  constructor() {
    this.errorListeners = [];
    this.logLevel =  true ? 'error' : 0;
  }

  /**
   * Log levels: debug, info, warn, error
   */
  setLogLevel(level) {
    this.logLevel = level;
  }

  /**
   * Add error listener callback
   * @param {Function} callback - Callback function to receive errors
   */
  addListener(callback) {
    this.errorListeners.push(callback);
  }

  /**
   * Remove error listener callback
   * @param {Function} callback - Callback to remove
   */
  removeListener(callback) {
    this.errorListeners = this.errorListeners.filter(cb => cb !== callback);
  }

  /**
   * Notify all listeners of an error
   * @param {Error} error - The error object
   * @param {Object} context - Additional context information
   */
  notifyListeners(error, context = {}) {
    this.errorListeners.forEach(callback => {
      try {
        callback(error, context);
      } catch (err) {
        console.error('Error in error listener:', err);
      }
    });
  }

  /**
   * Handle and log an error
   * @param {Error|string} error - The error to handle
   * @param {Object} context - Additional context information
   * @param {string} level - Log level (debug, info, warn, error)
   */
  handle(error, context = {}, level = 'error') {
    const errorObj = error instanceof Error ? error : new Error(String(error));
    const timestamp = new Date().toISOString();
    const logData = {
      timestamp,
      level,
      message: errorObj.message,
      stack: errorObj.stack,
      context
    };

    // Console logging based on level
    if (this.shouldLog(level)) {
      const logMethod = console[level] || console.error;
      logMethod(`[${timestamp}] [${level.toUpperCase()}]`, errorObj.message, context);
      if (errorObj.stack && level === 'error') {
        console.error(errorObj.stack);
      }
    }

    // Notify listeners
    if (level === 'error' || level === 'warn') {
      this.notifyListeners(errorObj, context);
    }

    // In development, you could send to external logging service
    if (true) {
      this.sendToLoggingService(logData);
    }
    return errorObj;
  }

  /**
   * Determine if a log level should be printed based on current log level setting
   * @param {string} level - The log level to check
   * @returns {boolean}
   */
  shouldLog(level) {
    const levels = {
      debug: 0,
      info: 1,
      warn: 2,
      error: 3
    };
    const currentLevel = levels[this.logLevel] || 0;
    const messageLevel = levels[level] || 0;
    return messageLevel >= currentLevel;
  }

  /**
   * Send error data to external logging service (stub for now)
   * @param {Object} logData - The log data to send
   */
  sendToLoggingService(logData) {
    // TODO: Implement integration with external logging service
    // (e.g., Sentry, LogRocket, etc.)
  }

  /**
   * Convenience methods for different log levels
   */
  debug(message, context = {}) {
    return this.handle(message, context, 'debug');
  }
  info(message, context = {}) {
    return this.handle(message, context, 'info');
  }
  warn(message, context = {}) {
    return this.handle(message, context, 'warn');
  }
  error(message, context = {}) {
    return this.handle(message, context, 'error');
  }

  /**
   * Wrap an async function with error handling
   * @param {Function} fn - The async function to wrap
   * @param {Object} context - Additional context for errors
   * @returns {Function} Wrapped function
   */
  wrapAsync(fn, context = {}) {
    return async (...args) => {
      try {
        return await fn(...args);
      } catch (error) {
        this.handle(error, {
          ...context,
          args
        }, 'error');
        throw error;
      }
    };
  }

  /**
   * Wrap a sync function with error handling
   * @param {Function} fn - The function to wrap
   * @param {Object} context - Additional context for errors
   * @returns {Function} Wrapped function
   */
  wrapSync(fn, context = {}) {
    return (...args) => {
      try {
        return fn(...args);
      } catch (error) {
        this.handle(error, {
          ...context,
          args
        }, 'error');
        throw error;
      }
    };
  }
}

// Export singleton instance
const errorHandler = new ErrorHandler();
/* harmony default export */ const services_errorHandler = (errorHandler);

;// ./src/utilities/useGameEngine.js











// Helper: accept boolean or string values like "true"/"false"
const parseBool = (v, def = false) => {
  if (typeof v === 'boolean') return v;
  if (typeof v === 'string') return v.trim().toLowerCase() === 'true';
  return def;
};

// Modified arguments: added objectData
const useGameEngine = (mapData, tileData, objectData, registryItems, onGameOver, onStateUpdate) => {
  const input = useInput();

  // Player state
  const [player, setPlayer] = (0,react.useState)({
    x: 0,
    // In pixels
    y: 0,
    // In pixels
    width: 32,
    // Default, will be overwritten from registry
    height: 32,
    vx: 0,
    vy: 0,
    isGrounded: false,
    direction: 1,
    // 1 right, -1 left
    animation: 'idle',
    // idle, run, jump
    health: 90,
    // Initial health (for testing, to allow picking up hearts)
    maxHealth: MAX_HEALTH,
    ammo: 0,
    // Fireball ammunition
    // New resources for display
    oxygen: MAX_OXYGEN,
    maxOxygen: MAX_OXYGEN,
    lavaResist: MAX_LAVA_RESIST,
    maxLavaResist: MAX_LAVA_RESIST,
    projectiles: [] // Active projectiles for rendering
  });

  // Ref objects for game logic
  const gameState = (0,react.useRef)({
    ...player
  }); // Player state for loop (avoids closure issues)
  const requestRef = (0,react.useRef)(); // requestAnimationFrame id
  const isInitialized = (0,react.useRef)(false); // Whether game is initialized
  const lastTimeRef = (0,react.useRef)(0); // Time between frames (t)
  const hazardDamageAccumulatorRef = (0,react.useRef)(0); // Accumulated time for hazard damage over time
  const lastHazardIndexRef = (0,react.useRef)(null); // Last hazard tile index cache (to associate damage with specific hazard)
  const triggeredHazardsRef = (0,react.useRef)(new Set()); // Hazards with damageOnce: true that have already triggered
  const projectilesRef = (0,react.useRef)([]); // Active projectiles
  const shootCooldownRef = (0,react.useRef)(0); // Remaining cooldown time (ms)
  const projectileIdRef = (0,react.useRef)(1); // Auto-incrementing ID
  const soundEnabledRef = (0,react.useRef)(false); // Global sound toggle
  const audioCtxRef = (0,react.useRef)(null); // WebAudio context (fallback)
  const audioCtxUnlockedRef = (0,react.useRef)(false); // Whether AudioContext is unlocked with user gesture
  const liquidDamageAccumulatorRef = (0,react.useRef)(0); // Accumulated time for liquid DPS ticking (e.g., lava)
  const oxygenDepleteAccRef = (0,react.useRef)(0); // O2 depletion DPS accumulator
  const lavaDepleteAccRef = (0,react.useRef)(0); // Lava resist depletion DPS accumulator

  // Sync global sound toggle from localStorage and events
  (0,react.useEffect)(() => {
    try {
      const v = localStorage.getItem('game_sound_enabled');
      soundEnabledRef.current = v === null ? false : v !== '0';
    } catch {
      soundEnabledRef.current = false;
    }
    const onToggle = e => {
      try {
        const enabled = !!e?.detail?.enabled;
        soundEnabledRef.current = enabled;
      } catch {}
    };
    window.addEventListener('game-sound-toggle', onToggle);
    // AudioContext unlocking with user gesture (click on HUD button, etc.)
    const onUserGesture = () => {
      try {
        if (!audioCtxRef.current) {
          const AC = window.AudioContext || window.webkitAudioContext;
          if (AC) audioCtxRef.current = new AC();
        }
        if (audioCtxRef.current && audioCtxRef.current.state === 'suspended') {
          audioCtxRef.current.resume?.();
        }
        if (audioCtxRef.current && audioCtxRef.current.state === 'running') {
          audioCtxUnlockedRef.current = true;
        }
      } catch {}
    };
    window.addEventListener('game-sound-user-gesture', onUserGesture);
    return () => {
      window.removeEventListener('game-sound-toggle', onToggle);
      window.removeEventListener('game-sound-user-gesture', onUserGesture);
    };
  }, []);

  // Helper function: play SFX (delegated to GameEngine/audio)
  const playShotSfx = (url, volume) => {
    return playSfx({
      soundEnabledRef,
      audioCtxRef,
      audioCtxUnlockedRef
    }, url, volume);
  };

  // Adapter: correctly calls GameEngine/checkHazardDamage with options object
  const checkHazardDamageWrapper = (currentX, currentY, mapWidth, objectLayerData, deltaMs) => {
    try {
      return checkHazardDamage({
        currentX,
        currentY,
        mapWidth,
        objectLayerData,
        deltaMs,
        registryItems,
        TILE_SIZE: TILE_SIZE,
        MOVE_SPEED: MOVE_SPEED,
        JUMP_FORCE: JUMP_FORCE,
        hazardDamageAccumulatorRef,
        lastHazardIndexRef,
        triggeredHazardsRef,
        gameState
      });
    } catch (error) {
      services_errorHandler.error(error, {
        component: 'useGameEngine',
        function: 'checkHazardDamageWrapper',
        playerPosition: {
          x: currentX,
          y: currentY
        },
        mapWidth
      });
      return {
        damage: 0,
        damageType: null
      };
    }
  };

  // Initialize player at starting position
  // Important: This effect now depends ONLY on mapData (which doesn't change when collecting items)
  (0,react.useEffect)(() => {
    // Reset hazard state when map changes
    isInitialized.current = false;
    lastTimeRef.current = 0;
    hazardDamageAccumulatorRef.current = 0;
    lastHazardIndexRef.current = null;
    triggeredHazardsRef.current = new Set();
    projectilesRef.current = [];
    shootCooldownRef.current = 0;
    projectileIdRef.current = 1;
    if (mapData && mapData.layers) {
      const mapW = mapData.meta?.width || mapData.width || 20;
      const mapH = mapData.meta?.height || mapData.height || 15;
      const objLayer = mapData.layers.find(l => l.name === 'entities');
      if (objLayer) {
        // Search for player (anything containing 'player')
        const startIndex = objLayer.data.findIndex(id => id && id.includes('player'));
        if (startIndex !== -1) {
          let startX = startIndex % mapW * TILE_SIZE;
          let startY = Math.floor(startIndex / mapW) * TILE_SIZE;

          // Get data from registry
          const playerId = objLayer.data[startIndex];
          const registryPlayer = findItemById(playerId) || findItemById("player"); // Fallback to generic player
          const maxHealth = Math.max(1, Number(registryPlayer?.maxHealth) || MAX_HEALTH);

          // Completely overwrite gameState with default values + new position
          gameState.current = {
            x: startX,
            y: startY,
            width: (registryPlayer?.width || 1) * TILE_SIZE * 0.8,
            height: (registryPlayer?.height || 1) * TILE_SIZE,
            vx: 0,
            vy: 0,
            isGrounded: false,
            direction: 1,
            animation: 'idle',
            health: Math.min(90, maxHealth),
            // Reset to 90 (not MAX) to allow testing items
            maxHealth,
            ammo: 0,
            // resources
            oxygen: MAX_OXYGEN,
            maxOxygen: MAX_OXYGEN,
            lavaResist: MAX_LAVA_RESIST,
            maxLavaResist: MAX_LAVA_RESIST
          };

          // If start position sinks into block, move up to safe location
          let guard = 0;
          while (checkCollision(gameState.current.x, gameState.current.y, mapW, mapH) && guard < mapH) {
            gameState.current.y = Math.max(0, gameState.current.y - TILE_SIZE);
            guard++;
          }
          // Ensure we're not outside world boundaries horizontally
          const maxXAtStart = mapW * TILE_SIZE - gameState.current.width;
          gameState.current.x = Math.max(0, Math.min(gameState.current.x, maxXAtStart));
          setPlayer({
            ...gameState.current,
            projectiles: []
          });
          isInitialized.current = true;
        } else {
          // If player not found in map, place at 0,0 or some safe location
          gameState.current = {
            ...gameState.current,
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            oxygen: MAX_OXYGEN,
            maxOxygen: MAX_OXYGEN,
            lavaResist: MAX_LAVA_RESIST,
            maxLavaResist: MAX_LAVA_RESIST
          };
          setPlayer({
            ...gameState.current,
            projectiles: []
          });
          isInitialized.current = true; // allow loop to work even without start position
        }
      } else {
        // No entities layer  still start game at 0,0
        gameState.current = {
          ...gameState.current,
          x: 0,
          y: 0,
          vx: 0,
          vy: 0,
          oxygen: MAX_OXYGEN,
          maxOxygen: MAX_OXYGEN,
          lavaResist: MAX_LAVA_RESIST,
          maxLavaResist: MAX_LAVA_RESIST
        };
        setPlayer({
          ...gameState.current,
          projectiles: []
        });
        isInitialized.current = true;
      }
    }
  }, [mapData]);

  // Helper function for collisions (AABB Collision) with blocks (tile layer)  delegates to GameEngine/collision
  const checkCollision = (newX, newY, mapWidth, mapHeightParam) => {
    return collision_checkCollision(newX, newY, mapWidth, mapHeightParam, TILE_SIZE, tileData, registryItems, gameState.current.width, gameState.current.height);
  };

  // Simple point solidity check for projectiles  delegates to GameEngine/collision
  const isSolidAtPixel = (wx, wy, mapWidthTiles, mapHeightTiles) => {
    return collision_isSolidAtPixel(wx, wy, mapWidthTiles, mapHeightTiles, TILE_SIZE, tileData, registryItems);
  };

  // New: water presence check at a world pixel
  const isWaterAtPixel = (wx, wy, mapWidthTiles, mapHeightTiles) => {
    // Strict: Only treat WATER as buoyant/swimmable in vertical physics
    const liq = getLiquidAtPixel(wx, wy, mapWidthTiles, mapHeightTiles, TILE_SIZE, tileData, registryItems);
    return !!(liq && liq.type === 'water');
  };

  // Liquid sampling helper for update loop (AABB based)
  const sampleLiquid = (aabb, mapWidthTiles, mapHeightTiles) => {
    return sampleLiquidForAABB({
      x: aabb.x,
      y: aabb.y,
      width: aabb.width,
      height: aabb.height,
      TILE_SIZE: TILE_SIZE,
      mapWidth: mapWidthTiles,
      mapHeight: mapHeightTiles,
      tileData,
      registryItems
    });
  };

  // Item collection  moved to GameEngine/collectItem

  // Helper function: create new projectile  moved to separate module
  const spawnProjectile = (originX, originY, direction) => {
    return spawnProjectile_spawnProjectile({
      findItemById: findItemById,
      TILE_SIZE: TILE_SIZE,
      parseBool,
      projectilesRef,
      projectileIdRef,
      playShotSfx
    }, originX, originY, direction);
  };

  // Game Loop (delegated to GameEngine/updateFrame)
  const update = timestamp => {
    const ctx = {
      mapData,
      objectData,
      input,
      refs: {
        gameState,
        isInitialized,
        lastTimeRef,
        projectilesRef,
        shootCooldownRef,
        liquidDamageAccumulatorRef,
        oxygenDepleteAccRef,
        lavaDepleteAccRef
      },
      constants: {
        TILE_SIZE: TILE_SIZE,
        GRAVITY: GRAVITY,
        TERMINAL_VELOCITY: TERMINAL_VELOCITY,
        MOVE_SPEED: MOVE_SPEED,
        JUMP_FORCE: JUMP_FORCE
      },
      helpers: {
        checkCollision,
        isWaterAt: (wx, wy) => isWaterAtPixel(wx, wy, mapData?.meta?.width || mapData?.width || 20, mapData?.meta?.height || mapData?.height || 15),
        getLiquidSample: ({
          x,
          y,
          width,
          height,
          TILE_SIZE: TS,
          mapWidth,
          mapHeight
        }) => sampleLiquid({
          x,
          y,
          width,
          height
        }, mapData?.meta?.width || mapData?.width || 20, mapData?.meta?.height || mapData?.height || 15)
      },
      actions: {
        collectItem: (x, y, mapWidth, objectLayer) => collectItem({
          registryItems,
          TILE_SIZE: TILE_SIZE,
          MAX_HEALTH: MAX_HEALTH,
          playShotSfx,
          onStateUpdate,
          gameState
        }, x, y, mapWidth, objectLayer),
        checkInteractables: (x, y, mapWidth, objectLayer) => checkInteractables({
          registryItems,
          TILE_SIZE: TILE_SIZE,
          MAX_HEALTH: MAX_HEALTH,
          playShotSfx,
          onStateUpdate,
          gameState
        }, x, y, mapWidth, objectLayer),
        checkHazardDamage: (x, y, mapWidth, objectLayer, deltaMs) => checkHazardDamageWrapper(x, y, mapWidth, objectLayer, deltaMs),
        spawnProjectile: (originX, originY, direction) => spawnProjectile(originX, originY, direction),
        updateProjectiles: (deltaMs, mapWidth, mapHeight) => updateProjectiles({
          projectilesRef,
          TILE_SIZE: TILE_SIZE,
          isSolidAtPixel,
          findItemById: findItemById
        }, deltaMs, mapWidth, mapHeight),
        setPlayer: next => setPlayer(next),
        onGameOver
      }
    };
    const res = updateFrame(ctx, timestamp);
    if (res?.continue !== false) {
      requestRef.current = requestAnimationFrame(update);
    }
  };

  // Loop initialization / restart
  (0,react.useEffect)(() => {
    requestRef.current = requestAnimationFrame(update);
    return () => cancelAnimationFrame(requestRef.current);
  }, [mapData, tileData, objectData]); // Restart loop if map or objects change

  return player;
};
;// ./src/sections/chapters/game/GameHeader.jsx




const HeaderContainer = styled_components_browser_esm/* default */.Ay.div.withConfig({
  displayName: "GameHeader__HeaderContainer",
  componentId: "sc-1q33akp-0"
})(["position:absolute;top:0;left:0;width:100%;height:60px;background-color:rgba(0,0,0,0.3);display:flex;justify-content:space-between;align-items:center;padding:0 20px;box-sizing:border-box;z-index:1000;pointer-events:none;"]);
const AmmoDisplay = styled_components_browser_esm/* default */.Ay.div.withConfig({
  displayName: "GameHeader__AmmoDisplay",
  componentId: "sc-1q33akp-1"
})(["font-size:28px;font-weight:bold;color:rgba(255,200,50,0.95);text-shadow:2px 2px 4px rgba(0,0,0,0.8);font-family:monospace;pointer-events:none;"]);
const RightSection = styled_components_browser_esm/* default */.Ay.div.withConfig({
  displayName: "GameHeader__RightSection",
  componentId: "sc-1q33akp-2"
})(["display:flex;align-items:center;gap:12px;"]);
const HealthDisplay = styled_components_browser_esm/* default */.Ay.div.withConfig({
  displayName: "GameHeader__HealthDisplay",
  componentId: "sc-1q33akp-3"
})(["font-size:32px;font-weight:bold;color:rgba(255,50,50,0.9);text-shadow:2px 2px 4px rgba(0,0,0,0.8);font-family:monospace;pointer-events:none;"]);
const SoundButton = styled_components_browser_esm/* default */.Ay.button.withConfig({
  displayName: "GameHeader__SoundButton",
  componentId: "sc-1q33akp-4"
})(["padding:6px 10px;border-radius:4px;border:1px solid;font-size:12px;font-weight:700;cursor:pointer;margin-left:12px;user-select:none;pointer-events:auto;color:#fff;background-color:", ";border-color:", ";&:hover{opacity:0.9;}"], props => props.$enabled ? 'rgba(40, 140, 60, 0.9)' : 'rgba(160, 40, 40, 0.9)', props => props.$enabled ? '#2e7d32' : '#7f1d1d');
const GameHeader = ({
  health,
  ammo = 0,
  soundEnabled = false,
  onToggleSound
}) => {
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(HeaderContainer, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(AmmoDisplay, {
      children: ["\uD83D\uDD25 ", ammo || 0]
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)(RightSection, {
      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(HealthDisplay, {
        children: ["\u2764\uFE0F ", health]
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(SoundButton, {
        $enabled: soundEnabled,
        onClick: () => {
          if (typeof onToggleSound === 'function') onToggleSound();
          try {
            window.dispatchEvent(new CustomEvent('game-sound-user-gesture'));
          } catch {}
        },
        title: soundEnabled ? 'Sound ON' : 'Sound OFF',
        children: soundEnabled ? 'Sound ON' : 'Sound OFF'
      })]
    })]
  });
};
GameHeader.propTypes = {
  health: (prop_types_default()).number.isRequired,
  ammo: (prop_types_default()).number,
  soundEnabled: (prop_types_default()).bool,
  onToggleSound: (prop_types_default()).func.isRequired
};
/* harmony default export */ const game_GameHeader = (GameHeader);
;// ./src/commands/gameCommands.js
// Simple command registry for in-game terminal
// Each command: { name, description, handler(input, ctx) => string | void }

const commands = [];
const register = cmd => {
  if (!cmd || !cmd.name) return;
  commands.push(cmd);
};
const listCommands = () => commands.map(c => ({
  name: c.name,
  description: c.description
}));
const executeCommand = (input, context = {}) => {
  const raw = String(input || '').trim();
  if (!raw) return '';
  const [name, ...args] = raw.split(/\s+/);
  const cmd = commands.find(c => c.name.toLowerCase() === name.toLowerCase());
  if (!cmd) {
    return `Unknown command: ${name}. Type 'help' to list commands.`;
  }
  try {
    const res = cmd.handler({
      args,
      raw,
      context
    });
    return typeof res === 'string' ? res : '';
  } catch (e) {
    return `Error executing '${name}': ${e?.message || e}`;
  }
};

// Built-in: help
register({
  name: 'help',
  description: 'Show available commands',
  handler() {
    const list = listCommands().map(c => `- ${c.name}${c.description ? `: ${c.description}` : ''}`).join('\n');
    return list || 'No commands available.';
  }
});

// Built-in: clear
register({
  name: 'clear',
  description: 'Clear terminal output',
  handler() {
    // Signal to UI to clear output; UI can interpret special token
    try {
      window.dispatchEvent(new CustomEvent('game-terminal-clear'));
    } catch {}
    return '';
  }
});

// First requested command: settings
register({
  name: 'settings',
  description: "Open the draggable game settings window",
  handler() {
    try {
      window.dispatchEvent(new CustomEvent('game-open-settings'));
      // Also close terminal automatically when opening settings
      window.dispatchEvent(new CustomEvent('game-close-terminal'));
    } catch {}
    return 'Opening settings...';
  }
});
/* harmony default export */ const gameCommands = ({
  register,
  listCommands,
  executeCommand
});
;// ./src/sections/chapters/game/GameTerminal.jsx



const panelStyleBase = {
  position: 'fixed',
  left: 0,
  right: 0,
  bottom: 0,
  height: '220px',
  backgroundColor: 'rgba(10, 10, 10, 0.95)',
  color: '#d6d6d6',
  fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',
  fontSize: '12px',
  borderTop: '1px solid #333',
  boxShadow: '0 -6px 16px rgba(0,0,0,0.5)',
  display: 'flex',
  flexDirection: 'column',
  zIndex: 3000,
  transition: 'transform 160ms ease'
};
function GameTerminal() {
  const [open, setOpen] = (0,react.useState)(false);
  const [lines, setLines] = (0,react.useState)(["Type 'help' to list commands. Press ESC to close."]);
  const [input, setInput] = (0,react.useState)('');
  const scrollRef = (0,react.useRef)(null);
  const inputRef = (0,react.useRef)(null);
  const suppressUntilRef = (0,react.useRef)(0);
  const suppressActiveRef = (0,react.useRef)(false);

  // Toggle handler from global events
  (0,react.useEffect)(() => {
    const onToggle = () => setOpen(prev => !prev);
    const onClear = () => setLines([]);
    const onClose = () => setOpen(false);
    window.addEventListener('game-toggle-terminal', onToggle);
    window.addEventListener('game-terminal-clear', onClear);
    window.addEventListener('game-close-terminal', onClose);
    return () => {
      window.removeEventListener('game-toggle-terminal', onToggle);
      window.removeEventListener('game-terminal-clear', onClear);
      window.removeEventListener('game-close-terminal', onClose);
    };
  }, []);

  // Track open state globally so input hook can disable movement
  (0,react.useEffect)(() => {
    try {
      window.__GAME_TERMINAL_OPEN__ = open;
    } catch {}
    if (open) {
      // Clear any previous text and suppress initial keystrokes that were held during gameplay
      setInput('');
      try {
        suppressUntilRef.current = (typeof performance !== 'undefined' ? performance.now() : Date.now()) + 220;
      } catch {
        suppressUntilRef.current = Date.now() + 220;
      }
      setTimeout(() => inputRef.current && inputRef.current.focus(), 0);
    }
  }, [open]);

  // Close with ESC when focused
  (0,react.useEffect)(() => {
    const onKey = e => {
      if (!open) return;
      if (e.key === 'Escape') {
        setOpen(false);
      }
    };
    window.addEventListener('keydown', onKey);
    return () => window.removeEventListener('keydown', onKey);
  }, [open]);

  // Auto-scroll to bottom when lines change
  (0,react.useEffect)(() => {
    if (!scrollRef.current) return;
    scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
  }, [lines, open]);
  const onSubmit = e => {
    e.preventDefault();
    const value = input.trim();
    if (!value) return;
    setLines(prev => [...prev, `> ${value}`]);
    const res = executeCommand(value, {});
    if (res) setLines(prev => [...prev, res]);
    setInput('');
  };
  const style = {
    ...panelStyleBase,
    transform: open ? 'translateY(0)' : 'translateY(100%)'
  };
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    style: style,
    "aria-hidden": !open,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      style: {
        padding: '6px 8px',
        borderBottom: '1px solid #333',
        color: '#9cdcfe'
      },
      children: "In-Game Terminal \u2014 press T to toggle"
    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      ref: scrollRef,
      style: {
        flex: 1,
        overflowY: 'auto',
        padding: '8px 10px',
        whiteSpace: 'pre-wrap',
        lineHeight: 1.4
      },
      children: lines.map((l, i) => /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        style: {
          color: l.startsWith('>') ? '#dcdcaa' : '#d6d6d6'
        },
        children: l
      }, i))
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)("form", {
      onSubmit: onSubmit,
      style: {
        display: 'flex',
        gap: '6px',
        padding: '8px',
        borderTop: '1px solid #333'
      },
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {
        style: {
          color: '#6a9955'
        },
        children: "$"
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("input", {
        ref: inputRef,
        value: input,
        onKeyDown: e => {
          const now = typeof performance !== 'undefined' ? performance.now() : Date.now();
          if (now < (suppressUntilRef.current || 0) && e.key !== 'Escape') {
            if (typeof e.preventDefault === 'function') e.preventDefault();
            if (typeof e.stopPropagation === 'function') e.stopPropagation();
            return;
          }
        },
        onChange: e => setInput(e.target.value),
        placeholder: "Enter command...",
        style: {
          flex: 1,
          background: '#111',
          color: '#fff',
          border: '1px solid #333',
          padding: '6px 8px',
          borderRadius: '3px',
          outline: 'none'
        }
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("button", {
        type: "submit",
        style: {
          background: '#0e639c',
          color: '#fff',
          border: '1px solid #0b5c8a',
          padding: '6px 10px',
          borderRadius: '3px',
          cursor: 'pointer'
        },
        children: "Run"
      })]
    })]
  });
}
;// ./src/sections/chapters/game/GameSettings.jsx


// Simple draggable, minimizable settings window.
// Opens when the custom event 'game-open-settings' is dispatched (from terminal command `settings`).
// Renders above the game canvas but below the in-game terminal.

function GameSettings() {
  // Runtime-linked settings (live updates)
  const [activeTab, setActiveTab] = (0,react.useState)(() => {
    try {
      return localStorage.getItem('game_settings_tab') || 'Audio';
    } catch {}
    return 'Audio';
  });
  const [parallax, setParallax] = (0,react.useState)(() => {
    try {
      const g = window.__GAME_RUNTIME_SETTINGS__;
      if (g && typeof g.backgroundParallaxFactor === 'number') return g.backgroundParallaxFactor;
    } catch {}
    return 0.3;
  });
  const [rain, setRain] = (0,react.useState)(() => {
    try {
      const ls = localStorage.getItem('game_weather_rain');
      if (ls !== null) return Math.max(0, Math.min(100, parseInt(ls, 10) || 0));
      const g = window.__GAME_RUNTIME_SETTINGS__;
      if (g && typeof g.weatherRain === 'number') return Math.max(0, Math.min(100, g.weatherRain));
    } catch {}
    return 0;
  });
  const [snow, setSnow] = (0,react.useState)(() => {
    try {
      const ls = localStorage.getItem('game_weather_snow');
      if (ls !== null) return Math.max(0, Math.min(100, parseInt(ls, 10) || 0));
      const g = window.__GAME_RUNTIME_SETTINGS__;
      if (g && typeof g.weatherSnow === 'number') return Math.max(0, Math.min(100, g.weatherSnow));
    } catch {}
    return 0;
  });
  const [clouds, setClouds] = (0,react.useState)(() => {
    try {
      // New key first
      const lsNew = localStorage.getItem('game_weather_clouds');
      if (lsNew !== null) return Math.max(0, Math.min(100, parseInt(lsNew, 10) || 0));
      // Backward compatibility: read old fog key if exists
      const lsOld = localStorage.getItem('game_weather_fog');
      if (lsOld !== null) return Math.max(0, Math.min(100, parseInt(lsOld, 10) || 0));
      const g = window.__GAME_RUNTIME_SETTINGS__;
      // Prefer clouds but also accept legacy fog
      if (g && typeof g.weatherClouds === 'number') return Math.max(0, Math.min(100, g.weatherClouds));
      if (g && typeof g.weatherFog === 'number') return Math.max(0, Math.min(100, g.weatherFog));
    } catch {}
    return 0;
  });
  // New: Thunder (Lightning) intensity 0..100
  const [thunder, setThunder] = (0,react.useState)(() => {
    try {
      const ls = localStorage.getItem('game_weather_thunder');
      if (ls !== null) return Math.max(0, Math.min(100, parseInt(ls, 10) || 0));
      const g = window.__GAME_RUNTIME_SETTINGS__;
      if (g && typeof g.weatherThunder === 'number') return Math.max(0, Math.min(100, g.weatherThunder));
    } catch {}
    return 0;
  });
  // New: dedicated Fog density (0..100)
  const [fog, setFog] = (0,react.useState)(() => {
    try {
      const ls = localStorage.getItem('game_weather_fog');
      if (ls !== null) return Math.max(0, Math.min(100, parseInt(ls, 10) || 0));
      const g = window.__GAME_RUNTIME_SETTINGS__;
      if (g && typeof g.weatherFog === 'number') return Math.max(0, Math.min(100, g.weatherFog));
    } catch {}
    return 0;
  });
  // UI: Health bar visibility
  const [healthBarEnabled, setHealthBarEnabled] = (0,react.useState)(() => {
    try {
      const ls = localStorage.getItem('game_ui_healthbar');
      if (ls !== null) return ls !== '0';
      const g = window.__GAME_RUNTIME_SETTINGS__;
      if (g && typeof g.healthBarEnabled === 'boolean') return g.healthBarEnabled;
    } catch {}
    return true;
  });
  // UI: Oxygen/Lava bars visibility
  const [oxygenBarEnabled, setOxygenBarEnabled] = (0,react.useState)(() => {
    try {
      const ls = localStorage.getItem('game_ui_oxygenbar');
      if (ls !== null) return ls !== '0';
      const g = window.__GAME_RUNTIME_SETTINGS__;
      if (g && typeof g.oxygenBarEnabled === 'boolean') return g.oxygenBarEnabled;
    } catch {}
    return true;
  });
  const [lavaBarEnabled, setLavaBarEnabled] = (0,react.useState)(() => {
    try {
      const ls = localStorage.getItem('game_ui_lavabar');
      if (ls !== null) return ls !== '0';
      const g = window.__GAME_RUNTIME_SETTINGS__;
      if (g && typeof g.lavaBarEnabled === 'boolean') return g.lavaBarEnabled;
    } catch {}
    return true;
  });
  // FX toggles
  const [waterSplashesEnabled, setWaterSplashesEnabled] = (0,react.useState)(() => {
    try {
      const ls = localStorage.getItem('game_fx_water_splashes');
      if (ls !== null) return ls !== '0';
      const g = window.__GAME_RUNTIME_SETTINGS__;
      if (g && typeof g.waterSplashesEnabled === 'boolean') return g.waterSplashesEnabled;
    } catch {}
    return true;
  });
  const [lavaEmbersEnabled, setLavaEmbersEnabled] = (0,react.useState)(() => {
    try {
      const ls = localStorage.getItem('game_fx_lava_embers');
      if (ls !== null) return ls !== '0';
      const g = window.__GAME_RUNTIME_SETTINGS__;
      if (g && typeof g.lavaEmbersEnabled === 'boolean') return g.lavaEmbersEnabled;
    } catch {}
    return true;
  });
  const [open, setOpen] = (0,react.useState)(false);
  const [minimized, setMinimized] = (0,react.useState)(false);
  const [pos, setPos] = (0,react.useState)(() => {
    // Restore last position from localStorage if available
    try {
      const raw = localStorage.getItem('game_settings_pos');
      if (raw) return JSON.parse(raw);
    } catch {}
    return {
      left: 12,
      top: 64
    };
  });
  const [size, setSize] = (0,react.useState)(() => {
    try {
      const raw = localStorage.getItem('game_settings_size');
      if (raw) return JSON.parse(raw);
    } catch {}
    return {
      width: 300,
      height: 220
    };
  });
  const draggingRef = (0,react.useRef)({
    active: false,
    offsetX: 0,
    offsetY: 0
  });

  // Helper: clamp position so the window stays within viewport (with small margin)
  const clampPos = (p, sz, isMin) => {
    const margin = 12;
    const vw = (typeof window !== 'undefined' ? window.innerWidth : 0) || 0;
    const vh = (typeof window !== 'undefined' ? window.innerHeight : 0) || 0;
    const maxL = Math.max(0, vw - (sz?.width || 300) - margin);
    const maxT = Math.max(0, vh - (isMin ? 36 : sz?.height || 220) - margin);
    let left = Number(p?.left);
    let top = Number(p?.top);
    if (!Number.isFinite(left)) left = margin;
    if (!Number.isFinite(top)) top = margin;
    left = Math.max(0, Math.min(maxL, left));
    top = Math.max(0, Math.min(maxT, top));
    return {
      left,
      top
    };
  };

  // Restore minimized state
  (0,react.useEffect)(() => {
    try {
      const raw = localStorage.getItem('game_settings_min');
      if (raw) setMinimized(raw === '1');
    } catch {}
  }, []);

  // Open handler from global event
  (0,react.useEffect)(() => {
    const onOpen = () => {
      // Ensure the window will be visible even if saved pos was off-screen
      setPos(p => clampPos(p, size, false));
      setOpen(true);
      setMinimized(false);
      // Sync current values from global when opening
      try {
        const g = window.__GAME_RUNTIME_SETTINGS__ || {};
        if (typeof g.backgroundParallaxFactor === 'number') {
          setParallax(g.backgroundParallaxFactor);
        }
        if (typeof g.weatherRain === 'number') setRain(Math.max(0, Math.min(100, g.weatherRain)));
        if (typeof g.weatherSnow === 'number') setSnow(Math.max(0, Math.min(100, g.weatherSnow)));
        if (typeof g.weatherClouds === 'number') setClouds(Math.max(0, Math.min(100, g.weatherClouds)));
        if (typeof g.weatherFog === 'number') setFog(Math.max(0, Math.min(100, g.weatherFog)));
        if (typeof g.weatherThunder === 'number') setThunder(Math.max(0, Math.min(100, g.weatherThunder)));
        if (typeof g.healthBarEnabled === 'boolean') setHealthBarEnabled(!!g.healthBarEnabled);
        if (typeof g.oxygenBarEnabled === 'boolean') setOxygenBarEnabled(!!g.oxygenBarEnabled);
        if (typeof g.lavaBarEnabled === 'boolean') setLavaBarEnabled(!!g.lavaBarEnabled);
        if (typeof g.waterSplashesEnabled === 'boolean') setWaterSplashesEnabled(!!g.waterSplashesEnabled);
        if (typeof g.lavaEmbersEnabled === 'boolean') setLavaEmbersEnabled(!!g.lavaEmbersEnabled);
      } catch {}
      // Auto-close the in-game terminal when settings opens
      try {
        window.dispatchEvent(new CustomEvent('game-close-terminal'));
      } catch {}
    };
    window.addEventListener('game-open-settings', onOpen);
    return () => window.removeEventListener('game-open-settings', onOpen);
  }, []);

  // Persist position and size/minimized
  (0,react.useEffect)(() => {
    try {
      localStorage.setItem('game_settings_pos', JSON.stringify(pos));
    } catch {}
  }, [pos]);
  (0,react.useEffect)(() => {
    try {
      localStorage.setItem('game_settings_size', JSON.stringify(size));
    } catch {}
  }, [size]);
  (0,react.useEffect)(() => {
    try {
      localStorage.setItem('game_settings_min', minimized ? '1' : '0');
    } catch {}
  }, [minimized]);
  (0,react.useEffect)(() => {
    try {
      localStorage.setItem('game_settings_tab', String(activeTab));
    } catch {}
  }, [activeTab]);

  // Drag logic
  (0,react.useEffect)(() => {
    const onMove = e => {
      if (!draggingRef.current.active) return;
      e.preventDefault();
      const nx = e.clientX - draggingRef.current.offsetX;
      const ny = e.clientY - draggingRef.current.offsetY;
      const maxL = Math.max(0, (window.innerWidth || 0) - size.width - 6);
      const maxT = Math.max(0, (window.innerHeight || 0) - (minimized ? 36 : size.height) - 6);
      setPos({
        left: Math.max(0, Math.min(maxL, nx)),
        top: Math.max(0, Math.min(maxT, ny))
      });
    };
    const onUp = () => {
      draggingRef.current.active = false;
    };
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
    return () => {
      window.removeEventListener('mousemove', onMove);
      window.removeEventListener('mouseup', onUp);
    };
  }, [size.width, size.height, minimized]);

  // Re-clamp into viewport when window resizes while settings are open
  (0,react.useEffect)(() => {
    if (!open) return;
    const onResize = () => setPos(p => clampPos(p, size, minimized));
    window.addEventListener('resize', onResize);
    // Run once immediately to correct if needed
    onResize();
    return () => window.removeEventListener('resize', onResize);
  }, [open, size.width, size.height, minimized]);
  const onHeaderMouseDown = e => {
    draggingRef.current.active = true;
    draggingRef.current.offsetX = e.clientX - pos.left;
    draggingRef.current.offsetY = e.clientY - pos.top;
  };
  const onClose = () => setOpen(false);
  const onMinToggle = () => setMinimized(m => !m);
  const emitUpdate = patch => {
    try {
      window.dispatchEvent(new CustomEvent('game-settings-update', {
        detail: patch
      }));
      // Mirror into a global bag for components that want to read without listeners
      window.__GAME_RUNTIME_SETTINGS__ = {
        ...(window.__GAME_RUNTIME_SETTINGS__ || {}),
        ...patch
      };
    } catch {}
  };
  const onResizeMouseDown = e => {
    // Simple bottom-right resize drag
    e.preventDefault();
    const startX = e.clientX;
    const startY = e.clientY;
    const startW = size.width;
    const startH = size.height;
    const move = ev => {
      const dw = ev.clientX - startX;
      const dh = ev.clientY - startY;
      const nw = Math.max(220, startW + dw);
      const nh = Math.max(140, startH + dh);
      setSize({
        width: nw,
        height: nh
      });
    };
    const up = () => {
      window.removeEventListener('mousemove', move);
      window.removeEventListener('mouseup', up);
    };
    window.addEventListener('mousemove', move);
    window.addEventListener('mouseup', up);
  };
  if (!open) return null;
  const panelStyle = {
    position: 'fixed',
    left: pos.left,
    top: pos.top,
    width: size.width,
    height: minimized ? 36 : size.height,
    background: 'rgba(20,20,20,0.96)',
    color: '#eaeaea',
    border: '1px solid #2a2a2a',
    borderRadius: 6,
    boxShadow: '0 8px 24px rgba(0,0,0,0.6)',
    zIndex: 2600,
    // below terminal (3000), above canvas/HUD
    display: 'flex',
    flexDirection: 'column',
    userSelect: draggingRef.current.active ? 'none' : 'auto',
    overflow: 'hidden'
  };
  const headerStyle = {
    cursor: 'move',
    background: 'linear-gradient(180deg, #2a2a2a, #1c1c1c)',
    padding: '6px 8px',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'space-between',
    borderBottom: '1px solid #333',
    fontSize: 12
  };
  const contentStyle = {
    flex: 1,
    display: minimized ? 'none' : 'block',
    padding: 10,
    overflow: 'auto',
    background: 'rgba(10,10,10,0.4)'
  };
  const buttonStyle = {
    background: '#0e639c',
    color: '#fff',
    border: '1px solid #0b5c8a',
    padding: '4px 8px',
    borderRadius: 4,
    fontSize: 11,
    cursor: 'pointer',
    marginLeft: 6
  };
  const tabsBarStyle = {
    display: minimized ? 'none' : 'flex',
    alignItems: 'center',
    gap: 6,
    padding: '6px 8px',
    borderBottom: '1px solid #2a2a2a',
    background: 'rgba(0,0,0,0.25)',
    whiteSpace: 'nowrap',
    overflowX: 'auto'
  };
  const tabBtnStyle = tab => ({
    background: activeTab === tab ? '#1e1e1e' : 'transparent',
    color: activeTab === tab ? '#9cdcfe' : '#ddd',
    border: activeTab === tab ? '1px solid #3a3a3a' : '1px solid transparent',
    padding: '4px 10px',
    borderRadius: 4,
    fontSize: 12,
    cursor: 'pointer'
  });
  const renderAudio = () => /*#__PURE__*/(0,jsx_runtime.jsxs)("section", {
    style: {
      marginBottom: 10
    },
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      style: {
        fontSize: 12,
        marginBottom: 6,
        color: '#d6d6d6'
      },
      children: "Audio"
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        gap: 8
      },
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("label", {
        style: {
          fontSize: 12,
          width: 120
        },
        children: "Master Volume"
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("input", {
        type: "range",
        min: "0",
        max: "1",
        step: "0.01",
        defaultValue: 0.7
      })]
    })]
  });
  const renderGraphics = () => /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("section", {
      style: {
        marginBottom: 10
      },
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        style: {
          fontSize: 12,
          marginBottom: 6,
          color: '#d6d6d6'
        },
        children: "Graphics"
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          gap: 8,
          marginBottom: 6
        },
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("label", {
          style: {
            fontSize: 12,
            width: 120
          },
          children: "Parallax Factor"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("input", {
          type: "range",
          min: "0",
          max: "1",
          step: "0.05",
          value: Number.isFinite(parallax) ? parallax : 0.3,
          onChange: e => {
            const v = parseFloat(e.target.value);
            setParallax(v);
            emitUpdate({
              backgroundParallaxFactor: v
            });
          }
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
          style: {
            fontSize: 12,
            width: 40,
            textAlign: 'right'
          },
          children: (Number.isFinite(parallax) ? parallax : 0.3).toFixed(2)
        })]
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          gap: 8
        },
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("label", {
          style: {
            fontSize: 12,
            width: 120
          },
          children: "VSync"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("input", {
          type: "checkbox",
          defaultChecked: true
        })]
      })]
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)("section", {
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        style: {
          fontSize: 12,
          marginBottom: 6,
          color: '#d6d6d6'
        },
        children: "Gameplay"
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          gap: 8
        },
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("label", {
          style: {
            fontSize: 12,
            width: 120
          },
          children: "Invert Jump (W)"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("input", {
          type: "checkbox"
        })]
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          gap: 8,
          marginTop: 6
        },
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("label", {
          style: {
            fontSize: 12,
            width: 120
          },
          children: "Show Health Bar"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("input", {
          type: "checkbox",
          checked: !!healthBarEnabled,
          onChange: e => {
            const v = !!e.target.checked;
            setHealthBarEnabled(v);
            try {
              localStorage.setItem('game_ui_healthbar', v ? '1' : '0');
            } catch {}
            emitUpdate({
              healthBarEnabled: v
            });
          }
        })]
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          gap: 8,
          marginTop: 6
        },
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("label", {
          style: {
            fontSize: 12,
            width: 120
          },
          children: "Show Oxygen Bar"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("input", {
          type: "checkbox",
          checked: !!oxygenBarEnabled,
          onChange: e => {
            const v = !!e.target.checked;
            setOxygenBarEnabled(v);
            try {
              localStorage.setItem('game_ui_oxygenbar', v ? '1' : '0');
            } catch {}
            emitUpdate({
              oxygenBarEnabled: v
            });
          }
        })]
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          gap: 8,
          marginTop: 6
        },
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("label", {
          style: {
            fontSize: 12,
            width: 120
          },
          children: "Show Lava Bar"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("input", {
          type: "checkbox",
          checked: !!lavaBarEnabled,
          onChange: e => {
            const v = !!e.target.checked;
            setLavaBarEnabled(v);
            try {
              localStorage.setItem('game_ui_lavabar', v ? '1' : '0');
            } catch {}
            emitUpdate({
              lavaBarEnabled: v
            });
          }
        })]
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          gap: 8,
          marginTop: 6
        },
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("label", {
          style: {
            fontSize: 12,
            width: 120
          },
          children: "Water Splashes"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("input", {
          type: "checkbox",
          checked: !!waterSplashesEnabled,
          onChange: e => {
            const v = !!e.target.checked;
            setWaterSplashesEnabled(v);
            try {
              localStorage.setItem('game_fx_water_splashes', v ? '1' : '0');
            } catch {}
            emitUpdate({
              waterSplashesEnabled: v
            });
          }
        })]
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          gap: 8,
          marginTop: 6
        },
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("label", {
          style: {
            fontSize: 12,
            width: 120
          },
          children: "Lava Embers"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("input", {
          type: "checkbox",
          checked: !!lavaEmbersEnabled,
          onChange: e => {
            const v = !!e.target.checked;
            setLavaEmbersEnabled(v);
            try {
              localStorage.setItem('game_fx_lava_embers', v ? '1' : '0');
            } catch {}
            emitUpdate({
              lavaEmbersEnabled: v
            });
          }
        })]
      })]
    })]
  });
  const renderWeather = () => /*#__PURE__*/(0,jsx_runtime.jsxs)("section", {
    style: {
      marginBottom: 10
    },
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      style: {
        fontSize: 12,
        marginBottom: 6,
        color: '#d6d6d6'
      },
      children: "Weather"
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        gap: 8,
        marginBottom: 6
      },
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("label", {
        style: {
          fontSize: 12,
          width: 120
        },
        children: "Lietus (Rain)"
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("input", {
        type: "range",
        min: "0",
        max: "100",
        step: "1",
        value: Number.isFinite(rain) ? rain : 0,
        onChange: e => {
          const v = Math.max(0, Math.min(100, parseInt(e.target.value, 10) || 0));
          setRain(v);
          try {
            localStorage.setItem('game_weather_rain', String(v));
          } catch {}
          emitUpdate({
            weatherRain: v
          });
        }
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
        style: {
          fontSize: 12,
          width: 34,
          textAlign: 'right'
        },
        children: Number.isFinite(rain) ? rain : 0
      })]
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        gap: 8,
        marginBottom: 6
      },
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("label", {
        style: {
          fontSize: 12,
          width: 120
        },
        children: "Sniegs (Snow)"
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("input", {
        type: "range",
        min: "0",
        max: "100",
        step: "1",
        value: Number.isFinite(snow) ? snow : 0,
        onChange: e => {
          const v = Math.max(0, Math.min(100, parseInt(e.target.value, 10) || 0));
          setSnow(v);
          try {
            localStorage.setItem('game_weather_snow', String(v));
          } catch {}
          emitUpdate({
            weatherSnow: v
          });
        }
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
        style: {
          fontSize: 12,
          width: 34,
          textAlign: 'right'
        },
        children: Number.isFinite(snow) ? snow : 0
      })]
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        gap: 8,
        marginBottom: 6
      },
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("label", {
        style: {
          fontSize: 12,
          width: 120
        },
        children: "Migla (Fog)"
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("input", {
        type: "range",
        min: "0",
        max: "100",
        step: "1",
        value: Number.isFinite(fog) ? fog : 0,
        onChange: e => {
          const v = Math.max(0, Math.min(100, parseInt(e.target.value, 10) || 0));
          setFog(v);
          try {
            localStorage.setItem('game_weather_fog', String(v));
          } catch {}
          emitUpdate({
            weatherFog: v
          });
        }
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
        style: {
          fontSize: 12,
          width: 34,
          textAlign: 'right'
        },
        children: Number.isFinite(fog) ? fog : 0
      })]
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        gap: 8,
        marginBottom: 6
      },
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("label", {
        style: {
          fontSize: 12,
          width: 120
        },
        children: "Zibens (Thunder)"
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("input", {
        type: "range",
        min: "0",
        max: "100",
        step: "1",
        value: Number.isFinite(thunder) ? thunder : 0,
        onChange: e => {
          const v = Math.max(0, Math.min(100, parseInt(e.target.value, 10) || 0));
          setThunder(v);
          try {
            localStorage.setItem('game_weather_thunder', String(v));
          } catch {}
          emitUpdate({
            weatherThunder: v
          });
        }
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
        style: {
          fontSize: 12,
          width: 34,
          textAlign: 'right'
        },
        children: Number.isFinite(thunder) ? thunder : 0
      })]
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        gap: 8
      },
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("label", {
        style: {
          fontSize: 12,
          width: 120
        },
        children: "M\u0101ko\u0146i (Clouds)"
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("input", {
        type: "range",
        min: "0",
        max: "100",
        step: "1",
        value: Number.isFinite(clouds) ? clouds : 0,
        onChange: e => {
          const v = Math.max(0, Math.min(100, parseInt(e.target.value, 10) || 0));
          setClouds(v);
          try {
            localStorage.setItem('game_weather_clouds', String(v));
          } catch {}
          emitUpdate({
            weatherClouds: v
          });
        }
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
        style: {
          fontSize: 12,
          width: 34,
          textAlign: 'right'
        },
        children: Number.isFinite(clouds) ? clouds : 0
      })]
    })]
  });
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    style: panelStyle,
    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      style: headerStyle,
      onMouseDown: onHeaderMouseDown,
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        style: {
          fontWeight: 600,
          color: '#9cdcfe'
        },
        children: "Game Settings"
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        style: {
          display: 'flex',
          alignItems: 'center'
        },
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("button", {
          onClick: onMinToggle,
          title: minimized ? 'Expand' : 'Minimize',
          style: buttonStyle,
          children: minimized ? '' : ''
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("button", {
          onClick: onClose,
          title: "Close",
          style: {
            ...buttonStyle,
            background: '#a33',
            borderColor: '#822'
          },
          children: "\u2715"
        })]
      })]
    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      style: tabsBarStyle,
      children: ['Audio', 'Graphics', 'Weather'].map(t => /*#__PURE__*/(0,jsx_runtime.jsx)("button", {
        style: tabBtnStyle(t),
        onClick: () => setActiveTab(t),
        children: t
      }, t))
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      style: contentStyle,
      children: [activeTab === 'Audio' && renderAudio(), activeTab === 'Graphics' && renderGraphics(), activeTab === 'Weather' && renderWeather()]
    }), !minimized && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      onMouseDown: onResizeMouseDown,
      title: "Resize",
      style: {
        position: 'absolute',
        right: 0,
        bottom: 0,
        width: 16,
        height: 16,
        cursor: 'nwse-resize',
        background: 'linear-gradient(135deg, transparent 0, transparent 50%, #666 50%, #666 100%)'
      }
    })]
  });
}
;// ./src/utilities/BackgroundMusicPlayer.jsx


// Lightweight background music player that resolves a meta path like
// "/sound/background/track.ogg" to a build URL via require.context and
// plays/pauses a looping HTMLAudioElement.
// Props:
// - metaPath: string | null  stored in map meta (e.g., "/sound/background/foo.ogg")
// - enabled: boolean  global sound toggle
// - volume: number (0..1)
function BackgroundMusicPlayer({
  metaPath,
  enabled = false,
  volume = 0.6
}) {
  const audioRef = (0,react.useRef)(null);
  const currentSrcRef = (0,react.useRef)(null);

  // Resolve ogg assets from src/assets/sound/background
  let musicContext = null;
  try {
    // utilities -> ../assets/sound/background
    musicContext = __webpack_require__(1032);
  } catch (e) {
    musicContext = null;
  }
  const resolveUrl = path => {
    if (!path) return null;
    const name = path.split('/').pop();
    if (!name) return null;
    if (musicContext) {
      try {
        const mod = musicContext(`./${name}`);
        return mod.default || mod;
      } catch (e) {
        console.warn(`Background music not found: ${name}`);
      }
    }
    return null;
  };
  const cleanup = () => {
    try {
      if (audioRef.current) {
        audioRef.current.pause();
        audioRef.current.src = '';
        audioRef.current = null;
        currentSrcRef.current = null;
      }
    } catch {}
  };

  // Build/rebuild audio element when metaPath changes
  (0,react.useEffect)(() => {
    const url = resolveUrl(metaPath);

    // If unchanged, just update enabled/volume in next effect
    if (url && currentSrcRef.current === url && audioRef.current) {
      return () => {};
    }

    // Rebuild
    cleanup();
    if (!url) return () => {};
    const audio = new Audio(url);
    audio.loop = true;
    audio.volume = Math.max(0, Math.min(1, Number(volume) || 0));
    audioRef.current = audio;
    currentSrcRef.current = url;

    // Try to pre-play if enabled (may be blocked by autoplay policy)
    if (enabled) {
      audio.play().catch(() => {
        // Will try again on explicit user gesture via custom event
      });
    }
    return () => cleanup();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [metaPath]);

  // React to enabled/volume changes
  (0,react.useEffect)(() => {
    const audio = audioRef.current;
    if (!audio) return;
    audio.volume = Math.max(0, Math.min(1, Number(volume) || 0));
    if (enabled) {
      // Attempt to play; may require user gesture
      audio.play().catch(() => {
        // try again on gesture event
      });
    } else {
      try {
        audio.pause();
      } catch {}
    }
  }, [enabled, volume]);

  // Listen for a gesture-driven event to force playback immediately in handler
  (0,react.useEffect)(() => {
    const onGesture = () => {
      const audio = audioRef.current;
      if (audio && enabled) {
        audio.play().catch(() => {});
      }
    };
    const onToggle = e => {
      const val = !!(e && e.detail && e.detail.enabled);
      const audio = audioRef.current;
      if (!audio) return;
      if (val) {
        audio.play().catch(() => {});
      } else {
        try {
          audio.pause();
        } catch {}
      }
    };
    window.addEventListener('game-sound-user-gesture', onGesture);
    window.addEventListener('game-sound-toggle', onToggle);
    return () => {
      window.removeEventListener('game-sound-user-gesture', onGesture);
      window.removeEventListener('game-sound-toggle', onToggle);
    };
  }, [enabled]);
  return null;
}
;// ./src/assets/maps/Temp_01.json
const Temp_01_namespaceObject = /*#__PURE__*/JSON.parse('{"meta":{"width":20,"height":15,"tileSize":32,"version":"1.0","name":"Temp_01","author":"VoltG3","date_map_created_at":"2025-11-25T16:30:58.740Z","date_map_last_updated":"2025-11-25T16:30:58.740Z"},"statistics":{"total_tiles":300,"filled_tiles":60,"total_objects":1,"total_items":0},"layers":[{"type":"tile","name":"background","data":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001"]},{"type":"object","name":"entities","data":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"player_default_100",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}]}');
;// ./src/assets/maps/Temp_02.json
const Temp_02_namespaceObject = /*#__PURE__*/JSON.parse('{"meta":{"width":20,"height":15,"tileSize":32,"version":"1.0","name":"Temp_02","author":"VoltG3","date_map_created_at":"2025-11-25T16:32:02.703Z","date_map_last_updated":"2025-11-25T16:32:02.703Z"},"statistics":{"total_tiles":300,"filled_tiles":64,"total_objects":2,"total_items":1},"layers":[{"type":"tile","name":"background","data":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"grass_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","grass_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","grass_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","grass_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","grass_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","grass_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","grass_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001",null,null,"grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001"]},{"type":"object","name":"entities","data":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"player_default_100",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"hertz_item",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}]}');
;// ./src/assets/maps/Temp_03.json
const Temp_03_namespaceObject = /*#__PURE__*/JSON.parse('{"meta":{"width":20,"height":15,"tileSize":32,"version":"1.0","name":"Temp_03","author":"VoltG3","date_map_created_at":"2025-11-25T16:33:05.295Z","date_map_last_updated":"2025-11-25T16:33:05.295Z"},"statistics":{"total_tiles":300,"filled_tiles":71,"total_objects":3,"total_items":2},"layers":[{"type":"tile","name":"background","data":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"grass_block_0001","grass_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","grass_block_0001","grass_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001",null,null,null,null,null,"grass_block_0001",null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,"dirt_block_0001",null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001"]},{"type":"object","name":"entities","data":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"player_default_100",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"hertz_item",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"hertz_item",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}]}');
;// ./src/assets/maps/Temp_04.json
const Temp_04_namespaceObject = /*#__PURE__*/JSON.parse('{"meta":{"width":100,"height":25,"tileSize":32,"version":"1.0","name":"Temp_04","author":"VoltG3","date_map_created_at":"2025-11-25T20:03:03.124Z","date_map_last_updated":"2025-11-29T19:57:55.029Z"},"statistics":{"total_tiles":2500,"filled_tiles":452,"total_objects":10,"total_items":6},"layers":[{"type":"tile","name":"background","data":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001"]},{"type":"object","name":"entities","data":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"player",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"hertz_item","hertz_item","hertz_item",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"bushes_001",null,null,"hertz_item","hertz_item","hertz_item",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"bushes_001","bushes_001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}]}');
;// ./src/assets/maps/Temp_05.json
const Temp_05_namespaceObject = /*#__PURE__*/JSON.parse('{"meta":{"width":124,"height":42,"tileSize":32,"version":"1.0","name":"Temp_05","author":"VoltG3","date_map_created_at":"2025-11-29T21:48:36.335Z","date_map_last_updated":"2025-11-29T21:48:36.335Z","backgroundImage":"/assets/background/seamless_04.jpg","backgroundParallaxFactor":0.1},"statistics":{"total_tiles":5208,"filled_tiles":648,"total_objects":2,"total_items":1},"layers":[{"type":"tile","name":"background","data":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001"]},{"type":"object","name":"entities","data":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"player",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"hertz_item",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}]}');
;// ./src/assets/maps/Temp_06.json
const Temp_06_namespaceObject = /*#__PURE__*/JSON.parse('{"meta":{"width":107,"height":33,"tileSize":32,"version":"1.0","name":"New Map","author":"Anonymous","date_map_created_at":"2025-11-30T21:57:01.134Z","date_map_last_updated":"2025-12-01T08:16:37.484Z","backgroundImage":"/assets/background/seamless_01.jpg","backgroundColor":null,"backgroundParallaxFactor":0.3,"backgroundMusic":"/assets/sound/background/170515__rolandasb__forest_ambient_01_loop.ogg"},"statistics":{"total_tiles":3531,"filled_tiles":524,"total_objects":6,"total_items":4},"layers":[{"type":"tile","name":"background","data":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0002","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001",null,null,null,null,null,null,null,null,"sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0002","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001",null,"sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001",null,null,null,"sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001",null,null,null,null,"sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001",null,"sand_block_0001","sand_block_0001","sand_block_0002","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001",null,"sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0002","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001",null,"sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0002","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0002","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0002","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001"]},{"type":"object","name":"entities","data":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"player",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"hertz_item","hertz_item","hertz_item","hertz_item",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"bushes_001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}]}');
;// ./src/assets/maps/Temp_07.json
const Temp_07_namespaceObject = /*#__PURE__*/JSON.parse('{"meta":{"width":165,"height":27,"tileSize":32,"version":"1.0","name":"Temp_07","author":"Oskar","date_map_created_at":"2025-12-03T15:53:54.327Z","date_map_last_updated":"2025-12-10T16:54:38.212Z","backgroundImage":"/assets/background/seamless_06.jpg","backgroundColor":null,"backgroundParallaxFactor":0.2,"backgroundMusic":"/assets/assets/sound/background/830253__nicktayloe__afternoon-woods-in-october-midwest-us-loop.ogg"},"statistics":{"total_tiles":4455,"filled_tiles":501,"total_objects":27,"total_items":10},"layers":[{"type":"tile","name":"background","data":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"grass_block_0001","lava_block","lava_block","grass_block_0001","grass_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","dirt_block_0001","lava_block","lava_block","dirt_block_0001","dirt_block_0001","grass_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001",null,null,null,null,null,null,null,null,null,null,null,"grass_block_0001","grass_block_0001","water_block","water_block","water_block","water_block","grass_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"grass_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001",null,null,null,null,"grass_block_0001","grass_block_0001","dirt_block_0001","dirt_block_0001","water_block","water_block","water_block","water_block","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"grass_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001",null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"grass_block_0001","grass_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","grass_block_0001","grass_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","grass_block_0001","diorite_block","diorite_block","diorite_block","diorite_block","grass_block_0001","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","diorite_block","diorite_block","diorite_block","diorite_block","dirt_block_0001","dirt_block_0001","dirt_block_0001","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","grass_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","diorite_block","diorite_block","diorite_block","diorite_block","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","water_block","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","sand_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001","dirt_block_0001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"type":"object","name":"entities","data":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"fireball_ammo",null,null,null,null,null,null,null,null,null,null,null,null,"bushes_001","bushes_001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"bushes_001","bushes_001","bushes_001","player",null,"hertz_item",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"hertz_item",null,null,null,null,null,null,"bushes_001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"bushes_001","bushes_001",null,"fireball_ammo",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"fireball_ammo","fireball_ammo","fireball_ammo","fireball_ammo",null,null,null,null,null,null,"hertz_item",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"bushes_001","bushes_001","bushes_001",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"fireball_ammo",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"berry_bush_01","berry_bush_01","berry_bush_01","berry_bush_01","berry_bush_01",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}]}');
;// ./src/sections/chapters/game.jsx















// Import maps (static files usually need to be imported or fetched in React/Webpack)








// Simulate file list from folder

const BUILT_IN_MAPS = [Temp_01_namespaceObject, Temp_02_namespaceObject, Temp_03_namespaceObject, Temp_04_namespaceObject, Temp_05_namespaceObject, Temp_06_namespaceObject, Temp_07_namespaceObject];

// Styled Components
const GameContainer = styled_components_browser_esm/* default */.Ay.div.withConfig({
  displayName: "game__GameContainer",
  componentId: "sc-2er1vf-0"
})(["position:relative;height:100%;overflow:hidden;background-color:#333;"]);
const ModalOverlay = styled_components_browser_esm/* default */.Ay.div.withConfig({
  displayName: "game__ModalOverlay",
  componentId: "sc-2er1vf-1"
})(["position:absolute;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,0.6);z-index:1000;display:flex;align-items:center;justify-content:center;backdrop-filter:blur(2px);"]);
const ModalContent = styled_components_browser_esm/* default */.Ay.div.withConfig({
  displayName: "game__ModalContent",
  componentId: "sc-2er1vf-2"
})(["background-color:#fff;padding:20px;border-radius:8px;width:500px;max-height:80%;overflow-y:auto;box-shadow:0 10px 25px rgba(0,0,0,0.5);display:flex;flex-direction:column;gap:15px;"]);
const ModalTitle = styled_components_browser_esm/* default */.Ay.h2.withConfig({
  displayName: "game__ModalTitle",
  componentId: "sc-2er1vf-3"
})(["margin:0;border-bottom:2px solid #eee;padding-bottom:10px;"]);
const MapList = styled_components_browser_esm/* default */.Ay.div.withConfig({
  displayName: "game__MapList",
  componentId: "sc-2er1vf-4"
})(["display:flex;flex-direction:column;gap:10px;"]);
const MapCard = styled_components_browser_esm/* default */.Ay.div.withConfig({
  displayName: "game__MapCard",
  componentId: "sc-2er1vf-5"
})(["border:1px solid #ddd;border-radius:6px;padding:10px;cursor:pointer;background-color:#f9f9f9;display:flex;justify-content:space-between;align-items:center;&:hover{background-color:#e8e8e8;}"]);
const MapTitle = styled_components_browser_esm/* default */.Ay.div.withConfig({
  displayName: "game__MapTitle",
  componentId: "sc-2er1vf-6"
})(["font-weight:bold;font-size:16px;"]);
const MapAuthor = styled_components_browser_esm/* default */.Ay.div.withConfig({
  displayName: "game__MapAuthor",
  componentId: "sc-2er1vf-7"
})(["font-size:12px;color:#666;"]);
const MapInfo = styled_components_browser_esm/* default */.Ay.div.withConfig({
  displayName: "game__MapInfo",
  componentId: "sc-2er1vf-8"
})(["text-align:right;font-size:11px;color:#555;"]);
const ModalDivider = styled_components_browser_esm/* default */.Ay.div.withConfig({
  displayName: "game__ModalDivider",
  componentId: "sc-2er1vf-9"
})(["border-top:2px solid #eee;padding-top:15px;margin-top:10px;"]);
const FileUploadLabel = styled_components_browser_esm/* default */.Ay.label.withConfig({
  displayName: "game__FileUploadLabel",
  componentId: "sc-2er1vf-10"
})(["padding:8px 16px;background-color:#2196F3;color:white;border:none;border-radius:4px;cursor:pointer;font-weight:bold;text-align:center;display:inline-block;width:100%;box-sizing:border-box;&:hover{background-color:#1976D2;}"]);
const HiddenFileInput = styled_components_browser_esm/* default */.Ay.input.withConfig({
  displayName: "game__HiddenFileInput",
  componentId: "sc-2er1vf-11"
})(["display:none;"]);
const Viewport = styled_components_browser_esm/* default */.Ay.div.withConfig({
  displayName: "game__Viewport",
  componentId: "sc-2er1vf-12"
})(["height:100%;display:", ";align-items:", ";justify-content:", ";overflow:auto;filter:", ";pointer-events:", ";transition:filter 0.3s ease;"], props => props.$centered ? 'flex' : 'block', props => props.$centered ? 'center' : 'stretch', props => props.$centered ? 'center' : 'flex-start', props => props.$blurred ? 'blur(5px)' : 'none', props => props.$blurred ? 'none' : 'auto');
const GameCanvas = styled_components_browser_esm/* default */.Ay.div.withConfig({
  displayName: "game__GameCanvas",
  componentId: "sc-2er1vf-13"
})(["position:relative;width:", "px;height:", "px;border:5px solid #222;box-shadow:0 0 20px rgba(0,0,0,0.5);background-color:#111;"], props => props.$width, props => props.$height);
const PlaceholderMessage = styled_components_browser_esm/* default */.Ay.div.withConfig({
  displayName: "game__PlaceholderMessage",
  componentId: "sc-2er1vf-14"
})(["color:#777;font-size:24px;"]);
function Game() {
  const dispatch = (0,react_redux/* useDispatch */.wA)();
  const viewportRef = (0,react.useRef)(null);

  // Redux state
  const {
    activeMapData,
    tileMapData,
    objectMapData,
    objectTextureIndices,
    mapWidth,
    mapHeight
  } = (0,react_redux/* useSelector */.d4)(state => state.game);
  const {
    isMapModalOpen,
    cameraScrollX,
    shouldCenterMap
  } = (0,react_redux/* useSelector */.d4)(state => state.ui);
  const {
    sound
  } = (0,react_redux/* useSelector */.d4)(state => state.settings);
  const soundEnabled = sound.enabled;

  // Runtime settings that can be changed from GameSettings on the fly
  const [runtimeSettings, setRuntimeSettings] = (0,react.useState)({});

  // Registry
  const registryItems = getRegistry() || [];
  const handleGameOver = () => {
    // Reload current map using Redux
    if (activeMapData) {
      console.log("Game Over! Reloading map...");
      loadMapData({
        ...activeMapData
      });
    }
  };

  // NEW: Function for removing items and updating interactables - now uses Redux
  const handleStateUpdate = (action, payload) => {
    if (action === 'collectItem') {
      const indexToRemove = payload;
      dispatch(removeObjectAtIndex(indexToRemove));
    } else if (action === 'interactable') {
      const index = payload;
      // Switch interactable to "used" variant by changing ID
      // e.g., berry_bush_01 -> berry_bush_01_used
      const currentId = objectMapData[index];
      if (currentId) {
        dispatch(updateObjectAtIndex({
          index,
          newId: currentId + '_used'
        }));
      }
    }
  };

  // We no longer need 'engineMapData' with layers, as we pass objectMapData separately.
  // So we pass the original 'activeMapData' as first argument (for initialization to work correctly and not reset),
  // and 'objectMapData' as third argument for item checking.

  // --- START ENGINE ---
  // Engine returns player coordinates and state
  // objectMapData contains dynamic data (removed items)
  const playerState = useGameEngine(activeMapData, tileMapData, objectMapData, registryItems, handleGameOver, handleStateUpdate);

  // Iegstam spltja vizulo izskatu (Texture)
  const playerVisuals = (0,react.useMemo)(() => {
    // eit vartu bt loika, kas maina tekstru atkarb no playerState.direction vai playerState.vx
    // Pagaidm paemam noklusto
    return findItemById("player_default_100") || findItemById("player");
  }, []);
  // --- END ENGINE ---

  // Determine if the map fits entirely in the viewport; if so, center it
  (0,react.useEffect)(() => {
    const vp = viewportRef.current;
    if (!vp) return;
    const recalc = () => {
      const vw = vp.clientWidth || 0;
      const vh = vp.clientHeight || 0;
      const cw = mapWidth * 32;
      const ch = mapHeight * 32;
      const fits = cw <= vw && ch <= vh;
      dispatch(setShouldCenterMap(fits));
      if (fits) {
        // Ensure no residual scroll when centered
        if (vp.scrollLeft || vp.scrollTop) {
          vp.scrollTo({
            left: 0,
            top: 0,
            behavior: 'auto'
          });
        }
      }
    };
    recalc();
    window.addEventListener('resize', recalc);
    return () => window.removeEventListener('resize', recalc);
  }, [mapWidth, mapHeight, isMapModalOpen, dispatch]);

  // Camera follow with horizontal dead-zone on large maps (disabled when map is centered)
  (0,react.useEffect)(() => {
    const vp = viewportRef.current;
    if (!vp || !activeMapData || isMapModalOpen || shouldCenterMap) return;
    const vw = vp.clientWidth || 0;
    const contentWidth = mapWidth * 32;
    const maxScrollLeft = Math.max(0, contentWidth - vw);
    const px = Number(playerState?.x) || 0;
    const pw = Number(playerState?.width) || 32;
    const playerCenter = px + pw / 2;
    const currentLeft = vp.scrollLeft || 0;
    const deadLeft = currentLeft + vw * 0.3;
    const deadRight = currentLeft + vw * 0.7;
    let targetLeft = currentLeft;
    if (playerCenter > deadRight) {
      targetLeft = playerCenter - vw * 0.7;
    } else if (playerCenter < deadLeft) {
      targetLeft = playerCenter - vw * 0.3;
    }
    targetLeft = Math.max(0, Math.min(maxScrollLeft, targetLeft));
    if (Math.abs(targetLeft - currentLeft) > 0.5) {
      vp.scrollTo({
        left: targetLeft,
        top: 0,
        behavior: 'auto'
      });
    }
  }, [playerState, activeMapData, isMapModalOpen, mapWidth, shouldCenterMap]);

  // Listen for runtime settings updates from GameSettings (live apply)
  (0,react.useEffect)(() => {
    const onSettingsUpdate = e => {
      const patch = e && e.detail || {};
      setRuntimeSettings(prev => ({
        ...prev,
        ...patch
      }));
    };
    window.addEventListener('game-settings-update', onSettingsUpdate);
    return () => window.removeEventListener('game-settings-update', onSettingsUpdate);
  }, []);

  // Listen for navigation buttons
  (0,react.useEffect)(() => {
    const handleOpenModalEvent = () => dispatch(setMapModalOpen(true));
    window.addEventListener('open-new-game-modal', handleOpenModalEvent);
    return () => window.removeEventListener('open-new-game-modal', handleOpenModalEvent);
  }, [dispatch]);

  // Mirror current effective runtime settings for other components to read (like GameSettings)
  (0,react.useEffect)(() => {
    try {
      const clouds = runtimeSettings.weatherClouds ?? 0;
      const fog = runtimeSettings.weatherFog ?? 0;
      const thunder = runtimeSettings.weatherThunder ?? 0;
      window.__GAME_RUNTIME_SETTINGS__ = {
        ...(window.__GAME_RUNTIME_SETTINGS__ || {}),
        backgroundParallaxFactor: runtimeSettings.backgroundParallaxFactor ?? activeMapData?.meta?.backgroundParallaxFactor ?? 0.3,
        weatherRain: runtimeSettings.weatherRain ?? 0,
        weatherSnow: runtimeSettings.weatherSnow ?? 0,
        weatherClouds: clouds,
        weatherFog: fog,
        weatherThunder: thunder,
        healthBarEnabled: runtimeSettings.healthBarEnabled ?? true,
        oxygenBarEnabled: runtimeSettings.oxygenBarEnabled ?? true,
        lavaBarEnabled: runtimeSettings.lavaBarEnabled ?? true,
        waterSplashesEnabled: runtimeSettings.waterSplashesEnabled ?? true,
        lavaEmbersEnabled: runtimeSettings.lavaEmbersEnabled ?? true,
        // legacy mirror for compatibility (e.g., older UI)
        weatherFogLegacy: fog
      };
    } catch {}
  }, [runtimeSettings, activeMapData]);
  const loadMapData = mapData => {
    try {
      if (!mapData) {
        services_errorHandler.warn('loadMapData called with empty mapData', {
          component: 'Game'
        });
        return;
      }
      const w = mapData.meta?.width || mapData.width || 20;
      const h = mapData.meta?.height || mapData.height || 15;
      let tileData = [];
      let objData = [];
      if (mapData.layers) {
        const bgLayer = mapData.layers.find(l => l.name === 'background');
        tileData = bgLayer ? bgLayer.data : Array(w * h).fill(null);
        const objLayer = mapData.layers.find(l => l.name === 'entities');
        objData = objLayer ? objLayer.data : Array(w * h).fill(null);
      } else {
        tileData = mapData.tiles || Array(w * h).fill(null);
        objData = Array(w * h).fill(null);
      }

      // Update Redux store
      dispatch(setActiveMap({
        mapData,
        tileMapData: tileData,
        objectMapData: objData,
        mapWidth: w,
        mapHeight: h
      }));
      dispatch(setCameraScrollX(0));
      dispatch(setMapModalOpen(false));
      services_errorHandler.info('Map loaded successfully', {
        component: 'Game',
        mapName: mapData.meta?.name || 'Unknown',
        dimensions: `${w}x${h}`
      });
    } catch (error) {
      services_errorHandler.error(error, {
        component: 'Game',
        function: 'loadMapData',
        mapData
      });
      alert('Error loading map. Check console for details.');
    }
  };
  const handleCustomMapUpload = event => {
    try {
      const file = event.target.files[0];
      if (!file) return;
      const fileReader = new FileReader();
      fileReader.readAsText(file, "UTF-8");
      fileReader.onload = e => {
        try {
          const loaded = JSON.parse(e.target.result);
          loadMapData(loaded);
        } catch (error) {
          services_errorHandler.error(error, {
            component: 'Game',
            function: 'handleCustomMapUpload',
            fileName: file.name
          });
          alert("Invalid map file! Check console for details.");
        }
      };
      fileReader.onerror = error => {
        services_errorHandler.error(error, {
          component: 'Game',
          function: 'handleCustomMapUpload',
          fileName: file.name,
          phase: 'fileReader'
        });
        alert("Error reading file!");
      };
    } catch (error) {
      services_errorHandler.error(error, {
        component: 'Game',
        function: 'handleCustomMapUpload'
      });
    }
  };
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(GameContainer, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(game_GameHeader, {
      health: playerState.health,
      ammo: playerState.ammo || 0,
      soundEnabled: soundEnabled,
      onToggleSound: () => {
        const next = !soundEnabled;
        dispatch(setSoundEnabled(next));
        try {
          window.dispatchEvent(new CustomEvent('game-sound-toggle', {
            detail: {
              enabled: next
            }
          }));
        } catch {}
        try {
          window.dispatchEvent(new CustomEvent('game-sound-user-gesture'));
        } catch {}
      }
    }), isMapModalOpen && /*#__PURE__*/(0,jsx_runtime.jsx)(ModalOverlay, {
      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(ModalContent, {
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(ModalTitle, {
          children: "Select a Map"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(MapList, {
          children: BUILT_IN_MAPS.map((map, index) => /*#__PURE__*/(0,jsx_runtime.jsxs)(MapCard, {
            onClick: () => loadMapData(map),
            children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
              children: [/*#__PURE__*/(0,jsx_runtime.jsx)(MapTitle, {
                children: map.meta?.name || "Unnamed Map"
              }), /*#__PURE__*/(0,jsx_runtime.jsxs)(MapAuthor, {
                children: ["By: ", map.meta?.author || "Unknown"]
              })]
            }), /*#__PURE__*/(0,jsx_runtime.jsx)(MapInfo, {
              children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
                children: ["Size: ", map.meta?.width, "x", map.meta?.height]
              })
            })]
          }, index))
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(ModalDivider, {
          children: /*#__PURE__*/(0,jsx_runtime.jsxs)(FileUploadLabel, {
            children: ["\uD83D\uDCC2 Load Custom Map from Computer", /*#__PURE__*/(0,jsx_runtime.jsx)(HiddenFileInput, {
              type: "file",
              accept: ".json",
              onChange: handleCustomMapUpload
            })]
          })
        })]
      })
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Viewport, {
      ref: viewportRef,
      onScroll: e => dispatch(setCameraScrollX(e.currentTarget.scrollLeft || 0)),
      $centered: shouldCenterMap,
      $blurred: isMapModalOpen,
      children: activeMapData ? /*#__PURE__*/(0,jsx_runtime.jsx)(GameCanvas, {
        $width: mapWidth * 32,
        $height: mapHeight * 32,
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(chapters_PixiStage, {
          mapWidth: mapWidth,
          mapHeight: mapHeight,
          tileSize: 32,
          tileMapData: tileMapData,
          objectMapData: objectMapData,
          objectTextureIndices: objectTextureIndices,
          registryItems: registryItems,
          playerState: playerState,
          playerVisuals: playerVisuals,
          projectiles: playerState.projectiles || [],
          backgroundImage: activeMapData?.meta?.backgroundImage,
          backgroundColor: activeMapData?.meta?.backgroundColor,
          backgroundParallaxFactor: runtimeSettings.backgroundParallaxFactor ?? activeMapData?.meta?.backgroundParallaxFactor,
          cameraScrollX: cameraScrollX,
          weatherRain: runtimeSettings.weatherRain ?? 0,
          weatherSnow: runtimeSettings.weatherSnow ?? 0,
          weatherClouds: runtimeSettings.weatherClouds ?? 0,
          weatherFog: runtimeSettings.weatherFog ?? 0,
          weatherThunder: runtimeSettings.weatherThunder ?? 0,
          healthBarEnabled: runtimeSettings.healthBarEnabled ?? true,
          oxygenBarEnabled: runtimeSettings.oxygenBarEnabled ?? true,
          lavaBarEnabled: runtimeSettings.lavaBarEnabled ?? true,
          waterSplashesEnabled: runtimeSettings.waterSplashesEnabled ?? true,
          lavaEmbersEnabled: runtimeSettings.lavaEmbersEnabled ?? true
        })
      }) : /*#__PURE__*/(0,jsx_runtime.jsx)(PlaceholderMessage, {
        children: "Select a map to start playing"
      })
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(BackgroundMusicPlayer, {
      metaPath: activeMapData?.meta?.backgroundMusic,
      enabled: soundEnabled,
      volume: 0.6
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(GameSettings, {}), /*#__PURE__*/(0,jsx_runtime.jsx)(GameTerminal, {})]
  });
}
;// ./src/utilities/saveFile.js
// Progressive save utility for web: prefers File System Access API (Chromium)
// Fallbacks to classic Blob download when not available or when permission denied.

/**
 * Save a file, letting the user choose directory/filename when supported.
 * @param {string|Blob|Uint8Array} contents - Data to write
 * @param {string} suggestedName - Suggested filename, e.g., "my_map.json"
 * @param {string} mimeType - MIME type, e.g., "application/json"
 * @returns {Promise<boolean>} true if saved, false if cancelled or failed
 */
async function saveFile(contents, suggestedName = 'file.txt', mimeType = 'application/octet-stream') {
  try {
    // Prefer native file picker if available (Chromium: Edge/Chrome/Opera/Brave)
    const hasPicker = typeof window !== 'undefined' && typeof window.showSaveFilePicker === 'function';
    if (hasPicker) {
      const opts = {
        suggestedName,
        types: [{
          description: 'File',
          accept: {
            [mimeType || 'application/octet-stream']: [`.${suggestedName.split('.').pop() || 'dat'}`]
          }
        }]
      };
      let handle;
      try {
        handle = await window.showSaveFilePicker(opts);
      } catch (e) {
        // User cancelled the dialog
        if (e && (e.name === 'AbortError' || e.name === 'NotAllowedError')) return false;
        throw e;
      }
      const writable = await handle.createWritable();
      const blob = contents instanceof Blob ? contents : new Blob([contents], {
        type: mimeType
      });
      await writable.write(blob);
      await writable.close();
      return true;
    }
  } catch (e) {
    // fall through to fallback
    try {
      console.warn('Native save picker failed, using download fallback:', e);
    } catch {}
  }

  // Fallback: trigger a download to the browser default location
  try {
    const blob = contents instanceof Blob ? contents : new Blob([contents], {
      type: mimeType
    });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = suggestedName || 'file.dat';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    setTimeout(() => URL.revokeObjectURL(link.href), 0);
    return true;
  } catch (e) {
    try {
      console.error('Download fallback failed:', e);
    } catch {}
    return false;
  }
}
/* harmony default export */ const utilities_saveFile = (saveFile);
;// ./src/sections/chapters/editor/mapOperations.js


const saveMap = async ({
  mapWidth,
  mapHeight,
  tileMapData,
  objectMapData,
  mapName,
  creatorName,
  createdAt,
  selectedBackgroundImage,
  selectedBackgroundColor,
  backgroundParallaxFactor,
  selectedBackgroundMusic,
  registryItems,
  setCreatedAt
}) => {
  const currentDate = new Date().toISOString();
  const createdDate = createdAt || currentDate;

  // Statistics calculation
  const filledBlocks = tileMapData.filter(t => t !== null).length;
  const objectsCount = objectMapData.filter(o => o !== null).length;
  const itemsCount = objectMapData.filter(o => {
    if (!o) return false;
    const item = registryItems.find(r => r.id === o);
    return item && item.name && item.name.startsWith('item.');
  }).length;
  const mapData = {
    meta: {
      width: mapWidth,
      height: mapHeight,
      tileSize: 32,
      version: "1.0",
      name: mapName,
      author: creatorName,
      date_map_created_at: createdDate,
      date_map_last_updated: currentDate,
      backgroundImage: selectedBackgroundImage || null,
      backgroundColor: selectedBackgroundImage ? null : selectedBackgroundColor,
      backgroundParallaxFactor: backgroundParallaxFactor,
      backgroundMusic: selectedBackgroundMusic || null
    },
    statistics: {
      total_tiles: mapWidth * mapHeight,
      filled_tiles: filledBlocks,
      total_objects: objectsCount,
      total_items: itemsCount
    },
    layers: [{
      type: "tile",
      name: "background",
      data: tileMapData
    }, {
      type: "object",
      name: "entities",
      data: objectMapData
    }]
  };
  const fileName = `${mapName.replace(/\s+/g, '_')}.json`;
  const json = JSON.stringify(mapData, null, 2);
  try {
    const saved = await utilities_saveFile(json, fileName, 'application/json');
    if (saved) {
      if (!createdAt) setCreatedAt(currentDate);
      services_errorHandler.info('Map saved successfully', {
        component: 'Editor',
        mapName,
        fileName,
        dimensions: `${mapWidth}x${mapHeight}`
      });
    }
  } catch (error) {
    services_errorHandler.error(error, {
      component: 'Editor',
      function: 'saveMap',
      mapName,
      fileName
    });
    alert('Failed to save map. Check console for details.');
  }
};
const loadMap = ({
  event,
  setMapWidth,
  setMapHeight,
  setMapName,
  setCreatorName,
  setCreatedAt,
  setSelectedBackgroundImage,
  setSelectedBackgroundColor,
  setBackgroundParallaxFactor,
  setSelectedBackgroundMusic,
  setTileMapData,
  setObjectMapData
}) => {
  const fileReader = new FileReader();
  const file = event.target.files[0];
  if (file) {
    fileReader.readAsText(file, "UTF-8");
    fileReader.onload = e => {
      try {
        const loaded = JSON.parse(e.target.result);
        if (loaded.meta) {
          setMapWidth(loaded.meta.width);
          setMapHeight(loaded.meta.height);
          if (loaded.meta.name) setMapName(loaded.meta.name);
          if (loaded.meta.author) setCreatorName(loaded.meta.author);
          if (loaded.meta.date_map_created_at) setCreatedAt(loaded.meta.date_map_created_at);
          if (typeof loaded.meta.backgroundImage !== 'undefined' && loaded.meta.backgroundImage) {
            setSelectedBackgroundImage(loaded.meta.backgroundImage);
          } else {
            setSelectedBackgroundImage(null);
          }
          if (typeof loaded.meta.backgroundColor !== 'undefined' && loaded.meta.backgroundColor) {
            setSelectedBackgroundColor(loaded.meta.backgroundColor);
          }
          if (typeof loaded.meta.backgroundParallaxFactor !== 'undefined') {
            setBackgroundParallaxFactor(loaded.meta.backgroundParallaxFactor);
          } else {
            setBackgroundParallaxFactor(0.3);
          }
          if (typeof loaded.meta.backgroundMusic !== 'undefined' && loaded.meta.backgroundMusic) {
            const m = loaded.meta.backgroundMusic;
            const normalized = typeof m === 'string' ? m.replace('/sound/background/', '/assets/sound/background/') : m;
            setSelectedBackgroundMusic(normalized);
          } else {
            setSelectedBackgroundMusic(null);
          }
          const bgLayer = loaded.layers.find(l => l.name === 'background');
          const objLayer = loaded.layers.find(l => l.name === 'entities');
          if (bgLayer) setTileMapData(bgLayer.data);
          if (objLayer) setObjectMapData(objLayer.data);
          services_errorHandler.info('Map loaded successfully', {
            component: 'Editor',
            mapName: loaded.meta.name,
            dimensions: `${loaded.meta.width}x${loaded.meta.height}`
          });
        } else {
          // Old format
          if (loaded.width) setMapWidth(loaded.width);
          if (loaded.height) setMapHeight(loaded.height);
          if (loaded.tiles) setTileMapData(loaded.tiles);
          setObjectMapData(Array(loaded.width * loaded.height).fill(null));
          services_errorHandler.warn('Loaded map in legacy format', {
            component: 'Editor',
            fileName: file.name
          });
        }
      } catch (error) {
        services_errorHandler.error(error, {
          component: 'Editor',
          function: 'loadMap',
          fileName: file.name
        });
        alert('Error loading map. Check console for details.');
      }
    };
    fileReader.onerror = error => {
      services_errorHandler.error(error, {
        component: 'Editor',
        function: 'loadMap',
        fileName: file.name,
        phase: 'fileReader'
      });
      alert('Error reading file!');
    };
  }
};
const clearMap = ({
  mapWidth,
  mapHeight,
  setTileMapData,
  setObjectMapData
}) => {
  if (window.confirm("Are you sure you want to clear the map?")) {
    const size = mapWidth * mapHeight;
    setTileMapData(Array(size).fill(null));
    setObjectMapData(Array(size).fill(null));
  }
};
const resizeMapData = ({
  newWidth,
  newHeight,
  stateRef,
  setMapWidth,
  setMapHeight,
  setTileMapData,
  setObjectMapData
}) => {
  const {
    mapWidth: oldW,
    mapHeight: oldH,
    tileMapData: oldTiles,
    objectMapData: oldObjs
  } = stateRef.current;
  if (newWidth < 1 || newHeight < 1) return;
  if (newWidth === oldW && newHeight === oldH) return;
  const resizeArray = oldArr => {
    const newArr = Array(newWidth * newHeight).fill(null);
    for (let y = 0; y < Math.min(oldH, newHeight); y++) {
      for (let x = 0; x < Math.min(oldW, newWidth); x++) {
        newArr[y * newWidth + x] = oldArr[y * oldW + x];
      }
    }
    return newArr;
  };
  setMapWidth(newWidth);
  setMapHeight(newHeight);
  setTileMapData(resizeArray(oldTiles));
  setObjectMapData(resizeArray(oldObjs));
};
;// ./src/sections/chapters/editor/paintingTools.js
const getFloodFillIndices = (startIndex, currentData, mapWidth, mapHeight) => {
  const startId = currentData[startIndex];
  const width = mapWidth;
  const height = mapHeight;
  const stack = [startIndex];
  const visited = new Set();
  const matchingIndices = [];
  while (stack.length > 0) {
    const idx = stack.pop();
    if (visited.has(idx)) continue;
    visited.add(idx);
    if (idx < 0 || idx >= currentData.length) continue;
    if (currentData[idx] !== startId) continue;
    matchingIndices.push(idx);
    const x = idx % width;
    const y = Math.floor(idx / width);
    if (x > 0) stack.push(idx - 1);
    if (x < width - 1) stack.push(idx + 1);
    if (y > 0) stack.push(idx - width);
    if (y < height - 1) stack.push(idx + width);
  }
  return matchingIndices;
};
const floodFill = (startIndex, targetId, getCurrentData, setCurrentData, mapWidth, mapHeight) => {
  const currentData = getCurrentData();
  const startId = currentData[startIndex];
  if (startId === targetId) return;
  const indices = getFloodFillIndices(startIndex, currentData, mapWidth, mapHeight);
  const newData = [...currentData];
  indices.forEach(idx => newData[idx] = targetId);
  setCurrentData(newData);
};
const paintTile = (index, selectedTile, brushSize, mapWidth, mapHeight, getCurrentData, setCurrentData) => {
  const currentData = getCurrentData();
  const newData = [...currentData];
  const x = index % mapWidth;
  const y = Math.floor(index / mapWidth);
  for (let dy = 0; dy < brushSize; dy++) {
    for (let dx = 0; dx < brushSize; dx++) {
      const targetX = x + dx;
      const targetY = y + dy;
      if (targetX < mapWidth && targetY < mapHeight) {
        const targetIndex = targetY * mapWidth + targetX;
        newData[targetIndex] = selectedTile ? selectedTile.id : null;
      }
    }
  }
  setCurrentData(newData);
};
;// ./src/sections/chapters/editor/assetLoaders.js
const loadBackgroundOptions = () => {
  const bgContext = __webpack_require__(8870);
  return bgContext.keys().map(key => {
    const mod = bgContext(key);
    const url = mod.default || mod;
    const name = key.replace('./', '');
    return {
      key,
      name,
      src: url,
      metaPath: `/assets/background/${name}`
    };
  });
};
const loadMusicOptions = () => {
  const musicContext = __webpack_require__(1032);
  return musicContext.keys().map(key => {
    const mod = musicContext(key);
    const name = key.replace('./', '');
    return {
      key,
      name,
      src: mod.default || mod,
      metaPath: `/assets/sound/background/${name}`
    };
  });
};
;// ./src/sections/chapters/editor/constants.js
const baseButtonStyle = {
  display: 'inline-flex',
  alignItems: 'center',
  justifyContent: 'center',
  cursor: 'pointer',
  border: '1px solid #333',
  padding: '0 10px',
  height: '28px',
  backgroundColor: '#e0e0e0',
  marginRight: '5px',
  marginBottom: '5px',
  fontSize: '13px',
  color: '#000',
  borderRadius: '3px',
  userSelect: 'none',
  minWidth: '30px',
  boxSizing: 'border-box',
  textDecoration: 'none',
  lineHeight: 'normal'
};
const buttonStyle = {
  ...baseButtonStyle
};
const activeButtonStyle = {
  ...baseButtonStyle,
  backgroundColor: '#aaa',
  borderColor: '#000',
  fontWeight: 'bold'
};
;// ./src/sections/chapters/editor/PaletteSection.jsx


const PaletteSection = ({
  title,
  children,
  isOpenDefault = false
}) => {
  const [isOpen, setIsOpen] = (0,react.useState)(isOpenDefault);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    style: {
      marginBottom: '5px',
      border: '1px solid #ddd',
      borderRadius: '4px',
      backgroundColor: '#fff'
    },
    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      onClick: () => setIsOpen(!isOpen),
      style: {
        padding: '8px',
        cursor: 'pointer',
        backgroundColor: '#f0f0f0',
        fontWeight: 'bold',
        fontSize: '12px',
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        userSelect: 'none'
      },
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {
        children: title
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
        children: isOpen ? '' : ''
      })]
    }), isOpen && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      style: {
        padding: '8px',
        maxHeight: '200px',
        overflowY: 'auto'
      },
      children: children
    })]
  });
};
;// ./src/utilities/AnimatedItem.jsx


const AnimatedItem = ({
  textures,
  texture,
  speed,
  style,
  alt,
  className
}) => {
  const [index, setIndex] = (0,react.useState)(0);
  (0,react.useEffect)(() => {
    // Ja ir vairkas tekstras, skam animciju
    if (textures && textures.length > 1) {
      const interval = setInterval(() => {
        setIndex(prevIndex => (prevIndex + 1) % textures.length);
      }, speed || 500); // Noklusjuma trums 500ms

      return () => clearInterval(interval);
    }
  }, [textures, speed]);

  // Izvlamies ko rendert: animcijas kadru, viengo tekstru vai statisko bildi
  let imgSrc = null;
  if (textures && textures.length > 0) {
    imgSrc = textures[index % textures.length];
  } else if (texture) {
    imgSrc = texture;
  }
  if (!imgSrc) return null;
  return /*#__PURE__*/(0,jsx_runtime.jsx)("img", {
    src: imgSrc,
    alt: alt || '',
    style: style,
    className: className,
    draggable: false // Biei nodergi spls/editoros
  });
};
/* harmony default export */ const utilities_AnimatedItem = (AnimatedItem);
;// ./src/sections/chapters/editor/Toolbar.jsx






const Toolbar = ({
  mapName,
  creatorName,
  openNewMapModal,
  saveMap,
  loadMap,
  showGrid,
  setShowGrid,
  clearMap,
  activeTool,
  setActiveTool,
  brushSize,
  setBrushSize,
  activeLayer,
  selection,
  moveSelection,
  setSelection,
  selectedTile,
  handlePaletteSelect,
  blocks,
  liquids,
  entities,
  items,
  interactables,
  hazards,
  backgroundOptions,
  selectedBackgroundImage,
  setSelectedBackgroundImage,
  selectedBackgroundColor,
  setSelectedBackgroundColor,
  backgroundParallaxFactor,
  setBackgroundParallaxFactor,
  musicOptions,
  selectedBackgroundMusic,
  setSelectedBackgroundMusic,
  totalTiles,
  filledBlocks,
  emptyBlocks,
  objectsCount
}) => {
  const renderPaletteItem = (item, color, layer) => {
    const hasImage = !!(item.texture || Array.isArray(item.textures) && item.textures.length > 0);
    const isLiquid = !!(item.flags && item.flags.liquid);
    const isWater = !!(item.flags && item.flags.water);
    const isLava = !!(item.flags && item.flags.lava);
    const swatchStyle = isWater ? {
      background: 'linear-gradient(180deg,#2a5d8f,#174369)'
    } : isLava ? {
      background: 'linear-gradient(180deg,#6b1a07,#c43f0f)'
    } : {
      background: '#eee'
    };
    return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      onClick: () => handlePaletteSelect(item, layer),
      title: item.name,
      style: {
        border: selectedTile?.id === item.id ? `2px solid ${color}` : '1px solid #ccc',
        cursor: 'pointer',
        padding: '2px',
        width: '36px',
        height: '36px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: '#fff',
        position: 'relative'
      },
      children: hasImage ? /*#__PURE__*/(0,jsx_runtime.jsx)(utilities_AnimatedItem, {
        textures: item.textures,
        texture: item.texture,
        speed: item.animationSpeed,
        style: {
          maxWidth: '100%',
          maxHeight: '100%',
          objectFit: 'contain'
        },
        alt: item.name
      }) : /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        style: {
          width: '100%',
          height: '100%',
          borderRadius: 2,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          color: '#fff',
          fontSize: 10,
          textAlign: 'center',
          lineHeight: 1.1,
          ...swatchStyle
        },
        children: isLiquid ? isWater ? 'WATER' : isLava ? 'LAVA' : 'LIQ' : item.name || ''
      })
    }, item.id);
  };
  const BlockEraser = () => /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    onClick: () => {
      handlePaletteSelect(null, 'tile');
    },
    title: "Erase Blocks (Background)",
    style: {
      border: selectedTile === null && activeLayer === 'tile' ? `2px solid blue` : '1px solid #ccc',
      cursor: 'pointer',
      padding: '2px',
      width: '36px',
      height: '36px',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: '#f0f8ff',
      fontSize: '16px',
      color: 'blue'
    },
    children: "\u232BB"
  });
  const ObjectEraser = () => /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    onClick: () => {
      handlePaletteSelect(null, 'object');
    },
    title: "Erase Objects (Entities/Items)",
    style: {
      border: selectedTile === null && activeLayer === 'object' ? `2px solid red` : '1px solid #ccc',
      cursor: 'pointer',
      padding: '2px',
      width: '36px',
      height: '36px',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: '#fff0f0',
      fontSize: '16px',
      color: 'red'
    },
    children: "\u232BO"
  });
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: "toolbar",
    style: {
      width: '280px',
      padding: '15px',
      borderRight: '1px solid #ccc',
      overflowY: 'auto',
      display: 'flex',
      flexDirection: 'column',
      backgroundColor: '#f8f8f8'
    },
    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      style: {
        marginBottom: '15px'
      },
      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        style: {
          marginBottom: '10px',
          display: 'flex',
          flexDirection: 'column',
          gap: '5px'
        },
        children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
          style: {
            fontSize: '12px'
          },
          children: ["Map Name: ", /*#__PURE__*/(0,jsx_runtime.jsx)("strong", {
            children: mapName
          })]
        }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
          style: {
            fontSize: '12px'
          },
          children: ["Creator: ", /*#__PURE__*/(0,jsx_runtime.jsx)("strong", {
            children: creatorName
          })]
        })]
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        style: {
          marginBottom: '10px'
        },
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("button", {
          onClick: openNewMapModal,
          style: {
            ...buttonStyle,
            backgroundColor: '#4CAF50',
            color: '#fff',
            borderColor: '#388E3C'
          },
          children: "New"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("button", {
          onClick: saveMap,
          style: buttonStyle,
          children: "Save"
        }), /*#__PURE__*/(0,jsx_runtime.jsxs)("label", {
          style: buttonStyle,
          children: ["Load ", /*#__PURE__*/(0,jsx_runtime.jsx)("input", {
            type: "file",
            accept: ".json,.txt",
            onChange: loadMap,
            style: {
              display: 'none'
            }
          })]
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("button", {
          onClick: () => setShowGrid(!showGrid),
          style: showGrid ? activeButtonStyle : buttonStyle,
          children: "#"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("button", {
          onClick: clearMap,
          style: {
            ...buttonStyle,
            color: 'red'
          },
          title: "Clear Map",
          children: "\u2715"
        })]
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        style: {
          borderTop: '1px solid #ddd',
          paddingTop: '10px',
          marginBottom: '10px'
        },
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {
          style: {
            fontSize: '12px',
            fontWeight: 'bold',
            display: 'block',
            marginBottom: '5px'
          },
          children: "TOOLS"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("button", {
          onClick: () => setActiveTool('brush'),
          style: activeTool === 'brush' ? activeButtonStyle : buttonStyle,
          children: "\uD83D\uDD8C\uFE0F"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("button", {
          onClick: () => setActiveTool('bucket'),
          style: activeTool === 'bucket' ? activeButtonStyle : buttonStyle,
          children: "\uD83E\uDEA3"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("button", {
          onClick: () => setActiveTool('move'),
          style: activeTool === 'move' ? activeButtonStyle : buttonStyle,
          children: "\u270B"
        }), activeTool === 'brush' && /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
          style: {
            marginTop: '5px'
          },
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {
            style: {
              fontSize: '11px',
              marginRight: '5px'
            },
            children: "Size:"
          }), [1, 2, 3, 4, 5].map(size => /*#__PURE__*/(0,jsx_runtime.jsx)("button", {
            onClick: () => setBrushSize(size),
            style: {
              ...(brushSize === size ? activeButtonStyle : buttonStyle),
              padding: '0 6px',
              minWidth: '20px'
            },
            children: size
          }, size))]
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
          style: {
            marginTop: '10px',
            padding: '5px',
            backgroundColor: activeLayer === 'tile' ? '#e6f7ff' : '#fff1f0',
            borderRadius: '4px',
            border: '1px solid #ccc'
          },
          children: /*#__PURE__*/(0,jsx_runtime.jsxs)("span", {
            style: {
              fontSize: '11px'
            },
            children: ["Active: ", /*#__PURE__*/(0,jsx_runtime.jsx)("strong", {
              children: activeLayer === 'tile' ? ' Background' : ' Objects'
            })]
          })
        }), activeTool === 'move' && selection && /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
          style: {
            marginTop: '5px'
          },
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {
            style: {
              fontSize: '11px',
              display: 'block'
            },
            children: "Move Selection:"
          }), /*#__PURE__*/(0,jsx_runtime.jsx)("button", {
            onClick: () => moveSelection(0, -1),
            style: buttonStyle,
            children: "\u25B2"
          }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
            style: {
              display: 'inline-block'
            },
            children: [/*#__PURE__*/(0,jsx_runtime.jsx)("button", {
              onClick: () => moveSelection(-1, 0),
              style: buttonStyle,
              children: "\u25C0"
            }), /*#__PURE__*/(0,jsx_runtime.jsx)("button", {
              onClick: () => moveSelection(1, 0),
              style: buttonStyle,
              children: "\u25B6"
            })]
          }), /*#__PURE__*/(0,jsx_runtime.jsx)("button", {
            onClick: () => moveSelection(0, 1),
            style: buttonStyle,
            children: "\u25BC"
          }), /*#__PURE__*/(0,jsx_runtime.jsx)("button", {
            onClick: () => setSelection(null),
            style: {
              ...buttonStyle,
              color: 'red',
              marginLeft: '5px'
            },
            children: "\u2715"
          })]
        })]
      })]
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      className: "palette",
      style: {
        flex: 1,
        overflowY: 'auto'
      },
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(PaletteSection, {
        title: "Erasers",
        isOpenDefault: true,
        children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
          style: {
            display: 'flex',
            flexWrap: 'wrap',
            gap: '4px'
          },
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(BlockEraser, {}), /*#__PURE__*/(0,jsx_runtime.jsx)(ObjectEraser, {})]
        })
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(PaletteSection, {
        title: "Blocks (Background)",
        isOpenDefault: true,
        children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
          style: {
            display: 'flex',
            flexWrap: 'wrap',
            gap: '4px'
          },
          children: blocks.map(b => renderPaletteItem(b, 'blue', 'tile'))
        })
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(PaletteSection, {
        title: "Liquids (Blocks)",
        isOpenDefault: true,
        children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
          style: {
            display: 'flex',
            flexWrap: 'wrap',
            gap: '4px'
          },
          children: liquids.map(li => renderPaletteItem(li, 'blue', 'tile'))
        })
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(PaletteSection, {
        title: "Entities (Objects)",
        children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
          style: {
            display: 'flex',
            flexWrap: 'wrap',
            gap: '4px'
          },
          children: entities.map(e => renderPaletteItem(e, 'red', 'object'))
        })
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(PaletteSection, {
        title: "Items (Objects)",
        children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
          style: {
            display: 'flex',
            flexWrap: 'wrap',
            gap: '4px'
          },
          children: items.map(i => renderPaletteItem(i, 'green', 'object'))
        })
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(PaletteSection, {
        title: "interactables (Objects)",
        children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
          style: {
            display: 'flex',
            flexWrap: 'wrap',
            gap: '4px'
          },
          children: interactables.map(i => renderPaletteItem(i, 'purple', 'object'))
        })
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(PaletteSection, {
        title: "Hazards (Objects)",
        children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
          style: {
            display: 'flex',
            flexWrap: 'wrap',
            gap: '4px'
          },
          children: hazards.map(h => renderPaletteItem(h, 'orange', 'object'))
        })
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)(PaletteSection, {
        title: "Background Image",
        isOpenDefault: true,
        children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
          style: {
            display: 'grid',
            gridTemplateColumns: 'repeat(3, 1fr)',
            gap: '6px'
          },
          children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
            onClick: () => setSelectedBackgroundImage(null),
            style: {
              border: selectedBackgroundImage ? '1px solid #ccc' : '2px solid #4CAF50',
              borderRadius: '4px',
              padding: '2px',
              cursor: 'pointer',
              background: '#fff'
            },
            title: "Solid Color",
            children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {
              style: {
                width: '100%',
                height: '48px',
                background: selectedBackgroundColor,
                display: 'block',
                borderRadius: '2px'
              }
            }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
              style: {
                fontSize: '10px',
                textAlign: 'center',
                paddingTop: '2px'
              },
              children: "Solid Color"
            })]
          }), backgroundOptions.map(bg => /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
            onClick: () => setSelectedBackgroundImage(bg.metaPath),
            style: {
              border: selectedBackgroundImage === bg.metaPath ? '2px solid #4CAF50' : '1px solid #ccc',
              borderRadius: '4px',
              padding: '2px',
              cursor: 'pointer',
              background: '#fff'
            },
            title: bg.name,
            children: [/*#__PURE__*/(0,jsx_runtime.jsx)("img", {
              src: bg.src,
              alt: bg.name,
              style: {
                width: '100%',
                height: '48px',
                objectFit: 'cover',
                display: 'block'
              }
            }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
              style: {
                fontSize: '10px',
                textAlign: 'center',
                paddingTop: '2px'
              },
              children: bg.name
            })]
          }, bg.name))]
        }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
          style: {
            marginTop: '8px',
            display: 'flex',
            alignItems: 'center',
            gap: '8px'
          },
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("label", {
            style: {
              fontSize: '12px'
            },
            children: "Parallax: "
          }), /*#__PURE__*/(0,jsx_runtime.jsx)("input", {
            type: "range",
            min: "0",
            max: "1",
            step: "0.05",
            value: backgroundParallaxFactor,
            onChange: e => setBackgroundParallaxFactor(parseFloat(e.target.value))
          }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
            style: {
              fontSize: '12px'
            },
            children: backgroundParallaxFactor.toFixed(2)
          })]
        }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
          style: {
            marginTop: '8px',
            display: 'flex',
            alignItems: 'center',
            gap: '8px'
          },
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("label", {
            style: {
              fontSize: '12px'
            },
            children: "Background Color:"
          }), /*#__PURE__*/(0,jsx_runtime.jsx)("input", {
            type: "color",
            value: selectedBackgroundColor,
            onChange: e => setSelectedBackgroundColor(e.target.value)
          })]
        })]
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(PaletteSection, {
        title: "Background Music",
        isOpenDefault: true,
        children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
          style: {
            display: 'flex',
            flexDirection: 'column',
            gap: '6px'
          },
          children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("select", {
            value: selectedBackgroundMusic || '',
            onChange: e => setSelectedBackgroundMusic(e.target.value || null),
            style: {
              width: '100%',
              padding: '6px',
              fontSize: '12px'
            },
            children: [/*#__PURE__*/(0,jsx_runtime.jsx)("option", {
              value: "",
              children: "\u2014 None \u2014"
            }), musicOptions.map(m => /*#__PURE__*/(0,jsx_runtime.jsx)("option", {
              value: m.metaPath,
              children: m.name
            }, m.name))]
          }), /*#__PURE__*/(0,jsx_runtime.jsx)(BackgroundMusicPlayer, {
            metaPath: selectedBackgroundMusic,
            enabled: true,
            volume: 0.4
          }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
            style: {
              fontSize: '11px',
              color: '#555'
            },
            children: ["Selected: ", selectedBackgroundMusic ? selectedBackgroundMusic.split('/').pop() : 'None']
          })]
        })
      })]
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      style: {
        marginTop: 'auto',
        paddingTop: '10px',
        borderTop: '1px solid #ccc',
        fontSize: '11px',
        backgroundColor: '#eee',
        padding: '10px'
      },
      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        style: {
          marginBottom: '4px'
        },
        children: ["Size: ", /*#__PURE__*/(0,jsx_runtime.jsx)("strong", {
          children: totalTiles
        }), " tiles"]
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        style: {
          marginBottom: '4px',
          color: 'blue'
        },
        children: ["\uD83D\uDFE6 Filled Blocks: ", /*#__PURE__*/(0,jsx_runtime.jsx)("strong", {
          children: filledBlocks
        })]
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        style: {
          marginBottom: '4px',
          color: '#666'
        },
        children: ["\u2B1C Empty Blocks: ", /*#__PURE__*/(0,jsx_runtime.jsx)("strong", {
          children: emptyBlocks
        })]
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        style: {
          marginBottom: '4px',
          color: 'red'
        },
        children: ["\uD83D\uDFE5 Objects Count: ", /*#__PURE__*/(0,jsx_runtime.jsx)("strong", {
          children: objectsCount
        })]
      })]
    })]
  });
};
;// ./src/sections/chapters/editor/Viewport.jsx




const Viewport_Viewport = ({
  mapWidth,
  mapHeight,
  selectedBackgroundUrl,
  selectedBackgroundColor,
  selectedBackgroundImage,
  showGrid,
  activeLayer,
  activeTool,
  tileMapData,
  objectMapData,
  registryItems,
  hoverIndex,
  brushSize,
  bucketPreviewIndices,
  selection,
  dragStart,
  isDragging,
  handleGridMouseDown,
  handleGridMouseEnter,
  handleGridMouseUp,
  handleGridMouseLeave,
  setIsDragging,
  handleResizeMouseDown
}) => {
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    className: "viewport",
    style: {
      flex: 1,
      padding: '40px',
      backgroundColor: '#555',
      overflow: 'auto',
      position: 'relative',
      userSelect: 'none'
    },
    onMouseUp: () => setIsDragging(false),
    children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      style: {
        position: 'relative',
        width: 'fit-content'
      },
      onMouseLeave: handleGridMouseLeave,
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        style: {
          position: 'absolute',
          top: 0,
          left: 0,
          width: mapWidth * 32,
          height: mapHeight * 32,
          backgroundImage: selectedBackgroundUrl ? `url(${selectedBackgroundUrl})` : 'none',
          backgroundColor: !selectedBackgroundUrl ? selectedBackgroundColor : 'transparent',
          backgroundRepeat: 'repeat-x',
          backgroundSize: 'auto 100%',
          zIndex: 0,
          pointerEvents: 'none'
        }
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        className: "grid",
        style: {
          display: 'grid',
          gridTemplateColumns: `repeat(${mapWidth}, 32px)`,
          gridTemplateRows: `repeat(${mapHeight}, 32px)`,
          gap: '0px',
          border: '1px solid #444',
          backgroundColor: 'transparent',
          position: 'relative',
          cursor: activeTool === 'bucket' ? 'cell' : 'default',
          zIndex: 1
        },
        children: Array(mapWidth * mapHeight).fill(0).map((_, index) => {
          const tileId = tileMapData[index];
          const objectId = objectMapData[index];
          const tileObj = tileId ? registryItems.find(r => r.id === tileId) : null;
          const objObj = objectId ? registryItems.find(r => r.id === objectId) : null;
          const x = index % mapWidth;
          const y = Math.floor(index / mapWidth);
          let isSelected = false;
          if (selection && x >= selection.x && x < selection.x + selection.w && y >= selection.y && y < selection.y + selection.h) {
            isSelected = true;
          }
          let isMoveSelecting = false;
          let isMoveHover = false;
          if (activeTool === 'move') {
            if (isDragging && dragStart && hoverIndex !== null) {
              const hx = hoverIndex % mapWidth;
              const hy = Math.floor(hoverIndex / mapWidth);
              const sx = dragStart.x;
              const sy = dragStart.y;
              const minX = Math.min(sx, hx);
              const minY = Math.min(sy, hy);
              const maxX = Math.max(sx, hx);
              const maxY = Math.max(sy, hy);
              if (x >= minX && x <= maxX && y >= minY && y <= maxY) isMoveSelecting = true;
            } else if (!isDragging && hoverIndex === index) {
              isMoveHover = true;
            }
          }
          let isBrushTarget = false;
          if (activeTool === 'brush' && hoverIndex !== null) {
            const hx = hoverIndex % mapWidth;
            const hy = Math.floor(hoverIndex / mapWidth);
            if (x >= hx && x < hx + brushSize && y >= hy && y < hy + brushSize) isBrushTarget = true;
          }
          let isBucketTarget = false;
          let isBucketPreview = false;
          if (activeTool === 'bucket') {
            if (bucketPreviewIndices.has(index)) isBucketPreview = true;else if (hoverIndex === index) isBucketTarget = true;
          }
          let borderStyle = showGrid ? '0.5px solid rgba(128,128,128,0.5)' : 'none';
          let bgStyle = 'transparent';
          const isLiquidTile = !!(tileObj && tileObj.flags && tileObj.flags.liquid);
          const isWaterTile = !!(tileObj && tileObj.flags && tileObj.flags.water);
          const isLavaTile = !!(tileObj && tileObj.flags && tileObj.flags.lava);
          if (isBrushTarget) borderStyle = '2px solid red';else if (isBucketPreview) {
            borderStyle = '1px dashed orange';
            bgStyle = 'rgb(168,187,220)';
          } else if (isBucketTarget) borderStyle = '2px solid orange';else if (isMoveHover) borderStyle = '2px solid blue';else if (isMoveSelecting) {
            borderStyle = '1px dashed blue';
            bgStyle = 'rgba(0, 0, 255, 0.1)';
          } else if (isSelected) {
            borderStyle = '1px dashed red';
            bgStyle = 'rgba(255, 255, 0, 0.3)';
          } else if (!showGrid) borderStyle = 'none';
          let backgroundStyleObj = {};
          if (bgStyle !== 'transparent') {
            backgroundStyleObj.backgroundColor = bgStyle;
          } else if (isLiquidTile) {
            if (isWaterTile) {
              backgroundStyleObj.background = 'linear-gradient(180deg, #2a5d8f, #174369)';
            } else if (isLavaTile) {
              backgroundStyleObj.background = 'linear-gradient(180deg, #6b1a07, #c43f0f)';
            } else {
              backgroundStyleObj.background = 'linear-gradient(180deg, #3a3a3a, #1e1e1e)';
            }
          }
          return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
            onMouseDown: e => handleGridMouseDown(index, e),
            onMouseEnter: () => handleGridMouseEnter(index),
            onMouseUp: () => handleGridMouseUp(index),
            style: {
              width: '32px',
              height: '32px',
              border: borderStyle,
              zIndex: isBrushTarget || isBucketTarget || isBucketPreview || isMoveHover || isMoveSelecting ? 20 : isSelected ? 15 : 1,
              boxSizing: 'border-box',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              position: 'relative',
              ...backgroundStyleObj
            },
            children: [tileObj && /*#__PURE__*/(0,jsx_runtime.jsx)(utilities_AnimatedItem, {
              textures: tileObj.textures,
              texture: tileObj.texture,
              speed: tileObj.animationSpeed,
              style: {
                position: 'absolute',
                width: '100%',
                height: '100%',
                objectFit: 'contain',
                zIndex: 2
              }
            }), objObj && /*#__PURE__*/(0,jsx_runtime.jsx)(utilities_AnimatedItem, {
              textures: objObj.textures,
              texture: objObj.texture,
              speed: objObj.animationSpeed,
              style: {
                position: 'absolute',
                width: '100%',
                height: '100%',
                objectFit: 'contain',
                zIndex: 3
              }
            }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
              style: {
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                height: '100%',
                zIndex: 10
              }
            })]
          }, index);
        })
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        onMouseDown: handleResizeMouseDown('width'),
        style: {
          position: 'absolute',
          top: 0,
          right: -15,
          width: '15px',
          height: '100%',
          backgroundColor: '#777',
          cursor: 'col-resize',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          borderTopRightRadius: '5px',
          borderBottomRightRadius: '5px'
        },
        children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
          style: {
            color: '#ccc',
            fontSize: '20px'
          },
          children: "\u22EE"
        })
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        onMouseDown: handleResizeMouseDown('height'),
        style: {
          position: 'absolute',
          bottom: -15,
          left: 0,
          width: '100%',
          height: '15px',
          backgroundColor: '#777',
          cursor: 'row-resize',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          borderBottomLeftRadius: '5px',
          borderBottomRightRadius: '5px'
        },
        children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
          style: {
            color: '#ccc',
            fontSize: '20px'
          },
          children: "\u22EF"
        })
      })]
    })
  });
};
;// ./src/sections/chapters/editor/NewMapModal.jsx



const NewMapModal = ({
  isOpen,
  tempMapName,
  setTempMapName,
  tempCreatorName,
  setTempCreatorName,
  confirmNewMap,
  onClose
}) => {
  if (!isOpen) return null;
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    style: {
      position: 'absolute',
      top: 0,
      left: 0,
      width: '100%',
      height: '100%',
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
      zIndex: 1000,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center'
    },
    children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      style: {
        backgroundColor: '#fff',
        padding: '20px',
        borderRadius: '8px',
        boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
        width: '300px',
        display: 'flex',
        flexDirection: 'column',
        gap: '10px'
      },
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("h3", {
        style: {
          marginTop: 0
        },
        children: "Create New Map"
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("label", {
          style: {
            display: 'block',
            fontSize: '12px',
            marginBottom: '4px'
          },
          children: "Map Name:"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("input", {
          type: "text",
          value: tempMapName,
          onChange: e => setTempMapName(e.target.value),
          style: {
            width: '100%',
            padding: '5px',
            boxSizing: 'border-box'
          }
        })]
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("label", {
          style: {
            display: 'block',
            fontSize: '12px',
            marginBottom: '4px'
          },
          children: "Creator Nickname:"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("input", {
          type: "text",
          value: tempCreatorName,
          onChange: e => setTempCreatorName(e.target.value),
          style: {
            width: '100%',
            padding: '5px',
            boxSizing: 'border-box'
          }
        })]
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        style: {
          display: 'flex',
          justifyContent: 'flex-end',
          gap: '10px',
          marginTop: '10px'
        },
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("button", {
          onClick: onClose,
          style: {
            ...buttonStyle,
            backgroundColor: '#f0f0f0'
          },
          children: "Cancel"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("button", {
          onClick: confirmNewMap,
          style: {
            ...buttonStyle,
            backgroundColor: '#4CAF50',
            color: 'white',
            borderColor: '#4CAF50'
          },
          children: "Create"
        })]
      })]
    })
  });
};
;// ./src/sections/chapters/editor/index.jsx










const Editor = () => {
  // Editor state: map dimensions, tile/object data, selected tile, tools
  const [mapWidth, setMapWidth] = (0,react.useState)(20);
  const [mapHeight, setMapHeight] = (0,react.useState)(15);
  const [tileMapData, setTileMapData] = (0,react.useState)([]);
  const [objectMapData, setObjectMapData] = (0,react.useState)([]);
  const [selectedTile, setSelectedTile] = (0,react.useState)(null);
  const [showGrid, setShowGrid] = (0,react.useState)(true);
  const [isDragging, setIsDragging] = (0,react.useState)(false);
  const [brushSize, setBrushSize] = (0,react.useState)(1);
  const [activeTool, setActiveTool] = (0,react.useState)('brush');
  const [selection, setSelection] = (0,react.useState)(null);
  const [hoverIndex, setHoverIndex] = (0,react.useState)(null);
  const [activeLayer, setActiveLayer] = (0,react.useState)('tile');
  const [dragStart, setDragStart] = (0,react.useState)(null);
  const [bucketPreviewIndices, setBucketPreviewIndices] = (0,react.useState)(new Set());
  const bucketTimerRef = (0,react.useRef)(null);
  const stateRef = (0,react.useRef)({
    mapWidth,
    mapHeight,
    tileMapData,
    objectMapData
  });

  // Map metadata
  const [mapName, setMapName] = (0,react.useState)("New Map");
  const [creatorName, setCreatorName] = (0,react.useState)("Anonymous");
  const [createdAt, setCreatedAt] = (0,react.useState)(null);
  const [isNewMapModalOpen, setIsNewMapModalOpen] = (0,react.useState)(false);
  const [tempMapName, setTempMapName] = (0,react.useState)("");
  const [tempCreatorName, setTempCreatorName] = (0,react.useState)("");
  (0,react.useEffect)(() => {
    stateRef.current = {
      mapWidth,
      mapHeight,
      tileMapData,
      objectMapData
    };
  }, [mapWidth, mapHeight, tileMapData, objectMapData]);
  (0,react.useEffect)(() => {
    const size = 15 * 20;
    setTileMapData(Array(size).fill(null));
    setObjectMapData(Array(size).fill(null));
  }, []);
  const registryItems = getRegistry() || [];
  const blocks = registryItems.filter(item => item.name && item.name.startsWith('block.') && !(item.flags && item.flags.liquid));
  const liquids = registryItems.filter(item => item.flags && item.flags.liquid);
  const entities = registryItems.filter(item => {
    if (!item.name || !item.name.startsWith('entities.')) return false;
    if (item.isHiddenInEditor) return false;
    return !item.type || item.type === 'default';
  });
  const items = registryItems.filter(item => item.name && item.name.startsWith('item.'));
  const interactables = registryItems.filter(item => item.name && item.name.startsWith('interactable.'));
  const hazards = registryItems.filter(item => item.type === 'hazard');
  const backgroundOptions = loadBackgroundOptions();
  const musicOptions = loadMusicOptions();
  const [selectedBackgroundImage, setSelectedBackgroundImage] = (0,react.useState)(backgroundOptions[0]?.metaPath || null);
  const [backgroundParallaxFactor, setBackgroundParallaxFactor] = (0,react.useState)(0.3);
  const [selectedBackgroundColor, setSelectedBackgroundColor] = (0,react.useState)('#87CEEB');
  const [selectedBackgroundMusic, setSelectedBackgroundMusic] = (0,react.useState)(null);
  const selectedBgOption = backgroundOptions.find(bg => bg.metaPath === selectedBackgroundImage) || backgroundOptions[0];
  const selectedBackgroundUrl = selectedBgOption && selectedBackgroundImage ? selectedBgOption.src : null;
  const openNewMapModal = () => {
    setTempMapName("New Map");
    setTempCreatorName(creatorName);
    setIsNewMapModalOpen(true);
  };
  const confirmNewMap = () => {
    if (window.confirm("Are you sure you want to create a new map? Unsaved changes will be lost.")) {
      const size = 20 * 15;
      setMapWidth(20);
      setMapHeight(15);
      setTileMapData(Array(size).fill(null));
      setObjectMapData(Array(size).fill(null));
      setMapName(tempMapName || "New Map");
      setCreatorName(tempCreatorName || "Anonymous");
      setCreatedAt(null);
      setSelectedBackgroundImage(backgroundOptions[0]?.metaPath || null);
      setBackgroundParallaxFactor(0.3);
      setSelectedBackgroundColor('#87CEEB');
      setSelectedBackgroundMusic(null);
      setIsNewMapModalOpen(false);
    }
  };
  const getCurrentData = () => activeLayer === 'tile' ? tileMapData : objectMapData;
  const setCurrentData = newData => activeLayer === 'tile' ? setTileMapData(newData) : setObjectMapData(newData);
  const handleGridMouseDown = (index, e) => {
    e.preventDefault();
    if (activeTool === 'brush') {
      setIsDragging(true);
      paintTile(index, selectedTile, brushSize, mapWidth, mapHeight, getCurrentData, setCurrentData);
    } else if (activeTool === 'bucket') {
      const targetId = selectedTile ? selectedTile.id : null;
      floodFill(index, targetId, getCurrentData, setCurrentData, mapWidth, mapHeight);
      setBucketPreviewIndices(new Set());
    } else if (activeTool === 'move') {
      const x = index % mapWidth;
      const y = Math.floor(index / mapWidth);
      setDragStart({
        x,
        y
      });
      setSelection(null);
      setIsDragging(true);
    }
  };
  const handleGridMouseEnter = index => {
    setHoverIndex(index);
    if (bucketTimerRef.current) {
      clearTimeout(bucketTimerRef.current);
      bucketTimerRef.current = null;
    }
    setBucketPreviewIndices(new Set());
    if (activeTool === 'brush' && isDragging) {
      paintTile(index, selectedTile, brushSize, mapWidth, mapHeight, getCurrentData, setCurrentData);
    } else if (activeTool === 'bucket' && !isDragging) {
      bucketTimerRef.current = setTimeout(() => {
        const currentData = getCurrentData();
        const indices = getFloodFillIndices(index, currentData, mapWidth, mapHeight);
        setBucketPreviewIndices(new Set(indices));
      }, 600);
    }
  };
  const handleGridMouseLeave = () => {
    setHoverIndex(null);
    if (bucketTimerRef.current) clearTimeout(bucketTimerRef.current);
    setBucketPreviewIndices(new Set());
  };
  const handleGridMouseUp = index => {
    setIsDragging(false);
    if (activeTool === 'move' && dragStart) {
      const endX = index % mapWidth;
      const endY = Math.floor(index / mapWidth);
      const x1 = Math.min(dragStart.x, endX);
      const y1 = Math.min(dragStart.y, endY);
      const x2 = Math.max(dragStart.x, endX);
      const y2 = Math.max(dragStart.y, endY);
      const w = x2 - x1 + 1;
      const h = y2 - y1 + 1;
      const selTileData = [];
      const selObjectData = [];
      for (let py = 0; py < h; py++) {
        for (let px = 0; px < w; px++) {
          const idx = (y1 + py) * mapWidth + (x1 + px);
          selTileData.push(tileMapData[idx]);
          selObjectData.push(objectMapData[idx]);
        }
      }
      setSelection({
        x: x1,
        y: y1,
        w,
        h,
        tileData: selTileData,
        objectData: selObjectData
      });
      setDragStart(null);
    }
  };
  const moveSelection = (dx, dy) => {
    if (!selection) return;
    const newTileMap = [...tileMapData];
    const newObjectMap = [...objectMapData];
    for (let py = 0; py < selection.h; py++) {
      for (let px = 0; px < selection.w; px++) {
        const idx = (selection.y + py) * mapWidth + (selection.x + px);
        if (idx >= 0 && idx < newTileMap.length) {
          newTileMap[idx] = null;
          newObjectMap[idx] = null;
        }
      }
    }
    const newX = selection.x + dx;
    const newY = selection.y + dy;
    for (let py = 0; py < selection.h; py++) {
      for (let px = 0; px < selection.w; px++) {
        const destX = newX + px;
        const destY = newY + py;
        if (destX >= 0 && destX < mapWidth && destY >= 0 && destY < mapHeight) {
          const destIdx = destY * mapWidth + destX;
          const srcDataIdx = py * selection.w + px;
          newTileMap[destIdx] = selection.tileData[srcDataIdx];
          newObjectMap[destIdx] = selection.objectData[srcDataIdx];
        }
      }
    }
    setTileMapData(newTileMap);
    setObjectMapData(newObjectMap);
    setSelection({
      ...selection,
      x: newX,
      y: newY
    });
  };
  const handleResizeMouseDown = direction => e => {
    e.preventDefault();
    e.stopPropagation();
    const startX = e.clientX;
    const startY = e.clientY;
    const {
      mapWidth: startW,
      mapHeight: startH
    } = stateRef.current;
    const onMouseMove = moveEvent => {
      const dx = moveEvent.clientX - startX;
      const dy = moveEvent.clientY - startY;
      if (direction === 'width') {
        const colsDiff = Math.round(dx / TILE_SIZE);
        if (startW + colsDiff !== stateRef.current.mapWidth) {
          resizeMapData({
            newWidth: startW + colsDiff,
            newHeight: stateRef.current.mapHeight,
            stateRef,
            setMapWidth,
            setMapHeight,
            setTileMapData,
            setObjectMapData
          });
        }
      } else if (direction === 'height') {
        const rowsDiff = Math.round(dy / TILE_SIZE);
        if (startH + rowsDiff !== stateRef.current.mapHeight) {
          resizeMapData({
            newWidth: stateRef.current.mapWidth,
            newHeight: startH + rowsDiff,
            stateRef,
            setMapWidth,
            setMapHeight,
            setTileMapData,
            setObjectMapData
          });
        }
      }
    };
    const onMouseUp = () => {
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('mouseup', onMouseUp);
    };
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
  };
  const handlePaletteSelect = (item, layer) => {
    setSelectedTile(item);
    setActiveLayer(layer);
    setActiveTool('brush');
    setSelection(null);
  };
  const totalTiles = mapWidth * mapHeight;
  const filledBlocks = tileMapData.filter(t => t !== null).length;
  const emptyBlocks = totalTiles - filledBlocks;
  const objectsCount = objectMapData.filter(o => o !== null).length;
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: "editor-wrapper",
    style: {
      position: 'relative',
      height: '100%',
      overflow: 'hidden'
    },
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(NewMapModal, {
      isOpen: isNewMapModalOpen,
      tempMapName: tempMapName,
      setTempMapName: setTempMapName,
      tempCreatorName: tempCreatorName,
      setTempCreatorName: setTempCreatorName,
      confirmNewMap: confirmNewMap,
      onClose: () => setIsNewMapModalOpen(false)
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      className: "editor-container",
      style: {
        display: 'flex',
        height: '100%',
        flexDirection: 'row',
        filter: isNewMapModalOpen ? 'blur(4px) brightness(0.7)' : 'none',
        transition: 'filter 0.2s ease',
        pointerEvents: isNewMapModalOpen ? 'none' : 'auto'
      },
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Toolbar, {
        mapName: mapName,
        creatorName: creatorName,
        openNewMapModal: openNewMapModal,
        saveMap: () => saveMap({
          mapWidth,
          mapHeight,
          tileMapData,
          objectMapData,
          mapName,
          creatorName,
          createdAt,
          selectedBackgroundImage,
          selectedBackgroundColor,
          backgroundParallaxFactor,
          selectedBackgroundMusic,
          registryItems,
          setCreatedAt
        }),
        loadMap: event => loadMap({
          event,
          setMapWidth,
          setMapHeight,
          setMapName,
          setCreatorName,
          setCreatedAt,
          setSelectedBackgroundImage,
          setSelectedBackgroundColor,
          setBackgroundParallaxFactor,
          setSelectedBackgroundMusic,
          setTileMapData,
          setObjectMapData
        }),
        showGrid: showGrid,
        setShowGrid: setShowGrid,
        clearMap: () => clearMap({
          mapWidth,
          mapHeight,
          setTileMapData,
          setObjectMapData
        }),
        activeTool: activeTool,
        setActiveTool: setActiveTool,
        brushSize: brushSize,
        setBrushSize: setBrushSize,
        activeLayer: activeLayer,
        selection: selection,
        moveSelection: moveSelection,
        setSelection: setSelection,
        selectedTile: selectedTile,
        handlePaletteSelect: handlePaletteSelect,
        blocks: blocks,
        liquids: liquids,
        entities: entities,
        items: items,
        interactables: interactables,
        hazards: hazards,
        backgroundOptions: backgroundOptions,
        selectedBackgroundImage: selectedBackgroundImage,
        setSelectedBackgroundImage: setSelectedBackgroundImage,
        selectedBackgroundColor: selectedBackgroundColor,
        setSelectedBackgroundColor: setSelectedBackgroundColor,
        backgroundParallaxFactor: backgroundParallaxFactor,
        setBackgroundParallaxFactor: setBackgroundParallaxFactor,
        musicOptions: musicOptions,
        selectedBackgroundMusic: selectedBackgroundMusic,
        setSelectedBackgroundMusic: setSelectedBackgroundMusic,
        totalTiles: totalTiles,
        filledBlocks: filledBlocks,
        emptyBlocks: emptyBlocks,
        objectsCount: objectsCount
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(Viewport_Viewport, {
        mapWidth: mapWidth,
        mapHeight: mapHeight,
        selectedBackgroundUrl: selectedBackgroundUrl,
        selectedBackgroundColor: selectedBackgroundColor,
        selectedBackgroundImage: selectedBackgroundImage,
        showGrid: showGrid,
        activeLayer: activeLayer,
        activeTool: activeTool,
        tileMapData: tileMapData,
        objectMapData: objectMapData,
        registryItems: registryItems,
        hoverIndex: hoverIndex,
        brushSize: brushSize,
        bucketPreviewIndices: bucketPreviewIndices,
        selection: selection,
        dragStart: dragStart,
        isDragging: isDragging,
        handleGridMouseDown: handleGridMouseDown,
        handleGridMouseEnter: handleGridMouseEnter,
        handleGridMouseUp: handleGridMouseUp,
        handleGridMouseLeave: handleGridMouseLeave,
        setIsDragging: setIsDragging,
        handleResizeMouseDown: handleResizeMouseDown
      })]
    })]
  });
};
;// ./src/sections/chapters/crystals.jsx

function Crystals() {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
    children: /*#__PURE__*/(0,jsx_runtime.jsx)("p", {
      children: "Crystals"
    })
  });
}
;// ./src/sections/chapters/repository.jsx




function Repository() {
  const registryItems = getRegistry();

  // Container style for grid layout
  const containerStyle = {
    display: 'flex',
    flexWrap: 'wrap',
    gap: '20px',
    padding: '20px'
  };

  // Style for each card
  const cardStyle = {
    border: '1px solid #ccc',
    borderRadius: '8px',
    padding: '10px',
    width: '200px',
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    backgroundColor: '#f9f9f9'
  };

  // Image style (64x64)
  const imageStyle = {
    width: '64px',
    height: '64px',
    objectFit: 'contain',
    // Prevent image stretching if proportions aren't perfect
    imageRendering: 'pixelated',
    // Important for pixel graphics (2D games)
    marginBottom: '10px',
    border: '1px dashed #aaa'
  };
  const fieldsContainerStyle = {
    width: '100%',
    fontSize: '12px',
    textAlign: 'left'
  };
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    style: containerStyle,
    children: [registryItems.map((item, index) => /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      style: cardStyle,
      children: [item.textures && item.textures.length > 0 ? /*#__PURE__*/(0,jsx_runtime.jsx)(utilities_AnimatedItem, {
        textures: item.textures,
        texture: item.texture,
        speed: item.animationSpeed,
        style: imageStyle,
        alt: item.name
      }) : /*#__PURE__*/(0,jsx_runtime.jsx)("img", {
        src: item.texture,
        alt: item.name,
        style: imageStyle,
        onError: e => {
          e.target.style.display = 'none';
        }
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        style: fieldsContainerStyle,
        children: Object.entries(item).filter(([key]) => !['texture', 'textures', 'animationSpeed'].includes(key)).map(([key, value]) => /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
          style: {
            marginBottom: '4px',
            wordBreak: 'break-all'
          },
          children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("strong", {
            children: [key, ":"]
          }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
            style: {
              marginLeft: '5px',
              color: '#555'
            },
            children: typeof value === 'object' ? JSON.stringify(value) : String(value)
          })]
        }, key))
      })]
    }, item.id || index)), registryItems.length === 0 && /*#__PURE__*/(0,jsx_runtime.jsx)("p", {
      children: "No items found in registry."
    })]
  });
}
;// ./src/index.js

















const root = client.createRoot(document.getElementById('root'));
root.render(/*#__PURE__*/(0,jsx_runtime.jsx)(react_redux/* Provider */.Kq, {
  store: src_store,
  children: /*#__PURE__*/(0,jsx_runtime.jsxs)(styled_components_browser_esm/* ThemeProvider */.NP, {
    theme: styles_theme,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(styles_GlobalStyles, {}), /*#__PURE__*/(0,jsx_runtime.jsx)(chunk_4WY6JWTD/* BrowserRouter */.Kd, {
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(chunk_4WY6JWTD/* Routes */.BV, {
        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(chunk_4WY6JWTD/* Route */.qh, {
          path: "/",
          element: /*#__PURE__*/(0,jsx_runtime.jsx)(src_App, {}),
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(chunk_4WY6JWTD/* Route */.qh, {
            index: true,
            element: /*#__PURE__*/(0,jsx_runtime.jsx)(Home, {})
          }), /*#__PURE__*/(0,jsx_runtime.jsx)(chunk_4WY6JWTD/* Route */.qh, {
            path: "game",
            element: /*#__PURE__*/(0,jsx_runtime.jsx)(Game, {})
          }), /*#__PURE__*/(0,jsx_runtime.jsx)(chunk_4WY6JWTD/* Route */.qh, {
            path: "editor",
            element: /*#__PURE__*/(0,jsx_runtime.jsx)(Editor, {})
          }), /*#__PURE__*/(0,jsx_runtime.jsx)(chunk_4WY6JWTD/* Route */.qh, {
            path: "crystals",
            element: /*#__PURE__*/(0,jsx_runtime.jsx)(Crystals, {})
          }), /*#__PURE__*/(0,jsx_runtime.jsx)(chunk_4WY6JWTD/* Route */.qh, {
            path: "repository",
            element: /*#__PURE__*/(0,jsx_runtime.jsx)(Repository, {})
          })]
        })
      })
    })]
  })
}));

/***/ }),

/***/ 9240:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAt0lEQVRYR+2XMQ6AIAxF5Rpc0MnF3cndxckLcg0NJk2MAfoLJGWoozG8x6fa6iblyynzJxOwBKoTWGZ/pwr4vIJoTdHDEUjgbQ3JF2g//HsfFREJRHgO/LeJIogELCCBkwwiAQnUwFEJVqAFjkiMLdBj91wKxQRMwBKwBNQToO6HNqDcfFnqCWN/CWlHLUfBdUQ2gRYJDh7XhgWk9YDAxQLqI9m3ytWG0t6/cqIa6A2vqoHeEuoJPMojlCF41qYzAAAAAElFTkSuQmCC";

/***/ }),

/***/ 9290:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAuklEQVRYR+2XwQmAMAxF7RpO582TI4iII3jy5nSuoUQoiLTNT1tID/Eo0vf6G010nfLllPmdCVgC2QlMY3+HCng/LtGaoocJ6MHrdgZfoGUe3vuoiEiA4DHw34ZEEAlYQAL3MogEJJADRyVYgRI4ItG2QI3dcykkEzABS8ASUE/Adz+0AcXmy1RPaPtL6HdUchRcR2QTKJHg4LQ2LCCtBwQuFlAfyb5VrjaU1v6VE9VAbXhWDdSWUE/gAeqElCEt0Ld5AAAAAElFTkSuQmCC";

/***/ }),

/***/ 9717:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAu0lEQVRYR+2XwQmAMAxF7RoO4GqeBE8O4Unw5GoO4BpKhIJI2/y0hfQQjyJ9r7/RRNcpX06Z35mAJZCdwDT2d6iA9+MSrSl6mIAevG5n8AVa5uG9j4qIBAgeA/9tSASRgAUkcC+DSEACOXBUghUogSMSbQvU2D2XQjIBE7AELAH1BHz3QxtQbL5M9YS2v4R+RyVHwXVENoESCQ5Oa8MC0npA4GIB9ZHsW+VqQ2ntXzlRDdSGZ9VAbQn1BB5XopQhvIwnHgAAAABJRU5ErkJgggAA";

/***/ }),

/***/ 9750:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "static/media/zzox-fx_nite-hit-item.9a820de1a358a418bf42.ogg";

/***/ }),

/***/ 9792:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAt0lEQVRYR+2XMQ6AIAxF5Rpc0MnF3cndxckLcg0NJk2MAfoLJGWoozG8x6fa6iblyynzJxOwBKoTWGZ/pwr4vIJoTdHDEUjgbQ3JF2g//HsfFREJRHgO/LeJIogELCCBkwwiAQnUwFEJVqAFjkiMLdBj91wKxQRMwBKwBNQToO6HNqDcfFnqCWN/CWlHLUfBdUQ2gRYJDh7XhgWk9YDAxQLqI9m3ytWG0t6/cqIa6A2vqoHeEuoJPMojlCF41qYzAAAAAElFTkSuQmCC";

/***/ }),

/***/ 9954:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAuklEQVRYR+2XwQmAMAxF7RpO582TI4iII3jy5nSuoUQoiLTNT1tID/Eo0vf6G010nfLllPmdCVgC2QlMY3+HCng/LtGaoocJ6MHrdgZfoGUe3vuoiEiA4DHw34ZEEAlYQAL3MogEJJADRyVYgRI4ItG2QI3dcykkEzABS8ASUE/Adz+0AcXmy1RPaPtL6HdUchRcR2QTKJHg4LQ2LCCtBwQuFlAfyb5VrjaU1v6VE9VAbXhWDdSWUE/gAeqElCEt0Ld5AAAAAElFTkSuQmCC";

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, [382,96], () => (__webpack_exec__(8921)));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);
//# sourceMappingURL=main.bundle.js.map