import { Graphics, Texture, TilingSprite } from 'pixi.js';
// Full-screen fog overlay: a semi-transparent rectangle covering entire viewport.
// Intensity 0..100 maps to alpha 0..0.65.
export default class WeatherFog {
  constructor(container, api, getIntensity) {
    this.container = container;
    this.api = api;
    this.getIntensity = getIntensity || (() => 0);
    this.width = api.mapWidth * api.tileSize;
    this.height = api.mapHeight * api.tileSize;
    this.intensity = 0;
    this.time = 0; // ms accumulator for subtle breathing
    // Base tint rectangle drawn once; alpha controlled via displayObject alpha (no redraws per frame)
    this.g = new Graphics();
    this.container.addChild(this.g);
    // Build procedural noise texture once (small size, repeats as tiling sprites)
    this.noiseTex = WeatherFog._createNoiseTexture(128, 128);
    this.layer1 = new TilingSprite(this.noiseTex, this.width, this.height);
    this.layer2 = new TilingSprite(this.noiseTex, this.width, this.height);
    // Different scales for parallax effect
    this.layer1.tileScale.set(1.0, 1.0);
    this.layer2.tileScale.set(0.6, 0.8);
    // Start with zero alpha; will be set based on intensity
    this.layer1.alpha = 0;
    this.layer2.alpha = 0;
    this.container.addChild(this.layer1);
    this.container.addChild(this.layer2);
    // Precompute parameters
    this._recalcParams();
    this._draw();
  }
  _alphaFromIntensity(v) {
    const t = Math.max(0, Math.min(100, Number(v) || 0)) / 100; // 0..1
    return Math.max(0, Math.min(0.65, t * 0.65));
  }
  setIntensity(v) {
    const nv = Math.max(0, Math.min(100, Number(v) || 0));
    if (nv === this.intensity) return;
    this.intensity = nv;
    this._recalcParams();
    this._applyAlphas(0); // update layer alphas based on new intensity
    this._draw();
  }
  resize(width, height) {
    const w = Math.max(1, Math.floor(width));
    const h = Math.max(1, Math.floor(height));
    if (w === this.width && h === this.height) return;
    this.width = w;
    this.height = h;
    // Resize tiling sprites and redraw base rect
    if (this.layer1) { this.layer1.width = w; this.layer1.height = h; }
    if (this.layer2) { this.layer2.width = w; this.layer2.height = h; }
    this._draw();
  }
  _draw() {
    const w = this.width;
    const h = this.height;
    const g = this.g;
    g.clear();
    const baseAlpha = this._alphaFromIntensity(this.intensity);
    if (baseAlpha <= 0) {
      g.alpha = 0;
      return;
    }
    // Draw once with alpha 1, then control real alpha via g.alpha each frame
    g.rect(0, 0, w, h);
    g.fill({ color: 0x9fb7c9, alpha: 1 });
    g.alpha = baseAlpha;
  }
  update(dtMs) {
    // Live intensity update from settings
    const cur = Math.max(0, Math.min(100, this.getIntensity()));
    if (cur !== this.intensity) this.setIntensity(cur);
    // Advance time for breathing/pulse
    const dt = Math.max(0, Number(dtMs) || 16.67);
    this.time += dt;
    // Very subtle breathing: sine between ~0.96 .. 1.04
    const pulse = 1 + 0.04 * Math.sin(this.time * 0.0012);
    this._applyAlphas(pulse);
    // Scroll noise layers slowly
    if (this.layer1) {
      this.layer1.tilePosition.x += this.speed1.x * dt;
      this.layer1.tilePosition.y += this.speed1.y * dt;
    }
    if (this.layer2) {
      this.layer2.tilePosition.x += this.speed2.x * dt;
      this.layer2.tilePosition.y += this.speed2.y * dt;
    }
  }
  destroy() {
    if (this.g) {
      try { this.g.parent && this.g.parent.removeChild(this.g); } catch {}
      try { this.g.destroy(); } catch {}
    }
    this.g = null;
    try {
      if (this.layer1) { this.layer1.parent && this.layer1.parent.removeChild(this.layer1); this.layer1.destroy(true); }
    } catch {}
    try {
      if (this.layer2) { this.layer2.parent && this.layer2.parent.removeChild(this.layer2); this.layer2.destroy(true); }
    } catch {}
    this.layer1 = null;
    this.layer2 = null;
    try { this.noiseTex?.destroy(true); } catch {}
    this.noiseTex = null;
  }
  _applyAlphas(pulseFactor = 1) {
    const base = this._alphaFromIntensity(this.intensity);
    // Noise contribution grows with intensity but remains subtle
    const t = Math.max(0, Math.min(1, this.intensity / 100));
    const noiseAlpha = base * (0.25 + 0.35 * t); // up to ~0.4 of base
    if (this.g) this.g.alpha = base * pulseFactor;
    if (this.layer1) this.layer1.alpha = noiseAlpha * 0.8;
    if (this.layer2) this.layer2.alpha = noiseAlpha;
  }
  _recalcParams() {
    // Map intensity to drift speeds (pixels per ms)
    const t = Math.max(0, Math.min(1, this.intensity / 100));
    const lerp = (a, b, u) => a + (b - a) * u;
    // Two layers drifting in different directions
    this.speed1 = { x: lerp(0.005, 0.025, t), y: lerp(0.0, 0.012, t) };
    this.speed2 = { x: lerp(-0.006, -0.018, t), y: lerp(0.004, 0.02, t) };
  }
  // Static helper: generate small grayscale noise texture
  static _createNoiseTexture(w = 128, h = 128) {
    const canvas = document.createElement('canvas');
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');
    const img = ctx.createImageData(w, h);
    // Use a gentle noise range to avoid harsh contrast
    for (let i = 0; i < img.data.length; i += 4) {
      const v = 200 + Math.floor(Math.random() * 55); // 200..254
      img.data[i] = v;
      img.data[i + 1] = v;
      img.data[i + 2] = v;
      img.data[i + 3] = 255;
    }
    ctx.putImageData(img, 0, 0);
    return Texture.from(canvas);
  }
}
import { Graphics } from 'pixi.js';
// Snow system: slow fluttering flakes with varied speeds; stop on blocks without bouncing.
export default class WeatherSnow {
  constructor(container, api, getIntensity) {
    this.container = container;
    this.api = api;
    this.getIntensity = getIntensity || (() => 0);
    this.width = api.mapWidth * api.tileSize;
    this.height = api.mapHeight * api.tileSize;
    this.flakes = [];
    this.intensity = 0;
    const area = this.width * this.height;
    // Snow lasts longer; keep a tighter cap than rain for performance
    this.maxFlakes = Math.max(120, Math.floor(area / 3800));
  }
  setIntensity(v) {
    this.intensity = Math.max(0, Math.min(100, Number(v) || 0));
  }
  spawnOne() {
    const g = new Graphics();
    g.clear();
    // Slightly larger/more visible flakes on average
    const r = 1.2 + Math.random() * 2.0; // radius
    g.circle(0, 0, r);
    g.fill({ color: 0xffffff, alpha: 0.97 });
    const x = Math.random() * this.width;
    const y = -10 - Math.random() * 30;
    const speed = 40 + Math.random() * 80; // slower than rain, but a bit more range
    const drift = (Math.random() * 50 - 25); // horizontal drift
    g.x = x;
    g.y = y;
    this.container.addChild(g);
    this.flakes.push({ g, x, y, vx: drift, vy: speed, alive: true, settled: false, life: 1.0, phase: 'fall', restMs: 0 });
  }
  update(dtMs) {
    // adjust intensity dynamically
    this.setIntensity(this.getIntensity());
    // Constant-density controller to avoid wavey bursts
    const norm = Math.max(0, Math.min(1, this.intensity / 100));
    const scaled = Math.pow(norm, 1.15);
    let target = Math.floor(this.maxFlakes * scaled);
    if (scaled > 0 && target < 10) target = 10;
    const deficit = target - this.flakes.length;
    if (deficit > 0) {
      const maxPerFrame = 24; // slower than rain
      const smooth = Math.max(1, Math.ceil(target * 0.015));
      const toSpawn = Math.min(deficit, smooth, maxPerFrame);
      for (let i = 0; i < toSpawn; i++) this.spawnOne();
    }
    // Gentle over-target culling to keep density steady when slider decreases
    if (this.flakes.length > target) {
      const surplus = this.flakes.length - target;
      const toCull = Math.min(surplus, Math.max(1, Math.ceil(this.flakes.length * 0.015)));
      for (let i = 0; i < toCull; i++) {
        const f = this.flakes.pop();
        if (!f) break;
        try { f.g.parent && f.g.parent.removeChild(f.g); } catch {}
        try { f.g.destroy(); } catch {}
      }
    }
    const gAcc = 200; // gentle gravity
    const dt = dtMs / 1000;
    const toRemove = [];
    for (let i = 0; i < this.flakes.length; i++) {
      const f = this.flakes[i];
      if (!f.alive) { toRemove.push(i); continue; }
      if (f.phase === 'fall') {
        f.vy = Math.min(140, f.vy + gAcc * dt);
        // small oscillation for flutter
        f.vx += Math.sin((f.y + i) * 0.02) * 7 * dt;
        let nx = f.x + f.vx * dt;
        let ny = f.y + f.vy * dt;
        // Liquid interaction first
        try {
          if (typeof this.api.getLiquidSurfaceY === 'function') {
            const sYwater = this.api.getLiquidSurfaceY('water', nx);
            if (Number.isFinite(sYwater) && ny >= sYwater) {
              // Land on water surface and rest for a bit
              ny = sYwater - 0.5;
              f.x = nx; f.y = ny; f.vx = 0; f.vy = 0;
              f.phase = 'rest';
              f.restMs = 800 + Math.random() * 400; // 0.8..1.2s
              // Do not continue to solid collision checks this frame
              // Update display and proceed to next flake
              f.g.x = f.x; f.g.y = f.y;
              continue;
            }
            const sYlava = this.api.getLiquidSurfaceY('lava', nx);
            if (Number.isFinite(sYlava) && ny >= sYlava) {
              // Steam puff and despawn
              if (typeof this.api.onLavaImpact === 'function') this.api.onLavaImpact({ x: nx, y: sYlava, strength: 0.5 });
              f.alive = false; toRemove.push(i); continue;
            }
          }
        } catch {}
        // Solid collision
        if (this.api.isSolidAt(nx, ny)) {
          // backtrack up to stand above the surface
          let guard = 0;
          while (this.api.isSolidAt(nx, ny) && guard < 10) { ny -= 1; guard++; }
          f.settled = true;
          f.vx = 0;
          f.vy = 0;
          f.phase = 'rest';
          f.restMs = 800 + Math.random() * 400;
        }
        f.x = nx;
        f.y = ny;
      } else if (f.phase === 'rest') {
        // Flake rests on surface for a short time (water or ground), then starts sinking/falling slowly
        f.restMs -= dtMs;
        if (f.restMs <= 0) {
          f.phase = 'sinking';
          // resume gentle fall with reduced alpha
          f.vx = (Math.random() * 20 - 10);
          f.vy = 20 + Math.random() * 20;
        }
      } else if (f.phase === 'sinking') {
        // Continue downward slowly; fade out progressively
        f.vy = Math.min(60, f.vy + gAcc * 0.3 * dt);
        f.x += f.vx * dt;
        f.y += f.vy * dt;
        f.life -= 0.22 * dt;
        if (f.life <= 0) { f.alive = false; toRemove.push(i); }
      }
      f.g.x = f.x;
      f.g.y = f.y;
      if (f.phase === 'rest' || f.phase === 'sinking' || f.settled) f.g.alpha = Math.max(0, Math.min(1, f.life));
      if (f.y > this.height + 40 || f.x < -40 || f.x > this.width + 40) {
        f.alive = false;
        toRemove.push(i);
      }
    }
    for (let j = toRemove.length - 1; j >= 0; j--) {
      const idx = toRemove[j];
      const f = this.flakes[idx];
      if (f && f.g && f.g.parent) f.g.parent.removeChild(f.g);
      if (f && f.g && f.g.destroy) try { f.g.destroy(); } catch {}
      this.flakes.splice(idx, 1);
    }
  }
  destroy() {
    this.flakes.forEach(f => {
      try { f.g.parent && f.g.parent.removeChild(f.g); } catch {}
      try { f.g.destroy(); } catch {}
    });
    this.flakes = [];
  }
}
import { Graphics, BlurFilter } from 'pixi.js';
// Thunder/Lightning weather effect
// API:
//   new WeatherThunder(container, api, getIntensity)
//   setIntensity(v), resize(w,h), update(dtMs), destroy()
// Notes:
// - Renders inside weather layer (below fog). Blocks/tiles remain above fog.
// - Picks random strike targets above solid tiles using api.isSolidAt(x,y).
export default class WeatherThunder {
  constructor(container, api, getIntensity) {
    this.container = container;
    this.api = api || {};
    this.getIntensity = getIntensity || (() => 0);
    this.width = (api?.mapWidth || 0) * (api?.tileSize || 32);
    this.height = (api?.mapHeight || 0) * (api?.tileSize || 32);
    this.intensity = 0;
    this.time = 0;
    this.nextStrikeMs = Infinity; // scheduled delay to next strike
    this.flashAlpha = 0; // global white flash
    this.flashDecay = 0.0;
    this.boltAlive = false;
    this.boltTime = 0; // ms since bolt spawned
    this.boltDuration = 0; // ms total
    // Graphics
    this.flashG = new Graphics();
    this.boltG = new Graphics();
    // Add slight glow to bolt
    try {
      this.boltG.filters = [new BlurFilter(2, 1)];
    } catch {}
    this.container.addChild(this.flashG);
    this.container.addChild(this.boltG);
    // Build once
    this._scheduleNextStrike(true);
  }
  setIntensity(v) {
    const nv = Math.max(0, Math.min(100, Number(v) || 0));
    if (nv === this.intensity) return;
    this.intensity = nv;
    if (nv <= 0) {
      // disable visuals
      this.flashAlpha = 0;
      this.boltAlive = false;
      this._redrawFlash();
      this._clearBolt();
      this.nextStrikeMs = Infinity;
    } else if (!Number.isFinite(this.nextStrikeMs) || this.nextStrikeMs === Infinity) {
      this._scheduleNextStrike(true);
    }
  }
  resize(w, h) {
    const W = Math.max(1, Math.floor(w));
    const H = Math.max(1, Math.floor(h));
    if (W === this.width && H === this.height) return;
    this.width = W;
    this.height = H;
    // redraw flash when active
    if (this.flashAlpha > 0) this._redrawFlash();
  }
  update(dtMs) {
    // live intensity updates
    const curInt = Math.max(0, Math.min(100, this.getIntensity()));
    if (curInt !== this.intensity) this.setIntensity(curInt);
    const dt = Math.max(0, Number(dtMs) || 16.67);
    if (this.intensity <= 0) return;
    // Update scheduling
    this.nextStrikeMs -= dt;
    if (this.nextStrikeMs <= 0) {
      // Perform strike: trigger screen flash and draw bolt
      this._triggerFlash();
      this._createBolt();
      this._scheduleNextStrike(false); // schedule next time after immediate strike window
    }
    // Flash decay
    if (this.flashAlpha > 0) {
      // exponential-like decay via linear factor raised with dt
      const decayPerMs = this.flashDecay || 0.004; // higher = quicker fade
      this.flashAlpha = Math.max(0, this.flashAlpha - decayPerMs * dt);
      this._redrawFlash();
    }
    // Bolt lifetime
    if (this.boltAlive) {
      this.boltTime += dt;
      const t = this.boltTime / Math.max(1, this.boltDuration);
      // Fade color/alpha over time
      const remain = Math.max(0, 1 - t);
      this.boltG.alpha = 0.25 + 0.75 * remain;
      if (this.boltTime >= this.boltDuration) {
        this._clearBolt();
      }
    }
  }
  destroy() {
    try { this.flashG.parent && this.flashG.parent.removeChild(this.flashG); } catch {}
    try { this.flashG.destroy(true); } catch {}
    try { this.boltG.parent && this.boltG.parent.removeChild(this.boltG); } catch {}
    try { this.boltG.destroy(true); } catch {}
    this.flashG = null;
    this.boltG = null;
    this.container = null;
  }
  // Internal helpers
  _scheduleNextStrike(initial) {
    // Map intensity 1..100 to delay: from ~9000..6000 ms down to ~2500..1000 ms
    if (this.intensity <= 0) { this.nextStrikeMs = Infinity; return; }
    const t = Math.max(0, Math.min(1, this.intensity / 100));
    const minDelay = this._lerp(1000, 2500, 1 - t); // at high intensity, between 1â€“2.5s
    const maxDelay = this._lerp(2500, 9000, 1 - t); // at low intensity, up to ~9s
    const delay = this._rand(minDelay, maxDelay);
    this.nextStrikeMs = initial ? this._rand(400, 1400) : delay; // first strike quicker on enable
  }
  _triggerFlash() {
    // Brightness based on intensity, with slight randomness
    const t = Math.max(0, Math.min(1, this.intensity / 100));
    const base = this._lerp(0.25, 0.9, t);
    this.flashAlpha = Math.min(1, base * this._rand(0.8, 1));
    // fade time scales with intensity (brighter fades a bit slower)
    this.flashDecay = this._lerp(0.008, 0.004, t);
    this._redrawFlash();
  }
  _redrawFlash() {
    const g = this.flashG;
    g.clear();
    if (this.flashAlpha <= 0) return;
    g.rect(0, 0, this.width, this.height);
    g.fill({ color: 0xffffff, alpha: this.flashAlpha });
  }
  _createBolt() {
    // Determine target using solid scan from top
    const W = this.width, H = this.height;
    const x = Math.floor(this._rand(8, W - 8));
    const topY = -Math.floor(this._rand(10, 40)); // start slightly above top
    const targetY = this._findGroundY(x, H);
    const endY = Number.isFinite(targetY) ? Math.max(0, targetY - this._rand(8, 16)) : Math.floor(H * 0.6);
    // Build polyline with jittered segments from top to end
    const segments = Math.max(8, Math.floor((endY - topY) / this._rand(10, 16)));
    const jitterX = this._lerp(6, 18, Math.max(0, Math.min(1, this.intensity / 100)));
    const points = [];
    let cx = x;
    let cy = topY;
    points.push({ x: cx, y: cy });
    for (let i = 1; i <= segments; i++) {
      const ny = topY + Math.floor(((endY - topY) * i) / segments);
      const nx = x + this._rand(-jitterX, jitterX);
      cx = nx; cy = ny;
      points.push({ x: cx, y: cy });
    }
    // Draw main bolt
    const g = this.boltG;
    g.clear();
    const thickness = this._lerp(2, 5, Math.max(0, Math.min(1, this.intensity / 100)));
    const color = 0xCCEEFF;
    g.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) g.lineTo(points[i].x, points[i].y);
    g.stroke({ width: thickness, color, alpha: 1, alignment: 0.5, cap: 'round', join: 'round' });
    // Branches: some short forks from random mid points
    const branchCount = Math.floor(this._lerp(1, 3, Math.max(0, Math.min(1, this.intensity / 100))));
    for (let b = 0; b < branchCount; b++) {
      const idx = Math.floor(this._rand(2, points.length - 2));
      const p = points[idx];
      const len = this._rand(30, 80);
      const ang = this._rand(-Math.PI * 0.5, Math.PI * 0.5);
      const bx = p.x + Math.cos(ang) * len;
      const by = p.y + Math.sin(ang) * len;
      g.moveTo(p.x, p.y);
      g.lineTo(bx, by);
      g.stroke({ width: Math.max(1, thickness * 0.55), color, alpha: 0.9, alignment: 0.5 });
    }
    this.boltAlive = true;
    this.boltTime = 0;
    this.boltDuration = this._rand(120, 260); // very brief
    this.boltG.alpha = 1;
  }
  _clearBolt() {
    if (!this.boltG) return;
    this.boltAlive = false;
    this.boltTime = 0;
    this.boltDuration = 0;
    try { this.boltG.clear(); } catch {}
  }
  _findGroundY(worldX, maxH) {
    // Scan from top to bottom to find first solid tile boundary
    const isSolid = this.api?.isSolidAt;
    if (typeof isSolid !== 'function') return null;
    for (let y = 0; y < maxH; y += 4) {
      if (isSolid(worldX, y)) {
        return y;
      }
    }
    return null;
  }
  _rand(a, b) {
    if (b === undefined) { b = a; a = 0; }
    return a + Math.random() * (b - a);
  }
  _lerp(a, b, t) { return a + (b - a) * t; }
}