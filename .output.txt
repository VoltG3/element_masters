diff --git a/src/Pixi/layers/ParallaxBackground.js b/src/Pixi/layers/ParallaxBackground.js
index 64d017f..ca9a38b 100644
--- a/src/Pixi/layers/ParallaxBackground.js
+++ b/src/Pixi/layers/ParallaxBackground.js
@@ -1,104 +1,139 @@
-import { TilingSprite, Sprite, Texture, WRAP_MODES, BlurFilter } from 'pixi.js';
+import { TilingSprite, Sprite, Texture, WRAP_MODES, BlurFilter, Assets } from 'pixi.js';

-// Parallax background helper. Manages a single tiling sprite (or solid sprite) inside a given container.
-// API:
-//   const par = new ParallaxBackground(container, textureCache);
-//   par.build({ worldWidth, worldHeight, url, color, factor });
-//   par.setScroll(cameraX, factor);
-//   par.destroy();
+// Parallax background helper. Manages background layers (solid color and image).
 export class ParallaxBackground {
   constructor(container, textureCache) {
     this.container = container;
     this.cache = textureCache;
-    this.sprite = null;
+    this.bgSprite = null; // Solid color layer
+    this.imgSprite = null; // Image layer
     this._worldW = 0;
     this._worldH = 0;
+    this._lastCameraX = 0;
   }

   build({ worldWidth, worldHeight, url, color, factor = 0.3 }) {
-    const layer = this.container;
-    if (!layer) return;
+    if (!this.container) return;
     this.clear();

     this._worldW = worldWidth;
     this._worldH = worldHeight;

+    // 1. Render solid color background FIRST (always present as base)
+    const hex = (typeof color === 'string' && color.startsWith('#'))
+      ? parseInt(color.slice(1), 16)
+      : (Number(color) || 0x87CEEB);
+
+    const solid = new Sprite(Texture.WHITE);
+    solid.tint = hex;
+    solid.width = worldWidth;
+    solid.height = worldHeight;
+    solid.alpha = 1.0;
+    try {
+      solid.filters = [new BlurFilter({ strength: 0.8, quality: 2 })];
+    } catch {}
+    this.container.addChild(solid);
+    this.bgSprite = solid;
+
+    // 2. If URL is provided, attempt to load and render image on top
     if (url) {
-      const tex = this.cache?.get(url) || Texture.from(url);
+      const setupImage = (tex) => {
+        if (!this.container) return;
+
+        // Remove old image if any
+        if (this.imgSprite) {
+          try { this.container.removeChild(this.imgSprite); } catch {}
+          try { this.imgSprite.destroy(); } catch {}
+          this.imgSprite = null;
+        }
+
+        if (!tex) {
+          console.warn('[ParallaxBackground] setupImage called with no texture');
+          return;
+        }

-      // Validate texture is loaded and has dimensions
-      if (!tex || (!tex.height && !tex.baseTexture?.height)) {
-        console.warn('ParallaxBackground: invalid texture, falling back to solid color');
-        // Fall through to solid color rendering below
-      } else {
-        if (tex?.baseTexture) tex.baseTexture.wrapMode = WRAP_MODES.REPEAT;
+        // Fix wrap mode for tiling
+        if (tex.baseTexture) tex.baseTexture.wrapMode = WRAP_MODES.REPEAT;
+        if (tex.source) tex.source.addressMode = 'repeat';

         const sprite = new TilingSprite({ texture: tex, width: worldWidth, height: worldHeight });
-        // Fit the height exactly, preserve horizontal scale (tileScale.x = 1)
-        const texH = (tex.height || tex.baseTexture?.height || 1);
+        const texH = (tex.height || (tex.source ? tex.source.height : 0) || 1);
         const scaleY = worldHeight / texH;
         sprite.tileScale.set(1, scaleY);
-        sprite.x = 0;
-        sprite.y = 0;
-        sprite.alpha = 0.9;
+        sprite.alpha = 1.0;
         try {
           sprite.filters = [new BlurFilter({ strength: 1.2, quality: 2 })];
         } catch {}
-        layer.addChild(sprite);
-        this.sprite = sprite;
-        // initial scroll
-        this.setScroll(0, factor);
-        return; // Exit early on success
-      }
-    }
+
+        this.container.addChild(sprite);
+        this.imgSprite = sprite;
+        this.setScroll(this._lastCameraX || 0, factor);
+      };

-    // Fallback: render solid color (if no url or texture invalid)
-    {
-      const hex = (typeof color === 'string' && color.startsWith('#'))
-        ? parseInt(color.slice(1), 16)
-        : (Number(color) || 0x87CEEB);
-      const solid = new Sprite(Texture.WHITE);
-      solid.tint = hex;
-      solid.width = worldWidth;
-      solid.height = worldHeight;
-      solid.alpha = 0.95;
+      // Try to get from Assets cache or Texture cache
+      let tex = null;
       try {
-        solid.filters = [new BlurFilter({ strength: 0.8, quality: 2 })];
-      } catch {}
-      layer.addChild(solid);
-      this.sprite = solid;
+        tex = Assets.get(url);
+      } catch (e) {
+        tex = this.cache?.get(url) || Texture.from(url);
+      }
+
+      const isValid = tex && (
+        tex.valid ||
+        (tex.baseTexture && tex.baseTexture.valid) ||
+        (tex.source && tex.source.width > 0)
+      );
+
+      if (isValid) {
+        console.log('[ParallaxBackground] Texture already ready');
+        setupImage(tex);
+      } else if (tex) {
+        console.log('[ParallaxBackground] Texture not ready, waiting...');
+        tex.once('update', () => {
+          console.log('[ParallaxBackground] Texture update event received');
+          setupImage(tex);
+        });
+      }
     }
   }

   setScroll(cameraX, factor = 0.3) {
-    if (!this.sprite) return;
-    if ('tilePosition' in this.sprite) {
-      this.sprite.tilePosition.x = -cameraX * factor;
-      this.sprite.tilePosition.y = 0;
+    this._lastCameraX = cameraX;
+    if (this.imgSprite && 'tilePosition' in this.imgSprite) {
+      this.imgSprite.tilePosition.x = -cameraX * factor;
+      this.imgSprite.tilePosition.y = 0;
     }
   }

   resize(worldWidth, worldHeight) {
-    if (!this.sprite) return;
     this._worldW = worldWidth;
     this._worldH = worldHeight;
-    this.sprite.width = worldWidth;
-    this.sprite.height = worldHeight;
-    const tex = this.sprite.texture;
-    const texH = (tex?.height || tex?.baseTexture?.height || 1);
-    if (this.sprite.tileScale && texH > 0) {
-      const scaleY = worldHeight / texH;
-      this.sprite.tileScale.set(1, scaleY);
+    if (this.bgSprite) {
+      this.bgSprite.width = worldWidth;
+      this.bgSprite.height = worldHeight;
+    }
+    if (this.imgSprite) {
+      this.imgSprite.width = worldWidth;
+      this.imgSprite.height = worldHeight;
+      const tex = this.imgSprite.texture;
+      const texH = (tex?.height || (tex?.source ? tex.source.height : 0) || 1);
+      if (this.imgSprite.tileScale && texH > 0) {
+        const scaleY = worldHeight / texH;
+        this.imgSprite.tileScale.set(1, scaleY);
+      }
     }
   }

   clear() {
-    const layer = this.container;
-    if (!layer) return;
-    if (this.sprite) {
-      try { layer.removeChild(this.sprite); } catch {}
-      try { this.sprite.destroy?.(); } catch {}
-      this.sprite = null;
+    if (this.bgSprite) {
+      try { this.container.removeChild(this.bgSprite); } catch {}
+      try { this.bgSprite.destroy(); } catch {}
+      this.bgSprite = null;
+    }
+    if (this.imgSprite) {
+      try { this.container.removeChild(this.imgSprite); } catch {}
+      try { this.imgSprite.destroy(); } catch {}
+      this.imgSprite = null;
     }
   }
